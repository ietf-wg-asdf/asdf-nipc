---
title: An Application Layer Interface for Non-IP device control (NIPC)
abbrev: NIPC
docname: draft-ietf-asdf-nipc-08
submissionType: IETF
category: std

ipr: trust200902
keyword: Internet-Draft

stand_alone: no
pi: [toc, sortrefs, symrefs]

author:
 - 
    ins: B. Brinckman
    name: Bart Brinckman
    org: Cisco Systems
    city: Brussels
    country: Belgium
    email: bbrinckm@cisco.com
 -
    ins: R. Mohan
    name: Rohit Mohan
    org: Cisco Systems
    street: 170 West Tasman Drive
    code: 95134
    city: San Jose
    country: USA
    email: rohitmo@cisco.com
 -
    ins: B. Sanford
    name: Braeden Sanford
    org: Philips
    city: Cambridge
    country: USA
    email: braeden.sanford@philips.com

informative:
  BLE53:
    title: Bluetooth Core Specification, Version 5.3
    author:
      -
        org: Bluetooth SIG
    date: 2021
  Zigbee22:
    title: zigbee Specification, Version 22 1.0
    author:
      -
        org: Connectivity Standards Alliance
    date: 2017
  Gatt-REST-API:
    title: A RESTful API used to access data in devices using the functionality defined in the Bluetooth GATT profile
    target: https://www.bluetooth.com/bluetooth-resources/gatt-rest-api/
    author:
      -
        org: Bluetooth SIG
    date: 2017

--- abstract

This memo specifies RESTful application layer interface for gateways 
providing operations against non-IP devices, as well as a CBOR-based 
publish-subscribe interface for streaming data. The described interfaces are
extensible. The specification also defines a protocol mapping function to
to map this interface to commonly used non-IP protocols. 

--- middle

# Introduction

## Scope

Low-power sensors, actuators and other connected devices introduced in
environments and use cases such as building management, healthcare, workplaces,
manufacturing, logistics and hospitality are often battery-powered. With 
limited power budget, they may not be able to support the IP protocol on their
wired or wireless interfaces, hence they support protocols that require a lower
power budget. Promiment examples of such protocols are {{BLE53}} and
{{Zigbee22}}. These devices typically do require to communicate with devices
or applications that are connected to IP-based networking infrastructure. 
Therefore, applications on the IP network that need to communicate or receive
telemetry from these non-IP low-power devices must do so through a gateway 
function on the IP network. This gateway functions then translates the 
communication to the non-IP protocol that the low-power device supports. 

~~~~~ aasvg
                                                               
    +-------------+              +---------+              +--------+
    | Application |<------------>| Gateway |<------------>| Non-IP |                     
    |    app      |   IP-based   |         |    Non-IP    | Device |
    +-------------+   Operation  +---------+   Operation  +--------+                 

~~~~~
{: #gw title="Gateway for non-IP Devices"}

There have been efforts to define Gateway functions for devices that support
a particular protocol, such as a BLE GATT REST API for BLE Gateways
({{Gatt-REST-API}}), however they have been limited to a single protocol or
a particular use case. In absence of an open standard describing how
applications on an IP network communicate with non-IP devices, bespoke and
vendor-specific implementations have proliferated. This results in parallel
infrastructure of both gateways and non-IP networks being deployed on a case
by case basis, each connecting separately into the IP network, with a distinct
set of APIs. At the same time, wireless access points supporting both IP-based 
wireless connectivity as well as non-IP based wireless technologies are
deployed ubiquitiously. Many of these wireless access points are equipped with
radios that can transmit and receive different frame types, such as {{BLE53}}
and {{Zigbee22}}. This specification aims to define a Gateway API for these 
Non-IP protocols that can be leveraged by this wireless infrastructure in order
to connect Non-IP devices into IP networks. The specification aims to be
extensible, in order to support existing and future non-IP protocols.

A standardized Non-IP Gateway interface has following benefits:

 - Avoid the need for parallel Non-IP infrastructure.
 - Avoid the need for applications to perform bespoke integrations for
   different environments.
 - Faster and more cost-effective adoption of Non-IP devices in IP network
   environments.

## Non-IP Gateway

A non-IP gateway MUST provide at least following functions:

 - Authentication and authorization of application clients that
   will leverage the gateway API to communicate with Non-IP devices.
 - Access to a database of onboarded devices. Onboarding ensures that 
   the Non-IP Gateway can identify a specific device and has sufficient context
   about the device to service gateway API requests.
 - The ability to consume an interaction model for a class of devices. This 
   allows the gateway to understand how to interact with a device.
 - An API that allows for bi-directional communication to non-IP devices.
 - One or more channels to process requests, responses, and asymmetric
   communications with the non-IP radio resources (Access Points)
   at its disposal.
 - The ability to stream telemetry received from non-IP devices in real-time
   to applications on the IP network.

The definition of the onboarding function is out of scope of this document, but
can be provided by a provisioning interface such as {{!RFC7644}} leveraging 
{{!I-D.ietf-scim-device-model}}. NIPC performs operations on a device or group
object, hence it requires device onboarding to be performed prior to performing
a NIPC operation on a device. NIPC APIs will reference a device or group id 
generated at the time of onboarding as a unique identifier. 

The Application gateway is a network function, so its goal is to proxy payloads 
between Non-IP and IP networks. It is not intended to be a middleware function
that interprets, decodes or modifies these payloads.

~~~~~ aasvg

                           +------------------------------------------+
                           |                                          |
  +-----------+   Request  |  +---------+                             |
  | onboarding+-------------->|  SCIM   |                             |
  |    app    |<--------------+ Server  |                             |
  +-----------+  Ctrl Endpt|  +---------+                             |
                           |                                          |
  +-----------+            |  +------------+   +-------+   +--------+ |
  |  Control  +----REST------>|    NIPC    +-->|  AP   +-->| Device | |
  |     &     |            |  |   Gateway  |   +-------+   +--------+ |
  | Telemetry |<--pub/sub-----+            |                          |
  |    Apps   |            |  +------------+                          |
  +-----------+            |                                          |
                           |            Network Deployment            |
                           +------------------------------------------+

~~~~~
{: #arch title="Basic Architecture"}

{{arch}} shows us applications, the NIPC application layer gateway (ALG),
an access point (AP), and a device (D). The applications, application layer
gateway and access point are deployed on an IP-Network. The AP supports a
Non-IP interface, which it uses to communicate with the device.
The Application is deployed in a different administrative domain than the
network elements (ALG & AP).
The role of the application layer gateway is to provide a gateway function
to applications wishing to communicate with non-IP devices in the network
domain served by the gateway.
Applications implementing Non-IP Control can leverage RESTful interfaces
to communicate with Non-IP devices in the network domain and subscribe to
events levering a CBOR-based pub/sub interface.

## Terminology

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in BCP
14 {{!RFC2119}} {{!RFC8174}} when, and only when, they appear in all
capitals, as shown here.

# Architecture

## Overview

Non-IP protocols, such as BLE or Zigbee, typically define a number of basic
operations that are similar across protocols. Examples of this are read and 
write data. NIPC provides a unified API to support those operations.

To perform NIPC operations on a device, the gateways needs 2 things:
1) Information about the instance of the device or thing: The device must be
onboarded on the gateway (e.g. by means of SCIM). This allows the NIPC Gateway
to retrieve the device object, identified by an id referenced in the path of 
the NIPC API.
2) Information about the interaction model: The Gateway must be able to perform
protocol-neutral operations, and hence requires a mapping of protocol-neutral
operations to protocol specific operations. These are supplied to the gateway
by means of an SDF model, described in {{!I-D.ietf-asdf-sdf}}.

~~~~~ aasvg

    +------------+   
    |    SCIM    |                      
    |   object   |           +----------------+          
    |    {id}    +---------->|                |
    +------------+           | NIPC Operation |
                             |    - Property  |
                             |    - Action    |
    +------------+           |    - Event     |
    |     SDF    +---------->|                |
    |    model   |           +----------------+
    +------------+  

~~~~~
{: #prereq title="NIPC prerequisites"}

Once these 2 prerequisites have been fulfilled, applications that are
authorized can perform NIPC operations on device ids. NIPC operations
are operations on properties, or constitute actions or events on devices,
as per the affordances defined in an SDF model.

## Onboarding

In order to perform a NIPC operation on a device, the device has to have its 
identity declared to the NIPC gateway. We refer to this as 'onboarding'. Apart
from the device identity, it is also necessary that the device object contains
all required information to bootstrap trust with the device, as well as
establish connectivity, as NIPC operations assume that connectivity is there. 
Allthough onboarding could theoretically be performed in other ways, it is
strongly recommended to leverage {{!RFC7644}} with
{{!I-D.ietf-scim-device-model}}, as the SCIM device schema has been developed
to contain all nessary attributes and extensions to support NIPC.

## Registrations 

NIPC registration APIs allow applications to declare information that is not
related to a device instance. Registrations can be information about an
interaction model for a class of devices, or information about an application
that is required to interact with the gateway.

### SDF model registrations

The SDF model for a class of devices determines how a gateway may interact with
these devices in a protocol-neutral way. In order to do that, the SDF model
must contain protocol mappings, mapping protocol-neutral SDF affordances
to protocol-specific ones. The SDF affordances supported by the device, as
well as its protcol-mappings, are provide to the gateway by means of an SDF
model registration. SDF models are described in {{!I-D.ietf-asdf-sdf}}. 

### Data application registration

An application authorized to perform NIPC operations on devices needs to be
able to define which applications can receive streaming event data from the
gateway. The data-app registration API allows mapping of an event to a data 
app as well as a protocol.

## Protocol mapping {#protocolmap}

An SDF model fully describes a thing, including all its SDF affordances. 
To leverage an SDF model to perform protocol specific operations on an
instance of that thing, a mapping of the SDF affordance to a protocol-specific
attribute is required. In NIPC, this is achieved through protocol mapping. 

Protocol mapping is required to map a protocol agnostic affordance to a 
protocol-specific operation, as implementations of the same affordance will
differ between protocols. For example BLE will address a property as a service
characteristic, while a property in Zigbee is addressed as a property in a
cluster of an endpoint. 

protocol mapping allows for integration of new protocols in NIPC, new mappings 
can be created without the need to update the base schema.

~~~~~ aasvg

  protocolmap
    |
    +-----> ble
    |        |
    |        +--> BLE property
    |
    +-----> zigbee
             |
             +--> Zigbee property

~~~~~
{: #protmap title="Property Mapping"}

As shown in {{protmap}}, protocol-specific properties must be embedded in a
protocolmap object, for example a "ble" or a "zigbee" object.


| Attribute | Req |   Type  |          Example                         |
+-----------+-----+---------+------------------------------------------|
| ble       |  T  |  object | an object with BLE-specific attributes   |
| zigbee    |  T  |  object | an object with Zigbee-specific attributes|
{: #proobj title="Protocol objects"}

where-

 - "ble" is an object containing properties that are specific to the BLE
   protocol.
 - "zigbee" is an object containing properties that are specific to the
   Zigbee protocol.
 - Other protocol mapping objects can be added by creating a new protocol
   object

Example protocol mapping:

~~~~~
"sdfObject": {
  "healthsensor": {
    "sdfProperty": {
      "heartrate": {
        "description": "The current measured heart rate",
        "type": "number",
        "unit": "beat/min",
        "observable": false,
        "writable": false,
        "protocolMap": {
          "ble": {
            "serviceID": "12345678-1234-5678-1234-56789abcdef4",
            "characteristicID": "12345678-1234-5678-1234-56789abcdef4"
          }
        }
      }
    }
  }
}
~~~~~
{: #exprotmap title="Example property mapping"}

A protocol map is provided as part of the SDF model, in the SDF affordance 
definition. Alternatively, it can be provided directly in a NIPC API.

## NIPC Operations {#nipc-ops}

NIPC operations are protocol-neutral operations on SDF affordances, more 
specifically properties, actions & events. NIPC operations can happen against
affordances that were registered in an SDF model. If connection management is
required to execute a NIPC operation, it is assumed that the gateway implictly
establishes and tears down required connections. 

### Properties APIs

Property APIs allow applications perform operations on properties, such as to
read or write values to them.

### Actions

Action APIs perform actions on devices, such as enabling or disabling a feature
on a device.

### Events

Event APIs allow apps to enable or disable event reporting on devices. Events
are reported over the events publish/subscribe interface.

### Connection management for NIPC Operations

For protocols that require connection management before executing an operation,
a NIPC gateway can perform implicit connection management. When executing a 
NIP operation, a NIPC Gateway can set up a connection with a device as well as
tear down the connection after the operation has completed. A NIPC Gateway
should support explicit connection management as well. Explicit connection
management can be used by an app that wants to perform multiple NIPC operations
in a single connection. Explicit connection management can be performed by 
calling the /devices/{id}/manage/connection action API. When after establishing an
explicit connection to a device, an application calls a NIPC Operation, the
Gateway will leverage the exissting connection and will also not tear the
connection down after the operation completes. The app will have to explicitly
close the connection. 

### Management APIs

Management APIs are APIs that perform device connection management and
protocol-specific operations, but do not use registered affordances. These APIs have embedded
protocol mappings. They require explicit connection management.

### Extensions {#extensions}

Extensions are not part of the core NIPC API specification, but 
extensions to it. Extensions are compound APIs. They leverage basic NIPC
operations but combine multiple operations in to one API call for efficiency.
An example of this is the the bulk operation, allowing to send multiple
operations in one operation. Extensions can be generic, IANA registered 
extentions, or vendor specific extensions.

## Events publish subscribe interface

Events are published on a publish/subscribe interface. Events can be of
different types:

- Streaming data from devices: Streaming data is activated/deactivated with the
  NIPC events API
- Broadcasts from devices
- Connection events: Devices connecting & disconnecting

## Protocols

### NIPC APIs

NIPC is a protocol that is based on RESTful HTTP {{!RFC9114}}. Along with HTTP
headers and URIs, NIPC uses JSON {{!RFC7159}} payloads to convey NIPC 
operations, such as registrations, actions, event and property operations. This
is the case for both request and response parameters, as well as errors.
NIPC uses the standard JSON media type "application/json", except for the SDF 
model registration APIs, where the media type reflects the content as an SDF 
model, and hence is media type "application/sdf+json".

### NIPC publish/subscribe events

NIPC publish/subscribe events are encoded in CBOR ({{!RFC8949}}) and can be
delivered over either:

- MQTT
- Webhook
- Websocket

## Paths

### General

The NIPC HTTP protocol is described in terms of a path relative to a Base URI.
The Base URI MUST NOT contain a query string, as clients MAY append additional 
path information and query parameters as part of forming the request.  The base
URI is a URL that most often consists of the "https" protocol scheme, a domain
name, and an initial path {{!RFC3986}}.  That initial path for NIPC is 
recommended to be /nipc.
For example:

      "https://example.com/nipc/"

Based on this a well_known URI {{!RFC8615}} of nipc can be defined.

Additionally a version number may be added, for example: 

      "https://example.com/nipc/v1/"

### NIPC Registrations

Registrations leverage the base path + /registration. NIPC supports SDF model
registrations and data-app registrations.

paths:

- /registration/model
- /registration/data-app

### NIPC Operations

Every NIPC Operations API pertains to either a device or group of devices, identified by
an id, hence the id will be reflected as the first parameter in the path. 
For example:

      "https://example.com/nipc/v1/{id}"

The second parameter in the path refers to the NIPC operation that the API will
perform on the device. This can be:

 - property
 - event
 - action
 - extension

These are described in {{nipc-ops}}.

## Schema

The NIPC schema leans heavily on the SDF schema, as defined in
{{!I-D.ietf-asdf-sdf}}. NIPC operations map directly to SDF affordances.

### SDF model registration

In order to perform a NIPC operation on a device, an SDF interaction model 
needs to be declared that provides protcol mappings for the SDF affordances
the operations will be performed on.

The SDF model can be registered by means of a registration API POST with 
the SDF model in the body of hte request. A registered SDF model can be 
fetched by a registration API GET with an sdfReference.

### NIPC Operations

NIPC operations require 2 key parameters:
1) A device ID identifying the device the operation should be executed on
2) an SDF reference for the SDF affordance the operations pertains to

#### Device ID

All NIPC operations are executed against a device or a group of devices.
Devices or groups of devices are identified by a unique uuid.

| Attribute     | Req |   Type  |          Example                     |
+---------------+-----+---------+--------------------------------------|
| id            |  T  |  uuid   | 12345678-1234-5678-1234-56789abcdef4 |
{: #devicedef title="Definition of a device our group of devices"}

Id is the unique uuid of the device. This id is generated when registering
the device, for example against a SCIM server. As such, this id is a common
identifier, known both to the application as well as the NIPC Server.

### SDFReferences

NIPC operations happen against SDF affordances and are referenced with an
sdfReference, which is the full path including the namespace.

The operations are either Properties, Events or Actions and their references
are of type string

For example:

| Attribute | Req |   Type  |          Example                               |
+-----------+-----+---------+------------------------------------------------|
| Property  |  T  |  string | https://example.com/heartrate#/sdfObject/thermostat/sdfProperty/temperature |
{: #nipcopsdef title="Definition of a NIPC operation on a property"}

### Responses 

A NIPC Gateway will respond to a NIPC operation request synchronously, and
provide the result of the completed operation in the HTTP response. 

The exception to the above are NIPC extensions, {{apiextensions}}. These contain 
compound statements, and thus require the gateway to execute multiple
NIPC operations. In this case the NIPC gateway will return HTTP status
code 202 after receiving the request and verifying it is able to execute it.
The client can then perform an HTTP GET of the extension API to get the
execution status for the request. If a callback URL was address was defined in
the request, the NIPC Gateway can optionally perform a callback with a
response to the compound request after the compound statement completes.

Actions also follow an asynchronous pattern, returning HTTP status code 202
when the action is accepted, along with a Location header pointing to the
action instance for status tracking.

A failure response will consist of a HTTP status code of 4xx or 5xx, and 
will follow the {{!RFC9457}} Problem Details format with `application/problem+json`
media type. The response will contain a `type` field with a URI identifying
the error type, and a human-readable `detail` field. The `type` field
is a URI and is described in {{errorhandling}}.

Failure response: 

Example of a failure response:

~~~~~
{
  "type": "https://www.iana.org/assignments/http-problem-types#nipc-invalid-id",
  "status": 400,
  "title": "Invalid Device ID",
  "detail": "Device ID 12345678-1234-5678-1234-56789abcdef4 does not exist or is not a device"
}
~~~~~
{: #failure title="Example failure response"}

where-

  - "type" is a URI identifying the specific error type
  - "status" is the HTTP status code
  - "title" is a brief, human-readable summary of the error type
  - "detail" is a human-readable explanation specific to this occurrence

# NIPC Registrations

NIPC allows an application to register an SDF model for a class of devices,
as well as a data application that will receive streaming data from the 
gateway.

## SDF model registration APIs

These APIs allow applications to register an SDF model for a class of devices.
These APIs use the `application/sdf+json` media type, as described in 
{{Section 7.1 of I-D.ietf-asdf-sdf}}.

### Register an sdf model

Method: `POST /registration/model`

Description: Registers an SDF model for a class of devices

Request Body:

 - an SDF model in JSON format, similar to the example in {{thermometer-sdf}}.

Response:

Example of a response:

~~~~~
[
  {
    "sdfName": "https://example.com/heartrate#/sdfObject/healthsensor"
  }
]
~~~~~
{:json #exregresp title="Example register sdf model response"}

where-

 - "sdfName" is the reference to the top-level sdfThing or sdfObject 
    in the SDF model

### Get all sdf models

Method: `GET /registration/model`

Description: Gets all sdf models registered with the gateway

Response:

Example of a response:

~~~~~
[
  {
    "sdfName": "https://example.com/heartrate#/sdfObject/healthsensor"
  }
]
~~~~~
{:json #exgetallresp title="Example get all sdf models response"}

where-

 - "sdfName" is the reference to the top-level sdfThing or sdfObject 
    in the SDF model

### Get an sdf model

Method: `GET /registration/model`

Description: Gets an sdf model registered with the gateway

Query Parameters: 

 - sdfName: the reference to the top-level sdfThing or sdfObject 
    in the SDF model.

Response:

The sdf model is returned in JSON format, similar to the example in 
{{thermometer-sdf}}.

### Delete an sdf model

Method: `DELETE /registration/model`

Description: Deletes an sdf model registered with the gateway

Query Parameters: 

 - sdfName: the reference to the top-level sdfThing or sdfObject 
    in the SDF model.

Response:

Example of a response:

~~~~~
{
  "sdfName": "https://example.com/heartrate#/sdfObject/healthsensor"
}
~~~~~
{:json #exdelresp title="Example delete sdf model response"}

where-

 - "sdfName" is the reference to the top-level sdfThing or sdfObject 
    in the SDF model

### Update an sdf model

Method: `PUT /registration/model`

Description: Updates an sdf model registered with the gateway

Query Parameters: 

 - sdfName: the reference to the top-level sdfThing or sdfObject 
    in the SDF model.

Request Body:

 - an SDF model in JSON format, similar to the example in {{thermometer-sdf}}.

Response:

Example of a response:

~~~~~
{
  "sdfName": "https://example.com/heartrate#/sdfObject/healthsensor"
}
~~~~~
{:json #exupresp title="Example update sdf model response"}

where-

 - "sdfName" is the reference to the top-level sdfThing or sdfObject 
    in the SDF model

## Data application registration APIs

These APIs allow applications to register a data application that will receive
streaming data from the gateway. These APIs operate on a data app ID.
This ID corresponds to the endpoint app ID of the telemetry endpoint app 
that is registered with the SCIM server. The endpoint app is defined in 
{{Section 6 of I-D.ietf-scim-device-model}}. 

### Register a data application

Method: `POST /registration/data-app`

Description: Registers a data application with the gateway

Query Parameters: 

 - dataAppId: the id of the data application

Request Body:

 - events: a list of events that the data application wants to receive
   streaming data for.

The request body also contains one of the following: 

 - mqttClient: an empty object that denotes that the data application
   is an MQTT client that will receive streaming data over MQTT
 - mqttBroker: an object that contains the MQTT broker information
   where the broker will publish the streaming data. 
    - URI: the URI of the MQTT broker
    - username: the username to authenticate with the MQTT broker
    - password: the password to authenticate with the MQTT broker
    - brokerCACert: the CA certificate of the MQTT broker (optional)
    - customTopic: the custom topic to publish the streaming data to
      (optional)
 - webhook: an object that contains a webhook URL along with any 
    credentials that are required to authenticate the webhook. 
    The webhook URL is the endpoint where the streaming data will be sent.
    - URI: the webhook URL
    - headers: An object that contains the headers to be sent with the webhook
      request. The headers can contain any authentication information
      required by the webhook server.
    - serverCACert: the CA certificate of the webhook server (optional)
 - websocket: an object that contains a websocket URL along with any 
   credentials that are required to authenticate the websocket. 
   The websocket URL is the endpoint where the streaming data will be sent.
    - URI: the websocket URL
    - headers: An object that contains the headers to be sent with the websocket
      request. The headers can contain any authentication information
      required by the websocket server.
    - serverCACert: the CA certificate of the websocket server (optional)

Example of a request body:

~~~~~
{
  "events": [
    {
      "event": "https://example.com/heartrate#/sdfObject/healthsensor/sdfEvent/fallDetected"
    }
  ],
  "mqttClient": {}
}
~~~~~
{:json #exregmqttclientrsp title="Example with mqttClient"}

Example of a request body for a data application that is an MQTT broker:

~~~~~
{
  "events": [
    {
      "event": "https://example.com/heartrate#/sdfObject/healthsensor/sdfEvent/fallDetected"
    }
  ],
  "mqttBroker": {
    "URI": "mqtt.example.com:1883",
    "username": "user",
    "password": "password",
    "customTopic": "custom/topic",
  }
}
~~~~~
{:json #exregmqttbrokerrsp title="Example with mqttBroker"}

Response:

If successful, the response will be identical to the request body. 

### Update a data application

Method: `PUT /registration/data-app`

Description: Updates a data application with the gateway

Query Parameters: 

 - dataAppId: the id of the data application

Request Body: Same as the request body for the register data application API.

Response: 

If successful, the response will be identical to the request body.

### Get a data application

Method: `GET /registration/data-app`

Description: Gets a data application registered with the gateway

Query Parameters: 

 - dataAppId: the id of the data application

Response:

The response will be identical to the request body for the register data
application API.

### Delete a data application

Method: `DELETE /registration/data-app`

Description: Deletes a data application registered with the gateway

Query Parameters: 

 - dataAppId: the id of the data application

Response:

The response will be identical to the request body for the register data
application API.

# NIPC APIs

The primary goal of the NIPC APIs is to exchange data with a Non-IP device, by
means of reading, writing or streaming NIPC properties to applications.

The NIPC APIs are divided into 3 categories:

 - NIPC Property APIs: These APIs allow applications to get and update device 
   properties.
 - NIPC Event APIs: These APIs allow applications to enable or disable event
   reporting on devices.
 - NIPC Action APIs: These APIs allow applications to perform actions on
   devices.
 - NIPC Management APIs: These APIs allow
   applications to manage device connections and perform protocol-specific
   operations.

An SDF model must be registered for the device in order to use these NIPC
Property, Event and Action APIs. The SDF model can be a top-level sdfThing with
multiple sdfObjects or a top-level sdfObject. These APIs depend on the SDF 
affordance (i.e. sdfProperty, sdfEvent and sdfAction) objects defined in
the SDF model and a device ID that is defined in {{I-D.ietf-scim-device-model}}.
The SDF affordance can be referenced using the global name of the SDF affordance
as described in {{Section 4 of I-D.ietf-asdf-sdf}}.

The SDF global name will be used against the registered SDF model to 
determine the protocol-specific protocolMap that the NIPC API will operate on. 

## NIPC Property APIs

These APIs allow applications to get and update device properties. 
These operations may require a connection to the device to be established. 
This connection can be established as part of the same API call implicitly.
If a connection is already active for this device, the existing connection willi
be leveraged without modifying it.

These APIs support multiple media types based on Content-Type and Accept
headers to accommodate different data formats. 

When using `application/octet-stream`, the raw binary data is sent 
directly in the request/response body.
When using `application/json`, the request and response bodies follow 
the format shown in the examples above, with binary data encoded as 
base64 in the "value" field. 
For other content types, the data is transmitted according to the 
specific format requirements of that media type.

### Write multiple values

Method: `PUT /devices/{id}/properties`

Description: Write values to one or more properties on a device

Parameters: 

 - id: the id of the device

Request Body:

  - an array of properties to update, each containing a property and a value

Example body updating multiple properties:

~~~~~
[
  {
    "property": "https://example.com/heartrate#/sdfObject/thermostat/sdfProperty/temperature",
    "value": "dGVzdA=="
  },
  {
    "property": "https://example.com/heartrate#/sdfObject/thermostat/sdfProperty/humidity",
    "value": "eGVzdB=="
  }
]
~~~~~
{:json #exupmprop title="Example updating multiple properties"}

Response: 

Example of a response:

~~~~~
[
  {
    "property": "https://example.com/heartrate#/sdfObject/thermostat/sdfProperty/temperature",
    "value": "dGVzdA=="
  },
  {
    "property": "https://example.com/heartrate#/sdfObject/thermostat/sdfProperty/humidity",
    "value": "eGVzdB=="
  }
]
~~~~~
{:json #exupmresp title="Example update multiple properties response"}

where-

 - "properties" is an array of properties that were updated, each containing
   a property and a value

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Read multiple values

Method: `GET /devices/{id}/properties`

Description: Read values from one or more properties on a device

Parameters: 

 - id: the id of the device

Query Parameters:

 - propertyName: a comma separated list of properties to read

Response:

Example of a response:

~~~~~
[
  {
    "property": "https://example.com/heartrate#/sdfObject/thermostat/sdfProperty/temperature",
    "value": "dGVzdA=="
  },
  {
    "property": "https://example.com/heartrate#/sdfObject/thermostat/sdfProperty/humidity",
    "value": "eGVzdB=="
  }
]
~~~~~
{:json #exreadmresp title="Example read multiple properties response"}

where-

 - "property" is the property that was read from
 - "value" is the bytes that were read in base64 encoding

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

## NIPC Event APIs

These APIs allow applications to enable or disable event reporting on devices.
These operations may require a connection to the device to be established. This
connection can be established as part of the same API call implicitly. If a
connection is already active for this device, the existing connection will be
leveraged without modifying it.

The event is a global name reference to an `sdfEvent`. 

The ID in the path is the id of the device or group of devices.
An event can be enabled on a group of devices if it is supported by the
underlying protocol. For example, if the underlying protocol is BLE, 
the event can be enabled on a group of devices if the event is an 
advertisement event or connection status event.

If the data application registered for this event is an MQTT broker or 
client, the event is used to construct the MQTT topic for the event.
The topic is constructed using the data application ID, the default 
namespace for the event, and the event itself. For example, if the data 
application ID is `"12345678-1234-5678-1234-56789abcdef4"` 
and the event is 
`"https://example.com/thermometer#/sdfThing/thermometer/sdfEvent/isPresent"`,
the topic will be:

~~~~~
data-app/<dataAppId>/<namespace>/<json_pointer_to_sdf_event>

data-app/12345678-1234-5678-1234-56789abcdef4/thermometer/sdfObject/thermometer/sdfEvent/isPresent
~~~~~

A data application can subscribe to this topic using the topic or it 
can use MQTT wildcards to subscribe to `data-app/+/temperature/#` to 
receive all events for the `temperature` namespace.

If a custom topic is provided for an MQTT broker, the custom topic is
used as the MQTT topic instead.

### Enable event reporting

Method: `POST /devices/{id}/events`

Description: Enables an event on a specific device

Parameters: 

 - id: the id of the device

Query Parameters:

 - eventName: the event to enable

The eventName is a URL encoded string that is the absolute URI that is a global
name reference to an `sdfEvent`. 

Response:

Returns HTTP status code 201 Created with a Location header pointing to the created event instance.

Example of a successful response:

~~~~~
HTTP/1.1 201 Created
Location: /devices/12345678-1234-5678-1234-56789abcdef4/events?instanceId=87654321-4321-8765-4321-fedcba9876543
~~~~~

The Location header contains the URI for the created event instance, which can be used to check status or disable the event.

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Disable event reporting

Method: `DELETE /devices/{id}/events`

Description: Disables an event on a specific device

Parameters:

  - id: the id of the device or group of devices

Query Parameters:

  - instanceId: the instance ID of the event to disable (obtained from the Location header when the event was enabled)

Response:

Returns HTTP status code 204 No Content on successful disable.

~~~~~
HTTP/1.1 204 No Content
~~~~~

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Get event status

Method: `GET /devices/{id}/events`

Description: Get the status of an event on a specific device

Parameters:

  - id: the id of the device or group of devices

Query Parameters:

  - instanceId: the instance ID of the event to query

Response:

Example of a response:

~~~~~
{
  "event": "https://example.com/heartrate#/sdfObject/healthsensor/sdfEvent/fallDetected"
}
~~~~~
{:json #exgeteventresp title="Example get event status response"}

where "event" is the event URI that was enabled for this instance.

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Get status of multiple events

Method: `GET /devices/{id}/events`

Description: Get the status of one or more events on a specific device

Parameters:

 - id: the id of the device or group of devices

Query Parameters:

  - instanceId: a comma separated list of event instance IDs to filter by (optional)

Response: 

Example of a response:

~~~~~
[
  {
    "instanceId": "87654321-4321-8765-4321-fedcba9876543",
    "event": "https://example.com/heartrate#/sdfObject/healthsensor/sdfEvent/fallDetected"
  }
]
~~~~~
{:json #exgetmresp title="Example get multiple events status response"}

where-

 - "instanceId" is the unique instance ID for each enabled event
 - "event" is the event URI for each enabled event

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Enable event reporting on a group of devices

Method: `POST /groups/{id}/events`

Description: Enables an event on a group of devices

Parameters: 

 - id: the id of the group of devices

Query Parameters:

 - eventName: the event to enable

The eventName is a URL encoded string that is the absolute URI that is a global
name reference to an `sdfEvent`. 

Response:

Returns HTTP status code 201 Created with a Location header pointing to the created event instance.

Example of a successful response:

~~~~~
HTTP/1.1 201 Created
Location: /groups/12345678-1234-5678-1234-56789abcdef4/events?instanceId=87654321-4321-8765-4321-fedcba9876543
~~~~~

The Location header contains the URI for the created event instance, which can be used to check status or disable the event.

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Disable event reporting on a group of devices

Method: `DELETE /groups/{id}/events`

Description: Disables an event on a group of devices

Parameters:

  - id: the id of the group of devices

Query Parameters:

  - instanceId: the instance ID of the event to disable (obtained from the Location header when the event was enabled)

Response:

Returns HTTP status code 204 No Content on successful disable.

~~~~~
HTTP/1.1 204 No Content
~~~~~

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Get event status on a group of devices

Method: `GET /groups/{id}/events`

Description: Get the status of an event on a group of devices

Parameters:

 - id: the id of the group of devices

Query Parameters:

 - instanceId: the instance ID of the event to check

Response:

Example of a response:

~~~~~
{
  "event": "https://example.com/heartrate#/sdfObject/healthsensor/sdfEvent/fallDetected"
}
~~~~~
{:json #exgetgevntresp title="Example get group event status response"}

where "event" is the event URI that was enabled for this instance.

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Get status of multiple events on a group of devices

Method: `GET /groups/{id}/events`

Description: Get the status of one or more events on a group of devices

Parameters:

 - id: the id of the group of devices

Query Parameters:

  - instanceId: a comma separated list of event instance IDs to filter by (optional)

Response: 

Example of a response:

~~~~~
[
  {
    "instanceId": "87654321-4321-8765-4321-fedcba9876543",
    "event": "https://example.com/heartrate#/sdfObject/healthsensor/sdfEvent/fallDetected"
  }
]
~~~~~
{:json #exgetmgevntsresp title="Example get multiple group events status response"}

where-

 - "instanceId" is the unique instance ID for each enabled event
 - "event" is the event URI for each enabled event

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

## NIPC Action APIs

These APIs allow applications to perform actions on devices. These operations
may require a connection to the device to be established. This connection can
be established as part of the same API call implicitly. If a connection is
already active for this device, the existing connection will be leveraged
without modifying it.

### Perform an action

Method: `POST /devices/{id}/actions`

Description: Perform an action on a specific device

Parameters:

  - id: the id of the device

Query Parameters:

  - actionName: the action to perform

Request Body:

The request body is optional and can contain binary data if the underlying protocol 
allows an action with a value.

Response:

Actions are performed asynchronously. A successful request returns HTTP status code 202 Accepted 
with a Location header pointing to the action instance for status checking.

Example of a successful response:

~~~~~
HTTP/1.1 202 Accepted
Location: /devices/12345678-1234-5678-1234-56789abcdef4/actions?instanceId=87654321-4321-8765-4321-fedcba9876543
~~~~~

The Location header contains the URI for the action instance, which can be used to check the action status.

### Check action status

Method: `GET /devices/{id}/actions`

Description: Check the status of an action on a specific device

Parameters:

  - id: the id of the device

Query Parameters:

  - instanceId: the instance ID of the action (obtained from the Location header)

Response:

Example of a response:

~~~~~
{
  "status": "COMPLETED"
}
~~~~~
{:json #exactionstatusresp title="Example action status response"}

where "status" indicates the current state of the action (e.g., "IN_PROGRESS" or "COMPLETED").

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

## NIPC Management APIs

These APIs allow applications to manage device connections, but do not use
registered properties, events or actions. These APIs do not perform an implicit
connection, so a connection must be established before calling these APIs.

### Connect to a device

Method: `POST /devices/{id}/manage/connection`

Description: Connect to a device

Parameters:

  - id: the id of the device

Request Body:

  - Connection retry parameters
  - A protocol map object. In the case of BLE, if no protocol map is included,
    service discovery is performed to discover all supported properties when
    connecting to a device. Optionally, service discovery may be limited to
    properties defined in the "ble" protocol extension. The services to be 
    discovered can be added in an array. Property discover can be buffered
    across connections, so the API also supports caching parameters. 

Example body of a connection without specific discovery of properties:

~~~~~
{
  "retries": 3,
  "retryMultipleAPs": true
}
~~~~~
{:json #exconn title="Example connection"}

where-

 - "retries" defines the number of retries in case the operations does not 
   succeed
 - "retryMultipleAPs" can be used in case there is an infrastructure with 
   multiple access points or radios that can reach the device. If set to "true"
   a different access point may be used for retries.

In case the application would like to discover specific properties of a device,
a protocol mapping can be added that defines what properties should be
discovered.

Example body of a BLE connection with specific discovery of properties:

~~~~~
{
  "retries": 3,
  "retryMultipleAPs": true,
  "protocolMap": {
    "ble": {
      "services": [
        {
          "serviceID": "12345678-1234-5678-1234-56789abcdef4"
        }
      ],
      "cached": false,
      "cacheIdlePurge": 3600,
      "autoUpdate": true,
      "bonding": "default"
    }
  }
}
~~~~~
{:json #exconnprp title="Example connection with explicit discovery of connections"}

where in the BLE protocol object: 

 - "services" is an array of services defined by their serviceIDs.
 - "cached" refers to whether the services need to be cached for 
   subsequent connects, in order not to perform service discovery on
   each request.
 - "cacheIdlepurge" defines how long the cache should be maintained 
   before purging
 - some devices support notifications on changes in services, 
   "autoUpdate" allows the network to update services based on 
   notification (on by default)
 - "bonding" allows you to override the bonding method configured when 
   onboarding the device

Response:

Success responses include a protocol mapping with an array of 
discovered properties, as defined in the specific protocol.
For example, for BLE, this is an array of supported services, which in turn
contains an array of charateristics, which in turn contains an array of
descriptors, as shown in {{BLEservices}}.

~~~~~
    services
     - serviceID
        |
        |> characteristics
            - charactericID
            - flags
               |
               |> Descriptors
                   - descriptorID
~~~~~
{: #BLEservices title="BLE Services"}

Example of a response:

~~~~~
{
  "id": "12345678-1234-5678-1234-56789abcdef4",
  "protocolMap": {
    "ble": [
      {
        "serviceID": "12345678-1234-5678-1234-56789abcdef4",
        "characteristics": [
          {
            "characteristicID": "12345678-1234-5678-1234-56789abcdef4",
            "flags": [
              "read",
              "write"
            ],
            "descriptors": [
              {
                "descriptorID": "12345678-1234-5678-1234-56789abcdef4"
              }
            ]
          }
        ]
      }
    ]
  }
}
~~~~~
{:json #exconnresp title="Example connection response"}

where-

  - "id" is the id of the device
   - "protocolMap" contains an Array of BLE services as shown in
   {{BLEservices}}

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Update a connection

Method: `PUT /devices/{id}/manage/connection`

Description: Update cached ServiceMap for a device. Full service discovery will
be performed, unless specific services are described in the API body.

Parameters:

  - id: the id of the device

Request Body:

  - A protocol map object. In the case of BLE, if no protocol map is included,
    service discovery is performed to discover all supported properties when
    connecting to a device. Optionally, service discovery may be limited to
    properties defined in the "ble" protocol extension. The services to be 
    discovered can be added in an array. Property discover can be buffered
    across connections, so the API also supports caching parameters. 

Example body of an update connection:

~~~~~
{
  "protocolMap": {
    "ble": {
      "services": [
        {
          "serviceID": "12345678-1234-5678-1234-56789abcdef4"
        }
      ],
      "cached": false,
      "cacheIdlePurge": 3600,
      "autoUpdate": true
    }
  }
}
~~~~~
{:json #exupconn title="Example service discovery response"}

where in the BLE protocol object: 

 - "services" is an array of services defined by their serviceIDs
 - "cached" refers to whether the services need to be cached for 
   subsequent connects, in order not to perform service discovery on
   each request
 - "cacheIdlepurge" defines how long the cache should be maintained 
   before purging
 - some devices support notifications on changes in services, 
   "autoUpdate" allows the network to update services based on 
   notification (on by default)

Response:

Success responses include a protocol mapping with an array of 
discovered properties, as defined in the specific protocol.
For example, for BLE, this is an array of supported services, which in turn
contains an array of charateristics, which in turn contains an array of
descriptors, as shown in {{BLEservices}}.

Example of a response:

~~~~~
{
  "id": "12345678-1234-5678-1234-56789abcdef4",
  "protocolMap": {
    "ble": [
      {
        "serviceID": "12345678-1234-5678-1234-56789abcdef4",
        "characteristics": [
          {
            "characteristicID": "12345678-1234-5678-1234-56789abcdef4",
            "flags": [
              "read",
              "write"
            ],
            "descriptors": [
              {
                "descriptorID": "12345678-1234-5678-1234-56789abcdef4"
              }
            ]
          }
        ]
      }
    ]
  }
}
~~~~~
{:json #exupconnresp title="Example connection response"}

where-

  - "id" is the id of the device
   - "protocolMap" contains an Array of BLE services as shown in
   {{BLEservices}}

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Disconnect from a device

Method: `DELETE /devices/{id}/manage/connection`

Description: Disconnect from a device

Parameters:

  - id: the id of the device

Response:

Returns HTTP status code 200 OK with device ID on successful disconnect.

Example of a response:

~~~~~
{
  "id": "12345678-1234-5678-1234-56789abcdef4"
}
~~~~~
{:json #exdisconnresp title="Example disconnect response"}

where "id" is the id of the device.

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Get connection status

Method: `GET /devices/{id}/manage/connection`

Description: Get connection status for a device. Success when device(s)
is/are connected, includes service map for the device if available.
Failure when a device is not connected.

Parameters:

  - id: the id of the device

Response:

Example of a response:

~~~~~
{
  "id": "12345678-1234-5678-1234-56789abcdef4",
  "protocolMap": {
    "ble": [
      {
        "serviceID": "12345678-1234-5678-1234-56789abcdef4",
        "characteristics": [
          {
            "characteristicID": "12345678-1234-5678-1234-56789abcdef4",
            "flags": [
              "read",
              "write"
            ],
            "descriptors": [
              {
                "descriptorID": "12345678-1234-5678-1234-56789abcdef4"
              }
            ]
          }
        ]
      }
    ]
  }
}
~~~~~
{:json #exconnstatresp title="Example connection status response"}

where-

  - "id" is the id of the device
  - "protocolMap" contains an Array of BLE services as shown in {{BLEservices}}

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

# NIPC Extensibility

NIPC is extensible in two ways:
 
 - Protocol mapping: New protocol mapping can extend NIPC with support
   for new non-IP protocols
 - API extensions: API extensions leverage compound statements of basic NIPC
   action APIs to simplify common operations for applications.
 
## Protocol extensions

As described in {{protocolmap}}, NIPC supports mapping protocol specific
properties to NIPC properties. BLE and Zigbee are used as examples, but protocol
mapping is extensible to other protocols, so now non-IP protocols can be 
supported by NIPC without a schema change.

The protocol objects need to be extended with the new
protocol as well. Protocol objects will be extended as follows:

| Attribute  | Req |   Type |          Example                         |
+------------+-----+--------+------------------------------------------|
| ble        |  T  | object | an object with BLE-specific properties   |
| zigbee     |  T  | object | an object with Zigbee-specific properties|
| newProtocol|  T  | object | an object with newProtocol-specific props|
{: #newprotext title="Adding Protocol mappings"}

In the new protocol object, protocol specific properties can be added.

Protocol mappings need to be IANA registered.
 
## API extensions {#apiextensions}

/extension

The extension APIs allow for extensibility of the APIs, either IANA 
registered extensions or vendor-specific extensions.
Extension APIs must leverage the basic NIPC defined APIs and combine them in 
compound statements in order to streamline application operation against
devices, make operations more expediant and convenient in one API call.
In principle they do not add any basic functionality. In
the OpenAPI model {{NIPCextensions}} below, we have defined a few example 
extensions.

The extensions can contain long running operations, such as firmware updates,
or other bulk operations that can be performed on a device. For long 
running operations, the extension API will return a 202 Accepted status 
code and a location header with the URL to check the status of the operation.
The status of the operation can be checked by calling the status extension API
with the same device ID. The status extension API will return a 200 OK status code
when the operation is in progress. When the operation is complete, 
the status extension API will return a 303 See Other status code with a 
location header with the URL to check the status of the operation.
The GET operation on the extension API will return a 200 OK status code
with the actual response once the operation is complete.

# NIPC Error Handling
{: #errorhandling}

The error codes in the NIPC APIs use URI-based error type identifiers 
as defined in {{!RFC9457}} Problem Details for HTTP APIs. The error codes 
can be generic or specific to the API category. The error codes are 
organized into the following categories:

  - Generic: Broadly applicable errors, including authorization, 
    invalid identifiers, and generic failures.
  - Property APIs: Errors related to property APIs (read/write).
  - Event APIs: Errors related to event APIs (enable/disable).
  - Protocol specific: Errors related to protocol-specific operations.
  - Extension APIs: Errors related to extension APIs.

The specific error codes are defined in the table below:

| Error Code                                      | Description                                  | Category         |
|-------------------------------------------------|----------------------------------------------|------------------|
| nipc-invalid-id                                 | Invalid device ID or gateway doesn't recognize the ID | Generic          |
| nipc-invalid-sdf-url                            | Invalid SDF URL or SDF affordance not found   | Generic           |
| nipc-extension-operation-not-executed           | Operation was not executed since the previous operation failed | Generic |
| nipc-sdf-model-already-registered               | SDF model already registered                  | Generic           |
| nipc-sdf-model-in-use                           | SDF model in use                              | Generic           |
| nipc-property-not-readable                      | Property not readable                         | Property APIs     |
| nipc-property-not-writable                      | Property not writable                         | Property APIs     |
| nipc-event-already-enabled                      | Event already enabled                         | Event APIs        |
| nipc-event-not-enabled                          | Event not enabled                             | Event APIs        |
| nipc-event-not-registered                       | Event not registered for any data application | Event APIs        |
| nipc-protocolmap-ble-already-connected          | Device already connected                      | Protocol specific |
| nipc-protocolmap-ble-no-connection              | No connection found for device                | Protocol specific |
| nipc-protocolmap-ble-connection-timeout         | BLE connection timeout                        | Protocol specific |
| nipc-protocolmap-ble-bonding-failed             | BLE bonding failed                            | Protocol specific |
| nipc-protocolmap-ble-connection-failed          | BLE connection failed                         | Protocol specific |
| nipc-protocolmap-ble-service-discovery-failed   | BLE service discovery failed                  | Protocol specific |
| nipc-protocolmap-ble-invalid-service-or-characteristic | Invalid BLE service or characteristic ID | Protocol specific     |
| nipc-protocolmap-zigbee-connection-timeout      | Zigbee connection timeout                     | Protocol specific |
| nipc-protocolmap-zigbee-invalid-endpoint-or-cluster | Invalid Zigbee endpoint or cluster ID     | Protocol specific |
| nipc-extension-broadcast-invalid-data           | Invalid transmit data                         | Transmit APIs     |
| nipc-extension-firmware-rollback                | Firmware rollback                             | Extension APIs    |
| nipc-extension-firmware-update-failed           | Firmware update failed                        | Extension APIs    |
{: #errorcodes title="Error Codes"}

The appropriate HTTP status code is returned in the response. 

# Publish/Subscribe Interface

The publish/subscribe interface, or data streaming interface, is an MQTT
publishing interface. Pub/sub topics can be created and managed by means
of the /registration/data-app API.

In this memo, we propose the data format to be CBOR {{!RFC8949}}.

## CDDL Definition

We have a CDDL {{!RFC8610}} definition where we define the
DataSubscription struct that will be used by all the messages published 
to the MQTT broker. 

The DataSubscription struct is a CBOR map that will contain the raw data
in bytes and a timestamp of the data. Optionally, the message will also
have a deviceID that corresponds to the SCIM ID of the device if the 
payload is associated to a known device.

Other fields in the CDDL such as apMacAddress and rssi can be optionally
included but these fields can expose the underlying network topology.

Each message also has a subscription choice group that will define the
type of data that is being published.

Each MQTT message can be a collection of DataSubscription structs. This
collection is represented as DataBatch in the CDDL. 

~~~~ CDDL
{::include cddl/data_subscription.cddl}
~~~~
{:cddl}

## CBOR Examples

This section contains a few examples of the DataSubscription struct 
depicted in CBOR diagnostic notation.

~~~
[
  {
    "data": h'02011A020A0C16FF4C001007721F41B0392078',
    "deviceID": "75fde96d-886f-4ac0-a1d5-df79f76e7c9c",
    "timestamp": 1727484393,
    "bleAdvertisement": {
        "macAddress": "C1:5C:00:00:00:01",
        "rssi": -25
    }
  }
]
~~~
{: title="Onboarded BLE Device Advertisement" }

~~~
[
  {
    "data": h'02011A020A0C16FF4C001007721F41B0392078',
    "timestamp": 1727484393,
    "bleAdvertisement": {
        "macAddress": "C1:5C:00:00:00:01",
        "rssi": -25
    }
  }
]
~~~
{: title="Non-onboarded BLE Device Advertisement" }

~~~
[
  {
    "data": h'434630374346303739453036',
    "deviceID": "75fde96d-886f-4ac0-a1d5-df79f76e7c9c",
    "timestamp": 1727484393,
    "bleSubscription": {
        "serviceID": "a4e649f4-4be5-11e5-885d-feff819cdc9f",
        "characteristicID": "c4c1f6e2-4be5-11e5-885d-feff819cdc9f"
    }
  }
]
~~~
{: title="BLE GATT Notification" }

~~~
[
  {
    "deviceID": "75fde96d-886f-4ac0-a1d5-df79f76e7c9c",
    "timestamp": 1727484393,
    "bleConnectionStatus": {
        "macAddress": "C1:5C:00:00:00:01",
        "connected": true
    }
  }
]
~~~
{: title="BLE Connection status event" }

~~~
[
  {
    "data": h'434630374346303739453036',
    "deviceID": "75fde96d-886f-4ac0-a1d5-df79f76e7c9c",
    "timestamp": 1727484393,
    "zigbeeSubscription": {
        "endpointID": 1,
        "clusterID": 6,
        "attributeID": 12,
        "type": 1
    }
  }
]
~~~
{: title="Zigbee Attribute Notification" }

# Examples

This section contains a few examples on how applications can leverage 
NIPC operations to communicate with BLE and Zigbee devices.

## Property Read/Write

In this example, we will connect to a device and read and write from a
property.

The sequence of operations for this are:  

  - Onboard a device using the SCIM Interface (out of scope of this
    memo)
  - Register an SDF model for the device

    ~~~~~
    POST /registration/model
    Content-Type: application/sdf+json
    Accept: application/json
    Host: localhost
    
    { ... }

    HTTP/1.1 200 OK
    content-type: application/json

    {
      "sdfName": "https://example.com/thermometer#/sdfThing/thermometer"
    }
    ~~~~~

    Request Body: JSON object with the SDF model, from {{thermometer-sdf}}

  - Read a property from the BLE device

    ~~~~~
    GET /devices/12345678-1234-5678-1234-56789abcdef4/properties?propertyName=https://example.com/thermometer%23/sdfThing/thermometer/sdfProperty/device_name
    Accept: application/json
    Host: localhost
    
    HTTP/1.1 200 OK
    content-type: application/json
    
    [
      {
        "property": "https://example.com/thermometer#/sdfThing/thermometer/sdfProperty/device_name",
        "value": "dGVzdA=="
      }
    ]
    ~~~~~
 
  - Write to a property on the BLE device

    ~~~~~
    PUT /devices/12345678-1234-5678-1234-56789abcdef4/properties
    Content-Type: application/json
    Host: localhost
    
    [
      {
        "property": "https://example.com/thermometer#/sdfThing/thermometer/sdfProperty/device_name",
        "value": "dGVzdA=="
      }
    ]
    
    HTTP/1.1 200 OK
    content-type: application/json
    
    [
      {
        "property": "https://example.com/thermometer#/sdfThing/thermometer/sdfProperty/device_name",
        "value": "dGVzdA=="
      }
    ]
    ~~~~~

## Enabling an Event

In this example, we will onboard a device, and setup an advertisement
subscription event for that device.

The sequence of operations for this are:  

  - Onboard a device and endpoint app using the SCIM Interface (out of scope of this
   memo)
  - Register an SDF model for the device

    ~~~~~
    POST /registration/model
    Content-Type: application/sdf+json
    Accept: application/json
    Host: localhost
    
    { ... }

    HTTP/1.1 200 OK
    content-type: application/json

    [
      {
        "sdfName": "https://example.com/thermometer#/sdfThing/thermometer"
      }
    ]
    ~~~~~

    Request Body: JSON object with the SDF model, from {{thermometer-sdf}}
    
  - Register the data app with the event 

    ~~~~~
    POST /registration/data-app?dataAppId=23456789-1234-5678-1234-56789abcdef4
    Content-Type: application/json
    Accept: application/json
    Host: localhost

    {
      "events": [
        "https://example.com/thermometer#/sdfThing/thermometer/sdfEvent/isPresent"
      ],
      "mqttClient": {}
    }

    HTTP/1.1 200 OK
    content-type: application/json

    {
      "events": [
        "https://example.com/thermometer#/sdfThing/thermometer/sdfEvent/isPresent"
      ],
      "mqttClient": {}
    }
    ~~~~~

  - Enable the advertisement event

    ~~~~
    POST /devices/12345678-1234-5678-1234-56789abcdef4/events?eventName=https://example.com/thermometer%23/sdfThing/thermometer/sdfEvent/isPresent
    Host: localhost
    Content-Length: 0
    
    HTTP/1.1 201 Created
    Location: /devices/12345678-1234-5678-1234-56789abcdef4/events?instanceId=87654321-4321-8765-4321-fedcba9876543
    ~~~~

  - Check the status of the event

    ~~~~~
    GET /devices/12345678-1234-5678-1234-56789abcdef4/events?instanceId=87654321-4321-8765-4321-fedcba9876543
    Host: localhost
    
    HTTP/1.1 200 OK
    content-type: application/json
    
    {
      "event": "https://example.com/thermometer#/sdfThing/thermometer/sdfEvent/isPresent"
    }
    ~~~~~

# Security Considerations

## API authorization 

In order to enable a network wishing to offer NIPC ALG functions, the network
administrator authorizes application(s) to perform operations on the Gateway.
This happens out of band and may be accomplished by means of exchanging tokens
or public keys.
Authorization can be role-based. The 3 primary roles are:  

1. Onboarding: Authorize an onboarding application against a SCIM server
   co-located with the gateway.  
2. Control: Authorize applications that may control devices.
3. Data: Authorize applications that may receive telemetry.  
It is possible to further refine roles down to an API basis.

# IANA Considerations

This section provides guidance to the Internet Assigned Numbers Authority
(IANA) regarding registration of values related to NIPC, in accordance
with {{!RFC8126}}.

## Protocol mapping

## API extensions

## Well-known URIs

## Problem Details for HTTP APIs

--- back

# OpenAPI definition

The following non-normative model is provide for convenience of
the implementor.

~~~~~~
<CODE BEGINS>
file "openapi.yml"
{::include nipc-openapi/NIPC.yaml}
<CODE ENDS>
~~~~~~
{: #openAPI}

# Protocol mapping

NIPC requires that a protocol mapping be provided as part of the sdf
model for a device or have one provided using the NIPC action APIs with 
embedded protocol mapping. The protocol mapping is a JSON object that 
describes the underlying technology used to communicate with the device 
along with any additional information needed to communicate with the 
device.

The JSON format of the protocol mapping is provided as a non-normative
OpenAPI model for the convenience of the implementor. 

## Protocol mapping OpenAPI model

~~~~~~
<CODE BEGINS>
file "ProtocolMap.yaml"
{::include nipc-openapi/protocolmaps/ProtocolMap.yaml}
<CODE ENDS>
~~~~~~
{: #protocolmapmodel}

## Protocol map for BLE

~~~~~
<CODE BEGINS>
file "ProtocolMap-BLE.yaml"
{::include nipc-openapi/protocolmaps/ProtocolMap-BLE.yaml}
<CODE ENDS>
~~~~~~
{: #protocolmapble}

## Protocol map for Zigbee

~~~~~
<CODE BEGINS>
file "ProtocolMap-Zigbee.yaml"
{::include nipc-openapi/protocolmaps/ProtocolMap-Zigbee.yaml}
<CODE ENDS>
~~~~~~
{: #protocolmapzigbee}

# NIPC API extensions {#NIPCextensions}

The following OpenAPI models define a few example extensions to the 
NIPC API.

## NIPC API write binary blob extension

~~~~~
<CODE BEGINS>
file "Extension-Blob.yaml"
{::include nipc-openapi/extensions/Extension-Blob.yaml}
<CODE ENDS>
~~~~~

## NIPC API bulk operations extension

~~~~~
<CODE BEGINS>
file "Extension-Bulk.yaml"
{::include nipc-openapi/extensions/Extension-Bulk.yaml}
<CODE ENDS>
~~~~~

## NIPC API write file extension

~~~~~
<CODE BEGINS>
file "Extension-File.yaml"
{::include nipc-openapi/extensions/Extension-File.yaml}
<CODE ENDS>
~~~~~

## NIPC API firmware update extension

~~~~~
<CODE BEGINS>
file "Extension-Firmware.yaml"
{::include nipc-openapi/extensions/Extension-Firmware.yaml}
<CODE ENDS>
~~~~~

## NIPC API conditional read extension

~~~~~
<CODE BEGINS>
file "Extension-ReadConditional.yaml"
{::include nipc-openapi/extensions/Extension-ReadConditional.yaml}
<CODE ENDS>
~~~~~

## NIPC API property extensions

~~~~~
<CODE BEGINS>
file "Extension-Property.yaml"
{::include nipc-openapi/extensions/Extension-Property.yaml}
<CODE ENDS>
~~~~~

# Example SDF model with protocol mappings for BLE 
{: #thermometer-sdf}

~~~~~
<CODE BEGINS>
file "thermometer.sdf.json"
{::include nipc-sdf-example/thermometer.sdf.json}
<CODE ENDS>
~~~~~
{: title="Example SDF model with protocol mappings for BLE"}
