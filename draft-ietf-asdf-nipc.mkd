---
title: An Application Layer Interface for Non-IP device control (NIPC)
abbrev: NIPC
docname: draft-ietf-asdf-nipc-03
submissionType: IETF
category: std

ipr: trust200902
keyword: Internet-Draft

stand_alone: no
pi: [toc, sortrefs, symrefs]

author:
 - 
    ins: B. Brinckman
    name: Bart Brinckman
    org: Cisco Systems
    city: Brussels
    country: Belgium
    email: bbrinckm@cisco.com
 -
    ins: R. Mohan
    name: Rohit Mohan
    org: Cisco Systems
    street: 170 West Tasman Drive
    code: 95134
    city: San Jose
    country: USA
    email: rohitmo@cisco.com
 -
    ins: B. Sanford
    name: Braeden Sanford
    org: Philips
    city: Cambridge
    country: USA
    email: braeden.sanford@philips.com

informative:
  BLE53:
    title: Bluetooth Core Specification, Version 5.3
    author:
      -
        org: Bluetooth SIG
    date: 2021
  Zigbee22:
    title: zigbee Specification, Version 22 1.0
    author:
      -
        org: Connectivity Standards Alliance
    date: 2017
  Gatt-REST-API:
    title: A RESTful API used to access data in devices using the functionality
 defined in the Bluetooth GATT profile
    target: https://www.bluetooth.com/bluetooth-resources/gatt-rest-api/
    author:
      -
        org: Bluetooth SIG
    date: 2017

--- abstract

This memo specifies RESTful application layer interface for gateways 
providing operations against non-IP devices, as well as a CBOR-based 
publish-subscribe interface for streaming data. The described interfaces are
extensible. The specification also defines a protocol mapping function to
to map this interface to commonly used non-IP protocols. 

--- middle

# Introduction

## Scope

Low-power sensors, actuators and other connected devices introduced in
environments and use cases such as building management, healthcare, workplaces,
manufacturing, logistics and hospitality are often battery-powered. With 
limited power budget, they may not be able to support the IP protocol on their
wired or wireless interfaces, hence they support protocols that require a lower
power budget. Promiment examples of such protocols are {{BLE53}} and
{{Zigbee22}}. These devices typically do require to communicate with devices
or applications that are connected to IP-based networking infrastructure. 
Therefore, applications on the IP network that need to communicate or receive
telemetry from these non-IP low-power devices must do so through a gateway 
function on the IP network. This gateway functions then translates the 
communication to the non-IP protocol that the low-power device supports. 

~~~~~
                                                               
    +-------------+              +---------+              +--------+
    | Application |<------------>| Gateway |<------------>| Non-IP |                     
    |    app      |   IP-based   |         |    Non-IP    | Device |
    +-------------+   Operation  +---------+   Operation  +--------+                 

~~~~~
{: #gw title="Gateway for non-IP Devices"}

There have been efforts to define Gateway functions for devices that support
a particular protocol, such as a BLE GATT REST API for BLE Gateways
({{Gatt-REST-API}}), however they have been limited to a single protocol or
a particular use case. In absence of an open standard describing how
applications on an IP network communicate with non-IP devices, bespoke and
vendor-specific implementations have proliferated. This results in parallel
infrastructure of both gateways and non-IP networks being deployed on a case
by case basis, each connecting separately into the IP network, with a distinct
set of APIs. At the same time, wireless access points supporting both IP-based 
wireless connectivity as well as non-IP based wireless technologies are
deployed ubiquitiously. Many of these wireless access points are equipped with
radios that can transmit and receive different frame types, such as {{BLE53}}
and {{Zigbee22}}. This specification aims to define a Gateway API for these 
Non-IP protocols that can be leveraged by this wireless infrastructure in order
to connect Non-IP devices into IP networks. The specification aims to be
extensible, in order to support existing and future non-IP protocols.

A standardized Non-IP Gateway interface has following benefits:

 - Avoid the need for parallel Non-IP infrastructure.
 - Avoid the need for applications to perform bespoke integrations for
   different environments.
 - Faster and more cost-effective adoption of Non-IP devices in IP network
   environments.

## Non-IP Gateway

A non-IP gateway MUST provide at least following functions:

 - Authentication and authorization of application clients that
   will leverage the gateway API to communicate with Non-IP devices.
 - Access to a database of onboarded devices. Onboarding ensures that 
   the Non-IP Gateway can identify a specific device and has sufficient context
   about the device to service gateway API requests.
 - The ability to consume an interaction model for a class of devices. This 
   allows the gateway to understand how to interact with a device.
 - An API that allows for bi-directional communication to non-IP devices.
 - One or more channels to process requests, responses, and asymmetric
   communications with the non-IP radio resources (Access Points)
   at its disposal.
 - The ability to stream telemetry received from non-IP devices in real-time
   to applications on the IP network.

The definition of the onboarding function is out of scope of this document, but
can be provided by a provisioning interface such as {{!RFC7644}} leveraging 
{{!I-D.ietf-scim-device-model}}. NIPC performs operations on a device or group
object, hence it requires device onboarding to be performed prior to performing
a NIPC operation on a device. NIPC APIs will reference a device or group id 
generated at the time of onboarding as a unique identifier. 

The Application gateway is a network function, so its goal is to proxy payloads 
between Non-IP and IP networks. It is not intended to be a middleware function
that interprets, decodes or modifies these payloads.

~~~~~

                             +-----------------------------------+
                             |                                   |
    +-----------+   Request  |  +---------+                      |
    | onboarding|-------------->|  SCIM   |                      |
    |    app    |<--------------| Server  |                      |
    +-----------+  Ctrl Endpt|  +---------+                      |
                             |                                   |
    +-----------+            |  +------------+  +-------+  +--+  |
    |  Control  |>...REST....|.>|    NIPC    |..|  AP   |..|D |  |
    |     &     |            |  |   Gateway  |  +-------+  +--+  |
    | Telemetry |<..pub/sub..|.<|            |                   |
    |    Apps   |            |  +------------+                   |
    +-----------+            |                                   |
                             |       Network Deployment          |
                             +-----------------------------------+

~~~~~
{: #arch title="Basic Architecture"}

{{arch}} shows us applications, the NIPC application layer gateway (ALG),
an access point (AP), and a device (D). The applications, application layer
gateway and access point are deployed on an IP-Network. The AP supports a
Non-IP interface, which it uses to communicate with the device.
The Application is deployed in a different administrative domain than the
network elements (ALG & AP).
The role of the application layer gateway is to provide a gateway functioni
to applications wishing to communicate with non-IP devices in the network
domain served by the gateway.
Applications implementing Non-IP Control can leverage RESTful interfaces
to communicate with Non-IP devices in the network domain and subscribe to
events levering a CBOR-based pub/sub interface.

## Terminology

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in BCP
14 {{!RFC2119}} {{!RFC8174}} when, and only when, they appear in all
capitals, as shown here.

# Architecture

## Overview

Non-IP protocols, such as BLE or Zigbee, typically define a number of basic
operations that are similar across protocols. Examples of this are read and 
write data. NIPC provides a unified API to support those operations.

To perform NIPC operations on a device, the gateways needs 2 things:
1) Information about the instance of the device or thing: The device must be
onboarded on the gateway (e.g. by means of SCIM). This allows the NIPC Gateway
to retrieve the device object, identified by an id referenced in the path of 
the NIPC API.
2) Information about the interaction model: The Gateway must be able to perform
protocol-neutral operations, and hence requires a mapping of protocol-neutral
operations to protocol specific operations. These are supplied to the gateway
by means of an SDF model, described in {{!I-D.ietf-adsf-sdf}. 

~~~~~

    +------------+   
    |    SCIM    |                      
    |   object   |           +----------------+          
    |    {id}    |---------->|                |
    +------------+           | NIPC Operation |
                             |    - Property  |
                             |    - Action    |
    +------------+           |    - Event     |
    |     SDF    |---------->|                |
    |    model   |           +----------------+
    |            |
    +------------+  

~~~~~
{: #prereq title="NIPC prerequisites"}

Once these 2 prerequisites have been fulfilled, applications that are
authorized can perform NIPC operations on device ids. NIPC operations
are operations on properties, or constitute actions or events on devices,
as per the affordances defined in an SDF model.

## Onboarding

In order to perform a NIPC operation on a device, the device has to have its 
identity declared to the NIPC gateway. We refer to this as 'onboarding'. Apart
from the device identity, it is also necessary that the device object contains
all required information to bootstrap trust with the device, as well as
establish connectivity, as NIPC operations assume that connectivity is there. 
Allthough onboarding could theoretically be performed in other ways, it is
strongly recommended to leverage {{!RFC7644}} with
{{!I-D.ietf-scim-device-model}}, as the SCIM device schema has been developed
to contain all nessary attributes and extensions to support NIPC.

## Registrations 

NIPC registration APIs allow applications to declare information that is not
related to a device instance. Registrations can be information about an
interaction model of a device or group of devices, or information about an
application that is required to interact with the gateway.

### SDF model registrations

The SDF model for a device or group of devices determines how a gateway may
interact with a device or group of devices in a protocol-neutral way. 
In order to do that, the SDF model must contain protocol mappings, mapping 
protocol-neutral SDF affordances to protocol-specific ones.
The SDF afforndances supported by the device, as well as its protcol-mappings
are provide to the gatewat by means of an SDF model registration. SDF models
are described in {{!I-D.ietf-asdf-sdf}. 

### Data application registration

An application authorized to perform NIPC operations on devices needs to be
able to define which applications can receive streaming event data from the
gateway. The data-app registration API allows mapping of an event to a data 
app as well as a protocol.

## NIPC Operations {#nipc-ops}

NIPC operations are protocol-neutral operations on SDF affordances, more 
specifically properties, actions & events. NIPC operations can happen against
affordances that were registered in an SDF model. If connection management is
required to execute a NIPC operation, it is assumed that the gateway implictly
establishes and tears down required connections.

### Properties APIs

Property APIs allow applications perform operations on properties, such as to
read or write values to them.

### Actions

Action APIs perform actions on devices, such as enabling or disabling a feature
on a device.

### Events

Event APIs allow apps to enable or disable event reporting on devices. Events
are reported over the events publish/subscribe interface.

### Action APIs with embedded protocol mapping

Action APIs with embedded protocol mapping are APIs that perform actions on
devices, but do not use registered affordances. These APIs have embedded
protocol mappings. They allow for explicit connection management, which is
useful when executing multiple property operations and/or actions. In this case
implicit connections management may be less efficient. They also consist of
other operations such as broadcasts.

### Extensions

Extensions are not part of the core NIPC API specification, but 
extensions. Extensions are compound APIs. They leverage basic NIPC operations
but combine multiple operations in to one API call for efficiency.
An example of this is the the bulk operation, allowing to send multiple
operations in one operation. Extensions can be generic, IANA registered 
extentions, or vendor specific extensions.

## Events publish subscribe interface

Events are published on a publish/subscribe interface. Events can be of
different types:
- Streaming data from devices
- Broadcasts from devices
- Connection events: Devices connecting & disconnecting

## Protocols

### NIPC APIs

NIPC is a protocol that is based on RESTful HTTP {{!RFC9114}}. Along with HTTP
headers and URIs, NIPC uses JSON {{!RFC7159}} payloads to convey NIPC 
operations, such as registrations, actions, event and property operations. This
is the case for both request and response parameters, as well as errors.
NIPC uses the standard JSON media type "application/json", except for the SDF 
model registration APIs, where the media type reflects the content as an SDF 
model, and hence is media type "application/sdf+json".

### NIPC publish/subscribe events

NIPC publish/subscribe events are encoded in CBOR ({{!RFC8949}}) and can be
delivered over either:
- MQTT
- Webhook
- Websocket

## Paths

The NIPC HTTP protocol is described in terms of a path relative to a Base URI.
The Base URI MUST NOT contain a query string, as clients MAY append additional 
path information and query parameters as part of forming the request.  The base
URI is a URL that most often consists of the "https" protocol scheme, a domain
name, and an initial path {{!RFC3986}}.  That initial path for NIPC is 
recommended to be /nipc.
For example:

      "https://example.com/nipc/"

Based on this a well_known URI {{!RFC8615}} of nipc can be defined.

Additionally a version number may be added, for example: 

      "https://example.com/nipc/v1/"

Every NIPC API pertains to either a device or group of devices, identified by
an id, hence the id will be reflected as the first parameter in the path. 
For example:

      "https://example.com/nipc/v1/{id}"

The second parameter in the path refers to the NIPC operation that the API will
perform on the device. This can be:
 - property
 - event
 - action
 - registration
 - extension

These are described in {{nipc-ops}}.

## Base Schema

### Device 

All NIPC operations are executed against a device or a group of devices.
Devices or groups of devices are identified by a unique uuid.

| Attribute     | Req |   Type  |          Example                     |
+---------------+-----+---------+--------------------------------------|
| id            |  T  |  uuid   | 12345678-1234-5678-1234-56789abcdef4 |
{: #devicedef title="Definition of a device our group of devices"}

Id is the unique uuid of the device. This id is generated when registering
the device, for example against a SCIM server. As such this id is a common
identifier, known both to the application as well as the NIPC Server. 

### NIPC Operations

NIPC operations happen against SDF affordances and are referenced with an
sdfReference, which can either be the full path including the namespace, or 
and abbreviated reference.

The opererations are either Properties, Events or Actions and their references
are of type string

For example:

| Attribute | Req |   Type  |          Example                               |
+-----------+-----+---------+------------------------------------------------|
| Property  |  T  |  string | #/sdfObject/thermostat/sdfProperty/temperature |
{: #nipcopsdef title="Definition of a NIPC operation on a property"}

### SDF model registration

In order to perform NIPC operations, an SDF model needs to be registered

### Data app registration

## Protocol mapping {#protocolmap}

An SDF model can fully describe a thing, including all its SDF affordances. 
To leverage an SDF model to perform protocol specific operations on an
instance of that thing, a mapping of the SDF affordance to a protocol is
required. 

An object can support one or more communications protocols. Even though Non-IP
communications protocols all perform operations on properties, implementations
differ between protocols. For example BLE will address a property as a service
characteristic, while a property in Zigbee is addressed as a property in a 
cluster of an endpoint. 

In order for NIPC to support protocol-agnostic APIs, a property mapping is
required between a NIPC property and a protocol-specific property. A property
mapping can be done by means of a property registration API.

Property mapping allows for integration of new protocols in NIPC, new mappings 
can be created without the need to update the base schema.

~~~~~

     - property
        |
        |> BLE
        |     - BLE property
        |
        |> Zigbee
              - Zigbee property

~~~~~
{: #propmap title="Property Mapping"}

As shown in {{propmap}}, protocol-specific properties must be described in a
protocol object, for example a "ble" or a "zigbee" object.


| Attribute | Req |   Type  |          Example                         |
+-----------+-----+---------+------------------------------------------|
| ble       |  T  |  object | an object with BLE-specific attributes   |
| zigbee    |  T  |  object | an object with Zigbee-specific attributes|
{: #proobj title="Protocol objects"}

where-

 - "ble" is an object containing properties that are specific to the BLE
   protocol.
 - "zigbee" is an object containing properties that are specific to the
   Zigbee protocol.
 - Other protocol mapping objects can be added by creating a new protocol
   object

Example property mapping:

~~~~~
{
  "propertyID": "temperature",
  "ble": {
    "serviceID": "12345678-1234-5678-1234-56789abcdef4",
    "characteristicID": "12345678-1234-5678-1234-56789abcdef4",
    "long": false
  }
}
~~~~~
{: #expropmap title="Example property mapping"}

Protocol mapping allows applications to perform a one-time registration to
a propertyID for a property, and leverage the propertyID in all API calls 
that perform an operation on this property. It might be useful for applications
to directly use protocol objects in action APIs as well, therefore there are 
a limited set of APIs available that have protocol objects directly embedded 
in the API, in order to perform operations on properties without having to 
first register them.

### Response

As most operations have a common base schema, based on a device ID and a
property, so do responses. Every NIPC API returns a status in the response, as
well as a requestID, which allows for tracking and logging of requests and 
responses. If the operation was performed on a device or group, the ID is also
returned. If the operation is to read or write a property, the resulting value
is also returned. 

Success response:

| Attribute     | Req |   Type  |           Example                    |
+---------------+-----+---------+--------------------------------------|
| status        |  T  |  enum   | SUCCESS                              |
| id            |  F  |  uuid   | 12345678-1234-5678-1234-56789abcdef4 |
| requestID     |  F  |  uuid   | abcd0987-1234-5678-1234-56789abcdef4 |
{: #success title="Success response"}

Example success response:

~~~~~
{
  "status": "SUCCESS",
  "requestID": "12345678-5678-1234-5578-abcdef1234",
  "id": "12345678-1234-5678-1234-56789abcdef4",
}
~~~~~
{: #exsuccess title="Example success response"}

Failure responses additionally include an error code and optionally a reason,
which contains a textual explanation of the error.

Failure response:

| Attribute     | Req |   Type  |           Example                    |
+---------------+-----+---------+--------------------------------------|
| status        |  T  |  enum   | SUCCESS                              |
| id            |  F  |  uuid   | 12345678-1234-5678-1234-56789abcdef4 |
| requestID     |  F  |  uuid   | abcd0987-1234-5678-1234-56789abcdef4 |
| errorCode     |  T  |  int    | 12                                   |
| reason        |  T  |  string | "Not Found"                          |
{: #failure title="Failure response"}

where-

 - status is the status of the request, either "SUCCESS" or "FAILURE". 
   In case of failure an error code and reason are added.
 - id is the id the operation was executed against, found in the request
 - requestID is a correlation ID that can be used for end-to-end 
   tracing.  
 - errorCode is a numerical value representing the error. The various 
   codes are defined in {{errorhandling}}.
 - reason is a human readable explanation of why the error occurred.

Example failure response:

~~~~~
{
  "status": "FAILURE",
  "reason": "Not Found",
  "errorCode": 12,
  "requestID": "12345678-5678-1234-5578-abcdef1234"
}
~~~~~
{: #exfail title="Example failure response"}

# NIPC Registrations

NIPC allows an application to register properties to use in action APIs. NIPC
supports 2 types of registrations: Registrations for properties and 
registrations for events.

## Event registration

/registration/event

The event registration API allows an application to register an event for a
data application to a specified property. This event is mapped to an MQTT
pub/sub topic. By activating a subscription on one or more device(s) for that
property, streaming data will get published to the associated pub/sub topic
on MQTT.

Operations:

 - Register an event: POST
 - Update an event: PUT
 - Get configuration of one or more events: GET
 - Delete an event: DELETE

### Event registration API

#### Registering an event

Method: POST /registration/event

Description: Register an event to a property 

Parameters: None

Request Body:

 - An event name that matches to an MQTT pub/sub topic
 - The data format the event should be delivered in
 - The device or group id the event is valid for
 - Whether the event needs to be cached for replay
 - the data applications that can consume the events

Example body registering an event:

~~~~~
{
  "event": "enterprise/hospital/pulse_oximeter",
  "eventFormat": "default",
  "replay": false,
  "id": "12345678-1234-5678-1234-56789abcdef4",
  "type": "device",
  "dataApps": [
    {
      "dataAppID": "12345678-1234-5678-1234-56789abcdef4",
      "mqtt": {
        "brokerURI": "mqtt.broker.com:8883",
        "username": "user1",
        "password": "password1",
        "brokerCACert": "string"
      }
    }
  ],
  "propertyID": "temperature"
}
~~~~~
{: #exregeve title="Example registering an event"}

where-

 - "event" is the event identifier, which also maps to the MQTT topic name
 - "eventFormat" is the format the data stream is delivered in, either default
   (decorated with id and property) or just the payload 
 - "replay" defines whether the event should be cached for replay or not
 - "id" is the id of the device or group the event is valid for
 - "type" is the type if the id, either device or group
 - "dataApps" is an array of data applications that can subscribe to the event
 - "propertyID" is the propertyID that will be used in action APIs to activate
   this event

The dataApps array consists of following-

 - "dataAppID" is the identity of the data application either configured 
   administratively or through SCIM.
 - "mqtt" optional MQTT broker connection parameters, in case an external MQTT
   needs to be configured

Response:
Success responses include standard success response properties
as defined in {{success}} as well as all the attributes that were configured
from the request.

Example of a register event response:

~~~~~
{
  "status": "SUCCESS",
  "requestID": "12345678-5678-1234-5578-abcdef1234",
  "id": "12345678-1234-5678-1234-56789abcdef4",
  "event": "enterprise/hospital/pulse_oximeter",
  "eventFormat": "default",
  "replay": false,
  "type": "device",
  "dataApps": [
    {
      "dataAppID": "12345678-1234-5678-1234-56789abcdef4",
      "mqtt": {
        "brokerURI": "mqtt.broker.com:8883",
        "username": "user1",
        "password": "password1",
        "brokerCACert": "string"
      }
    }
  ],
  "propertyID": "temperature"
}
~~~~~
{: #exregeveresp title="Example register event response"}

where-

 - "id", "requestID" and "technology" are part of the standard {{success}} definition
 - "event" is the event identifier, which also maps to the MQTT topic name
 - "eventFormat" is the format the data stream is delivered in, either default 
   (decorated with id and property) or just the payload
 - "replay" defines whether the event should be cached for replay or not
 - "dataApps" is an array of data applications that can subscribe to the event
 - "propertyID" is the propertyID that will be used in action APIs to activate
   this event

The dataApps array consists of following-

 - "dataAppID" is the identity of the data application either configured 
   administratively or through SCIM.
 - "mqtt" optional MQTT broker connection parameters, in case an external MQTT
   needs to be configured

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

#### Updating a topic

Method: PUT /registration/event

Description: Update an existing event 

Parameters: None

Request Body:

 - An event name that matches to an MQTT pub/sub topic
 - The data format the event should be delivered in
 - The device or group id the event is valid for
 - Whether the event needs to be cached for replay
 - the data applications that can consume the events

Example body updating an event:

~~~~~
{
  "event": "enterprise/hospital/pulse_oximeter",
  "eventFormat": "default",
  "replay": false,
  "id": "12345678-1234-5678-1234-56789abcdef4",
  "type": "device",
  "dataApps": [
    {
      "dataAppID": "12345678-1234-5678-1234-56789abcdef4",
      "mqtt": {
        "brokerURI": "mqtt.broker.com:8883",
        "username": "user1",
        "password": "password1",
        "brokerCACert": "string"
      }
    }
  ],
  "propertyID": "temperature"
  "ble": {
    "type": "gatt",
    "serviceID": "12345678-1234-5678-1234-56789abcdef0",
    "characteristicID": "12345678-1234-5678-1234-56789abcdef1"
  }
}
~~~~~
{: #exupdeve title="Example updating an event"}

where-

 - "event" is the event identifier, which also maps to the MQTT topic name
 - "eventFormat" is the format the data stream is delivered in, either default
   (decorated with id and property) or just the payload
 - "replay" defines whether the event should be cached for replay or not
 - "id" is the id of the device or group the event is valid for
 - "type" is the type if the id, either device or group
 - "dataApps" is an array of data applications that can subscribe to the event
 - "propertyID" is the propertyID that will be used in action APIs to activate
   this event

The dataApps array consists of following-

 - "dataAppID" is the identity of the data application either configured
   administratively or through SCIM.
 - "mqtt" optional MQTT broker connection parameters, in case an external MQTT
   needs to be configured

The propertyID gets mapped to a protocol-specific property with a 
property mapping, through a protocol object-

Response:
Success responses include standard success response properties
as defined in {{success}} as well as all the attributes that were configured
from the request.

Example of an update register event response:

~~~~~
{
  "status": "SUCCESS",
  "requestID": "12345678-5678-1234-5578-abcdef1234",
  "id": "12345678-1234-5678-1234-56789abcdef4",
  "event": "enterprise/hospital/pulse_oximeter",
  "eventFormat": "default",
  "replay": false,
  "type": "device",
  "dataApps": [
    {
      "dataAppID": "12345678-1234-5678-1234-56789abcdef4",
      "mqtt": {
        "brokerURI": "mqtt.broker.com:8883",
        "username": "user1",
        "password": "password1",
        "brokerCACert": "string"
      }
    }
  ],
  "propertyID": "temperature"
  "ble": {
    "type": "gatt",
    "serviceID": "12345678-1234-5678-1234-56789abcdef0",
    "characteristicID": "12345678-1234-5678-1234-56789abcdef1"
  }
}
~~~~~
{: #exupdeveresp title="Example update event response"}

where-

 - "id", "requestID" and "technology" are part of the standard {{success}} 
   definition
 - "event" is the event identifier, which also maps to the MQTT topic name
 - "eventFormat" is the format the data stream is delivered in, either default
   (decorated with id and property) or just the payload
 - "replay" defines whether the event should be cached for replay or not
 - "dataApps" is an array of data applications that can subscribe to the event
 - "propertyID" is the propertyID that will be used in action APIs to activate
   this event

The dataApps array consists of following-

 - "dataAppID" is the identity of the data application either configured
   administratively or through SCIM.
 - "mqtt" optional MQTT broker connection parameters, in case an external MQTT
   needs to be configured

The propertyID gets mapped to a protocol-specific property with a
property mapping, through a protocol object-

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

#### Get configuration of one or more events

Method: GET /registration/event

Description: Gets the configuration of one or more events

Parameters: An event name. Multiple events can be added by comma-separated
attributes. If no parameters are present, all events are returned.

Response: A success response as in {{success}} with a "events" object
containing an array of returned event names with attributes defined in
{{exupdeve}}.

Example of a get event response:

~~~~~
{
  "status": "SUCCESS",
  "requestID": "12345678-5678-1234-5578-abcdef1234",
  "events": [
    {
      "ble": {
        "type": "gatt",
        "serviceID": "12345678-1234-5678-1234-56789abcdef0",
        "characteristicID": "12345678-1234-5678-1234-56789abcdef1"
      },
      "event": "enterprise/hospital/pulse_oximeter",
      "propertyID": "temperature",
      "eventFormat": "default",
      "replay": false,
      "id": "12345678-1234-5678-1234-56789abcdef4",
      "type": "device",
      "dataApps": [
        {
          "dataAppID": "12345678-1234-5678-1234-56789abcdef4",
          "mqtt": {
            "brokerURI": "mqtt.broker.com:8883",
            "username": "user1",
            "password": "password1",
            "brokerCACert": "string"
          }
        }
      ],
      "technology": "ble"
    },
    {
      "zigbee": {
        "endpointID": 1,
        "clusterID": 6,
        "propertyID": 16,
        "type": 1
      },
      "event": "enterprise/hospital/pulse_oximeter",
      "propertyID": "temperature",
      "eventFormat": "default",
      "replay": false,
      "id": "12345678-1234-5678-1234-56789abcdef4",
      "type": "device",
      "dataApps": [
        {
          "dataAppID": "12345678-1234-5678-1234-56789abcdef4",
          "mqtt": {
            "brokerURI": "mqtt.broker.com:8883",
            "username": "user1",
            "password": "password1",
            "brokerCACert": "string"
          }
        }
      ],
      "technology": "ble"
    }
  ]
}
~~~~~
{: #exgeteveresp title="Example get event response"}

where-

 - "id", "requestID" and "technology" are part of the standard {{success}}
   definition
 - "events" is an array of events

where an event-

 - "event" is the event identifier, which also maps to the MQTT topic name
 - "eventFormat" is the format the data stream is delivered in, either default
   (decorated with id and property) or just the payload
 - "replay" defines whether the event should be cached for replay or not
 - "id" is the id of the device or group the event is valid for
 - "type" is the type if the id, either device or group
 - "dataApps" is an array of data applications that can subscribe to the event
 - "propertyID" is the propertyID that will be used in action APIs to activate
   this event

The dataApps array consists of following-

 - "dataAppID" is the identity of the data application either configured
   administratively or through SCIM.
 - "mqtt" optional MQTT broker connection parameters, in case an external MQTT
   needs to be configured

The propertyID gets mapped to a protocol-specific property with a
property mapping, through a protocol object-

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

#### Delete one or more topics

Method: DELETE /registration/event

Description: Delete one or more events

Parameters: An event name. Multiple events can be added by comma-separated
attributes. If no parameters are present, all events are returned.

Response: A success response as in {{success}} with a "events" object
containing an array of returned event names with attributes defined in
{{exupdeve}}.

Example of a delete event response:

~~~~~
{
  "status": "SUCCESS",
  "requestID": "12345678-5678-1234-5578-abcdef1234",
  "events": [
    {
      "ble": {
        "type": "gatt",
        "serviceID": "12345678-1234-5678-1234-56789abcdef0",
        "characteristicID": "12345678-1234-5678-1234-56789abcdef1"
      },
      "event": "enterprise/hospital/pulse_oximeter",
      "propertyID": "temperature",
      "eventFormat": "default",
      "replay": false,
      "id": "12345678-1234-5678-1234-56789abcdef4",
      "type": "device",
      "dataApps": [
        {
          "dataAppID": "12345678-1234-5678-1234-56789abcdef4",
          "mqtt": {
            "brokerURI": "mqtt.broker.com:8883",
            "username": "user1",
            "password": "password1",
            "brokerCACert": "string"
          }
        }
      ],
      "technology": "ble"
    },
    {
      "zigbee": {
        "endpointID": 1,
        "clusterID": 6,
        "propertyID": 16,
        "type": 1
      },
      "event": "enterprise/hospital/pulse_oximeter",
      "propertyID": "temperature",
      "eventFormat": "default",
      "replay": false,
      "id": "12345678-1234-5678-1234-56789abcdef4",
      "type": "device",
      "dataApps": [
        {
          "dataAppID": "12345678-1234-5678-1234-56789abcdef4",
          "mqtt": {
            "brokerURI": "mqtt.broker.com:8883",
            "username": "user1",
            "password": "password1",
            "brokerCACert": "string"
          }
        }
      ],
      "technology": "ble"
    }
  ]
}
~~~~~
{: #exdeleveresp title="Example delete event response"}

where-

 - "id", "requestID" and "technology" are part of the standard {{success}}
   definition
 - "events" is an array of events

where an event-

 - "event" is the event identifier, which also maps to the MQTT topic name
 - "eventFormat" is the format the data stream is delivered in, either default
   (decorated with id and property) or just the payload
 - "replay" defines whether the event should be cached for replay or not
 - "id" is the id of the device or group the event is valid for
 - "type" is the type if the id, either device or group
 - "dataApps" is an array of data applications that can subscribe to the event
 - "propertyID" is the propertyID that will be used in action APIs to activate
   this event

The dataApps array consists of following-

 - "dataAppID" is the identity of the data application either configured
   administratively or through SCIM.
 - "mqtt" optional MQTT broker connection parameters, in case an external MQTT
   needs to be configured

The propertyID gets mapped to a protocol-specific property with a
property mapping, through a protocol object-

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

## Property registration

/registration/property
  
The property registration API allows an application to register a property
mapping against a protocol-specific property as decribed in {{propertymap}}

Operations:

 - Register a property: POST
 - Update a property: PUT
 - Get a property: GET
 - Delete a property: DELETE

### Property registration API

#### Registering a property

Method: POST /registration/property

Description: Register a property mapping to a protocol-specific property

Parameters: None

Request Body:

 - a property ID
 - a protocol object containing a protocol mapping

Example body registering a property:

~~~~~
{
  "propertyID": "temperature",
  "ble": {
    "serviceID": "12345678-1234-5678-1234-56789abcdef4",
    "characteristicID": "12345678-1234-5678-1234-56789abcdef4",
    "long": false
  }
}
~~~~~
{: #exregprop title="Example registering a property"}

where-

 - "propertyID" is the propertyID that will be used in action APIs to refer
   to this property mapping
 - A protocol object with a protocol-specific property map, as decribed in
   {{propertymap}}

Response:
Success responses include standard success response properties
as defined in {{success}} as well as all the attributes that were configured
from the request.

Example of a register property response:

~~~~~
{
  "status": "SUCCESS",
  "requestID": "12345678-5678-1234-5578-abcdef1234",
  "propertyID": "temperature",
  "ble": {
    "serviceID": "12345678-1234-5678-1234-56789abcdef4",
    "characteristicID": "12345678-1234-5678-1234-56789abcdef4",
    "long": false
  }
}
~~~~~
{: #exregpropresp title="Example register property response"}

where-

 - "id", "requestID" and "technology" are part of the standard {{success}}
   definition
 - "propertyID" is the propertyID that will be used in action APIs to refer
   to this property mapping
 - A protocol object with a protocol-specific property map, as decribed in
   {{propertymap}}

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

#### Updating a property

Method: PUT /registration/property

Description: Update a property mapping to a protocol-specific property

Parameters: None

Request Body:

 - a property ID
 - a protocol object containing a protocol mapping

Example body updating a property:

~~~~~
{
  "propertyID": "temperature",
  "ble": {
    "serviceID": "12345678-1234-5678-1234-56789abcdef4",
    "characteristicID": "12345678-1234-5678-1234-56789abcdef4",
    "long": false
  }
}
~~~~~
{: #exupdprop title="Example registering a property"}

where-

 - "propertyID" is the propertyID that will be used in action APIs to refer
   to this property mapping
 - A protocol object with a protocol-specific property map, as decribed in
   {{propertymap}}

Response:
Success responses include standard success response properties
as defined in {{success}} as well as all the attributes that were configured
from the request.

Example of an update property response:

~~~~~
{
  "status": "SUCCESS",
  "requestID": "12345678-5678-1234-5578-abcdef1234",
  "propertyID": "temperature",
  "ble": {
    "serviceID": "12345678-1234-5678-1234-56789abcdef4",
    "characteristicID": "12345678-1234-5678-1234-56789abcdef4",
    "long": false
  }
}
~~~~~
{: #exupdpropresp title="Example register property response"}

where-

 - "id", "requestID" and "technology" are part of the standard {{success}}
   definition
 - "propertyID" is the propertyID that will be used in action APIs to refer
   to this property mapping
 - A protocol object with a protocol-specific property map, as decribed in
   {{propertymap}}

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

#### Get property mapping of one or more properties

Method: GET /registration/property

Description: Gets the property mapping of one or more properties

Parameters: A property name. Multiple properties can be added by
comma-separated parameters. If no parameters are present, all properties
are returned.

Response: A success response as in {{success}} with an array of properties,
containing propertyID with protocol object containing a protocol-specific 
property mapping

Example of a get property response:

~~~~~
{
  "status": "SUCCESS",
  "requestID": "12345678-5678-1234-5578-abcdef1234",
  "properties": [
    {
      "ble": {
        "serviceID": "12345678-1234-5678-1234-56789abcdef4",
        "characteristicID": "12345678-1234-5678-1234-56789abcdef4",
        "long": false
      },
      "propertyID": "temperature"
    },
    {
      "zigbee": {
        "endpointID": 1,
        "clusterID": 6,
        "propertyID": 16,
        "type": 1
      },
      "propertyID": "temperature"
    }
  ]
}
~~~~~
{: #exgetpropresp title="Example get property response"}

where-

 - "id", "requestID" and "technology" are part of the standard {{success}}
   definition
 - "properties" is an array of properties

where a property-

 - "id", "requestID" and "technology" are part of the standard {{success}}
   definition
 - "propertyID" is the propertyID that will be used in action APIs to refer
   to this property mapping
 - A protocol object with a protocol-specific property map, as decribed in
   {{propertymap}}

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

#### Delete property mapping of one or more properties

Method: DELETE /registration/property

Description: Deletes the property mapping of one or more properties

Parameters: A property name. Multiple properties can be added by 
comma-separated parameters. If no parameters are present, all properties
are deleted.

Response: A success response as in {{success}} with an array of properties, 
containing propertyID with protocol object containing a protocol-specific   
property mapping

Example of a delete property response:

~~~~~
{
  "status": "SUCCESS",
  "requestID": "12345678-5678-1234-5578-abcdef1234",
  "properties": [
    {
      "ble": {
        "serviceID": "12345678-1234-5678-1234-56789abcdef4",
        "characteristicID": "12345678-1234-5678-1234-56789abcdef4",
        "long": false
      },
      "propertyID": "temperature"
    },
    {
      "zigbee": {
        "endpointID": 1,
        "clusterID": 6,
        "propertyID": 16,
        "type": 1
      },
      "propertyID": "temperature"
    }
  ]
}
~~~~~
{: #exdelpropresp title="Example delete property response"}

where-

 - "id", "requestID" and "technology" are part of the standard {{success}}
   definition
 - "properties" is an array of properties

where a property-

 - "id", "requestID" and "technology" are part of the standard {{success}}
   definition
 - "propertyID" is the propertyID that will be used in action APIs to refer
   to this property mapping
 - A protocol object with a protocol-specific property map, as decribed in
   {{propertymap}}

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

# NIPC APIs

The primary goal of the NIPC APIs is to exchange data with a Non-IP device, by
means of reading, writing or streaming NIPC properties to applications. 

The NIPC APIs are divided into 3 categories:

 - NIPC Property APIs: These APIs allow applications to get and update device 
   properties.
 - NIPC Event APIs: These APIs allow applications to enable or disable event reporting on devices.
 - NIPC Action APIs: These APIs allow applications to perform actions on devices.
 - NIPC Action APIs with embedded protocol mapping: These APIs allow applications to perform actions on devices, but do not use registered properties, events or actions.

An SDF model must be registered for the device in order to use these NIPC Property, Event and Action APIs.
The SDF model can be a top-level sdfThing with multiple sdfObjects or a top-level sdfObject.
These APIs depend on the SDF affordance (i.e. sdfProperty, sdfEvent and sdfAction) objects defined in the SDF model and a device ID that is defined in {{I-D.ietf-scim-device-model}}.
The SDF affordance can be referenced using the fragment identifier as described in {{I-D.ietf-asdf-sdf}}. In this case, the default namespace is assumed.
If there are multiple properties/events/actions with the same fragment identifier, the global name of the SDF affordance in the SDF model can be used as defined in {{Section 4 of I-D.ietf-asdf-sdf}}.

The SDF affordance name will be used against the registered SDF model to 
determine the protocol-specific protocolMap that the NIPC API will operate on. 
The fragment identifier or the global name must be percent-encoded to be used in the URL as per {{!RFC3986}}.

## NIPC Property APIs

These APIs allow applications to get and update device properties. 
These operations may require a connection to the device to be established. 
This connection can be established as part of the same API call implicitly.
If a connection is already active for this device, the existing connection will be leveraged without modifying it.

### Write a value

Method: `POST /{id}/property/{property}`

Description: Writes a value to a property on a device

Parameters: 

 - id: the id of the device
 - property: the property to write to

Request Body:

  - value: the bytes to be written in base64 encoding

Response:

Example of a write property response:

~~~~~
{
  "id": "12345678-1234-5678-1234-56789abcdef4",
  "property": "#/sdfObject/thermostat/sdfProperty/temperature",
  "value": "dGVzdA=="
}
~~~~~
{:json #exwrresp title="Example write property response"}

where-

 - "id" is the id of the device
 - "property" is the property that was written to
 - "value" is the bytes that were written in base64 encoding

A failure will generate a standard failed response. Please refer to {{failure}} definition of failed response.

### Read a value

Method: `GET /{id}/property/{property}`

Description: Reads a value from a property on a device

Parameters: 

 - id: the id of the device
 - property: the property to read from

Response:

Example of a read property response:

~~~~~
{
  "id": "12345678-1234-5678-1234-56789abcdef4",
  "property": "#/sdfObject/thermostat/sdfProperty/temperature",
  "value": "dGVzdA=="
}
~~~~~
{:json #exreresp title="Example read property response"}

where-

 - "id" is the id of the device
 - "property" is the property that was read from
 - "value" is the bytes that were read in base64 encoding

A failure will generate a standard failed response. Please refer to {{failure}} definition of failed response.

### Write multiple values

Method: `PUT /{id}/property`

Description: Write values to one or more properties on a device

Parameters: 

 - id: the id of the device

Request Body:

  - an array of properties to update, each containing a property and a value

Example body updating multiple properties:

~~~~~
{
  "properties": [
    {
      "property": "#/sdfObject/thermostat/sdfProperty/temperature",
      "value": "dGVzdA=="
    },
    {
      "property": "#/sdfObject/thermostat/sdfProperty/humidity",
      "value": "eGVzdB=="
    }
  ]
}
~~~~~
{:json #exupmprop title="Example updating multiple properties"}

Response: 

Example of a response:

~~~~~
{
  "id": "12345678-1234-5678-1234-56789abcdef4",
  "properties": [
    {
      "property": "#/sdfObject/thermostat/sdfProperty/temperature",
      "value": "dGVzdA=="
    },
    {
      "property": "#/sdfObject/thermostat/sdfProperty/humidity",
      "value": "eGVzdB=="
    }
  ]
}
~~~~~
{:json #exupmresp title="Example update multiple properties response"}

where-

 - "id" is the id of the device
 - "properties" is an array of properties that were updated, each containing a property and a value

A failure will generate a standard failed response. Please refer to {{failure}} definition of failed response.

### Read multiple values

Method: `GET /{id}/property`

Description: Read values from one or more properties on a device

Parameters: 

 - id: the id of the device

Query Parameters:

 - property: a comma separated list of properties to read

Response:

Example of a response:

~~~~~
{
  "id": "12345678-1234-5678-1234-56789abcdef4",
  "properties": [
    {
      "property": "#/sdfObject/thermostat/sdfProperty/temperature",
      "value": "dGVzdA=="
    },
    {
      "property": "#/sdfObject/thermostat/sdfProperty/humidity",
      "value": "eGVzdB=="
    }
  ]
}
~~~~~
{:json #exreadmresp title="Example read multiple properties response"}

where-

 - "id" is the id of the device
 - "properties" is an array of properties that were read, each containing a property and a value

A failure will generate a standard failed response. Please refer to {{failure}} definition of failed response.

## NIPC Event APIs

These APIs allow applications to enable or disable event reporting on devices.
These operations may require a connection to the device to be established. This connection can be established as part of the same API call implicitly. If a connection is already active for this device, the existing connection will be leveraged without modifying it.

The event is a URL encoded string that is the absolute URI that is a global name reference to an `sdfEvent`.
This event is also used as the MQTT topic name.

### Enable event reporting

Method: `POST /{id}/event/{event}`

Description: Enables an event on a specific device

Parameters: 

 - id: the id of the device
 - event: the event to enable

The event is a URL encoded string that is the absolute URI that is a global name reference to an `sdfEvent`. 

Response:

Example of a response:

~~~~~
{
  "id": "12345678-1234-5678-1234-56789abcdef4",
  "event": "https%3A%2F%2Fexample.com%2Fheartrate%23%2FsdfObject%2Fhealthsensor%2FsdfEvent%2FfallDetected"
}
~~~~~
{:json #exenableresp title="Example enable event response"}

where-

 - "id" is the id of the device
 - "event" is the event that was enabled

A failure will generate a standard failed response. Please refer to {{failure}} definition of failed response.

### Disable event reporting

Method: `DELETE /{id}/event/{event}`

Description: Disables an event on a specific device

Parameters:

  - id: the id of the device
  - event: the event to disable

The event is a URL encoded string that is the absolute URI that is a global name reference to an `sdfEvent`.

Response:

Example of a response:

~~~~~
{
  "id": "12345678-1234-5678-1234-56789abcdef4",
  "event": "https%3A%2F%2Fexample.com%2Fheartrate%23%2FsdfObject%2Fhealthsensor%2FsdfEvent%2FfallDetected"
}
~~~~~
{:json #exdisableresp title="Example disable event response"}

where-

 - "id" is the id of the device
 - "event" is the event that was disabled

A failure will generate a standard failed response. Please refer to {{failure}} definition of failed response.

### Get event status

Method: `GET /{id}/event/{event}`

Description: Get the status of an event on a specific device

Parameters:

  - id: the id of the device
  - event: the event to get the status of

The event is a URL encoded string that is the absolute URI that is a global name reference to an `sdfEvent`.

Response:

Example of a response:

~~~~~
{
  "id": "12345678-1234-5678-1234-56789abcdef4",
  "event": "https%3A%2F%2Fexample.com%2Fheartrate%23%2FsdfObject%2Fhealthsensor%2FsdfEvent%2FfallDetected"
}
~~~~~
{:json #exgeteventresp title="Example get event status response"}

where-

 - "id" is the id of the device
 - "event" is the event that was queried

A failure will generate a standard failed response. Please refer to {{failure}} definition of failed response.

### Get status of multiple events

Method: `GET /{id}/event`

Description: Get the status of one or more events on a specific device

Parameters:

  - id: the id of the device

Query Parameters:

  - event: a comma separated list of events to get the status of

Response: 

Example of a response:

~~~~~
{
  "events": [
    {
      "id": "12345678-1234-5678-1234-56789abcdef4",
      "event": "https%3A%2F%2Fexample.com%2Fheartrate%23%2FsdfObject%2Fhealthsensor%2FsdfEvent%2FfallDetected"
    }
  ]
}
~~~~~
{:json #exgetmresp title="Example get multiple events status response"}

where-

 - "id" is the id of the device
 - "events" is an array of events that were queried

A failure will generate a standard failed response. Please refer to {{failure}} definition of failed response.

## NIPC Action APIs

These APIs allow applications to perform actions on devices. These operations may require a connection to the device to be established. This connection can be established as part of the same API call implicitly. If a connection is already active for this device, the existing connection will be leveraged without modifying it.

### Perform an action

Method: `PUT /{id}/action/{action}`

Description: Perform an action on a specific device

Parameters:

  - id: the id of the device
  - action: the action to perform

Request Body:

  - value: the bytes to be written in base64 encoding

Example body of an action:

~~~~~
{
  "value": "dGVzdA=="
}
~~~~~
{:json #exaction title="Example action"}

Response:

Example of a response:

~~~~~
{
  "id": "12345678-1234-5678-1234-56789abcdef4",
  "action": "#/sdfObject/healthsensor/sdfAction/start"
}
~~~~~
{:json #exactionresp title="Example action response"}

where-

 - "id" is the id of the device
 - "action" is the action that was performed

A failure will generate a standard failed response. Please refer to {{failure}} definition of failed response.

## NIPC Action APIs with embedded protocol mapping

These APIs allow applications to perform actions on devices, but do not use registered properties, events or actions. These APIs do not perform an implicit connection, so a connection must be established before calling these APIs.

### Connect to a device

Method: `POST /{id}/action/connection`

Description: Connect to a device

Parameters:

  - id: the id of the device

Request Body:

  - Connection retry parameters
  - A protocol map object. In the case of BLE,if no protocol map is included, service discovery is 
   performed to discover all supported properties when connecting to
   a device. Optionally, service discovery may be limited to properties 
   defined in the "ble" protocol extension. The services to be 
   discovered can be added in an array. Property discover can be buffered
   across connections, so the API also supports caching parameters. 

Example body of a connection without specific discovery of properties:

~~~~~
{
  "retries": 3,
  "retryMultipleAPs": true
}
~~~~~
{:json #exconn title="Example connection"}

where-

 - "retries" defines the number of retries in case the operations does not 
   succeed
 - "retryMultipleAPs" can be used in case there is an infrastructure with 
   multiple access points or radios that can reach the device. If set to "true"
   a different access point may be used for retries.

In case the application would like to discover specific properties of a device,
a protocol mapping can be added that defines what properties should be
discovered.

Example body of a BLE connection with specific discovery of properties:

~~~~~
{
  "retries": 3,
  "retryMultipleAPs": true,
  "protocolMap": {
    "ble": {
      "services": [
        {
          "serviceID": "12345678-1234-5678-1234-56789abcdef4"
        }
      ],
      "cached": false,
      "cacheIdlePurge": 3600,
      "autoUpdate": true,
      "bonding": "default"
    }
  }
}
~~~~~
{:json #exconnprp title="Example connection with explicit discovery of connections"}

where in the BLE protocol object: 

 - "services" is an array of services defined by their serviceIDs.
 - "cached" refers to whether the services need to be cached for 
   subsequent connects, in order not to perform service discovery on
   each request.
 - "cacheIdlepurge" defines how long the cache should be maintained 
   before purging
 - some devices support notifications on changes in services, 
   "autoUpdate" allows the network to update services based on 
   notification (on by default)
 - "bonding" allows you to override the bonding method configured when 
   onboarding the device

Response:

Success responses include a protocol mapping with an array of 
discovered properties, as defined in the specific protocol.
For example, for BLE, this is an array of supported services, which in turn
contains an array of charateristics, which in turn contains an array of
descriptors, as shown in {{BLEservices}}.

~~~~~
    services
     - serviceID
        |
        |> characteristics
            - charactericID
            - flags
               |
               |> Descriptors
                   - descriptorID
~~~~~
{: #BLEservices title="BLE Services"}

Example of a response:

~~~~~
{
  "id": "12345678-1234-5678-1234-56789abcdef4",
  "protocolMap": {
    "ble": [
      {
        "serviceID": "12345678-1234-5678-1234-56789abcdef4",
        "characteristics": [
          {
            "characteristicID": "12345678-1234-5678-1234-56789abcdef4",
            "flags": [
              "read",
              "write"
            ],
            "descriptors": [
              {
                "descriptorID": "12345678-1234-5678-1234-56789abcdef4"
              }
            ]
          }
        ]
      }
    ]
  }
}
~~~~~
{:json #exconnresp title="Example connection response"}

where-

  - "id" is the id of the device
   - "protocolMap" contains an Array of BLE services as shown in
   {{BLEservices}}

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Update a connection

Method: `PUT /{id}/action/connection`

Description: Update cached ServiceMap for a device. Full service discovery will be performed, unless specific services are described in the API body.

Parameters:

  - id: the id of the device

Request Body:

  - A protocol map object. In the case of BLE,if no protocol map is included, service discovery is 
   performed to discover all supported properties when connecting to
   a device. Optionally, service discovery may be limited to properties 
   defined in the "ble" protocol extension. The services to be 
   discovered can be added in an array. Property discover can be buffered
   across connections, so the API also supports caching parameters.

Example body of an update connection:

~~~~~
{
  "protocolMap": {
    "ble": {
      "services": [
        {
          "serviceID": "12345678-1234-5678-1234-56789abcdef4"
        }
      ],
      "cached": false,
      "cacheIdlePurge": 3600,
      "autoUpdate": true
    }
  }
}
~~~~~
{:json #exupconn title="Example service discovery response"}

where in the BLE protocol object: 

 - "services" is an array of services defined by their serviceIDs.
 - "cached" refers to whether the services need to be cached for 
   subsequent connects, in order not to perform service discovery on
   each request.
 - "cacheIdlepurge" defines how long the cache should be maintained 
   before purging
 - some devices support notifications on changes in services, 
   "autoUpdate" allows the network to update services based on 
   notification (on by default)

Response:

Success responses include a protocol mapping with an array of 
discovered properties, as defined in the specific protocol.
For example, for BLE, this is an array of supported services, which in turn
contains an array of charateristics, which in turn contains an array of
descriptors, as shown in {{BLEservices}}.

Example of a response:

~~~~~
{
  "id": "12345678-1234-5678-1234-56789abcdef4",
  "protocolMap": {
    "ble": [
      {
        "serviceID": "12345678-1234-5678-1234-56789abcdef4",
        "characteristics": [
          {
            "characteristicID": "12345678-1234-5678-1234-56789abcdef4",
            "flags": [
              "read",
              "write"
            ],
            "descriptors": [
              {
                "descriptorID": "12345678-1234-5678-1234-56789abcdef4"
              }
            ]
          }
        ]
      }
    ]
  }
}
~~~~~
{:json #exupconnresp title="Example connection response"}

where-

  - "id" is the id of the device
   - "protocolMap" contains an Array of BLE services as shown in
   {{BLEservices}}

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Disconnect from a device

Method: `DELETE /{id}/action/connection`

Description: Disconnect from a device

Parameters:

  - id: the id of the device

Response:

Example of a response:

~~~~~
{
  "id": "12345678-1234-5678-1234-56789abcdef4"
}
~~~~~
{:json #exdisconnresp title="Example disconnect response"}

where-

 - "id" is the id of the device

A failure will generate a standard failed response. Please refer to {{failure}} definition of failed response.

### Get connection status

Method: `GET /{id}/action/connection`

Description: Get connection status for a device. Success when device(s) is/are connected, includes service map for the device if available. Failure when a device is not connected

Parameters:

  - id: the id of the device

Response:

Example of a response:

~~~~~
{
  "id": "12345678-1234-5678-1234-56789abcdef4",
  "protocolMap": {
    "ble": [
      {
        "serviceID": "12345678-1234-5678-1234-56789abcdef4",
        "characteristics": [
          {
            "characteristicID": "12345678-1234-5678-1234-56789abcdef4",
            "flags": [
              "read",
              "write"
            ],
            "descriptors": [
              {
                "descriptorID": "12345678-1234-5678-1234-56789abcdef4"
              }
            ]
          }
        ]
      }
    ]
  }
}
~~~~~
{:json #exconnstatresp title="Example connection status response"}

where-

  - "id" is the id of the device
   - "protocolMap" contains an Array of BLE services as shown in
   {{BLEservices}}

A failure will generate a standard failed response. Please refer to {{failure}} definition of failed response.

### Write a value using protocol mapping

Method: `POST /{id}/action/property/write`

Description: Writes a value to a property on a device using protocol mapping

Parameters:

  - id: the id of the device

Request Body:

  - value: the bytes to be written in base64 encoding
  - protocolMap: the protocol mapping for the property

Example body of a write property:

~~~~~
{
  "value": "dGVzdA==",
  "protocolMap": {
    "ble": {
      "serviceID": "12345678-1234-5678-1234-56789abcdef4",
      "characteristicID": "12345678-1234-5678-1234-56789abcdef4"
    }
  }
}
~~~~~
{:json #exwriteprop title="Example write property"}

Response:

Example of a response:

~~~~~
{
  "id": "12345678-1234-5678-1234-56789abcdef4",
  "value": "dGVzdA==",
  "protocolMap": {
    "ble": {
      "serviceID": "12345678-1234-5678-1234-56789abcdef4",
      "characteristicID": "12345678-1234-5678-1234-56789abcdef4"
    }
  }
}
~~~~~
{:json #exwritepropresp title="Example write property response"}

where-

 - "id" is the id of the device
 - "value" is the bytes that were written in base64 encoding
 - "protocolMap" is the protocol mapping for the property

A failure will generate a standard failed response. Please refer to {{failure}} definition of failed response.

### Read a value using protocol mapping

Method: `POST /{id}/action/property/read`

Description: Reads a value from a property on a device using protocol mapping

Parameters:

  - id: the id of the device

Request Body:

  - protocolMap: the protocol mapping for the property

Example body of a read property:

~~~~~
{
  "protocolMap": {
    "ble": {
      "serviceID": "12345678-1234-5678-1234-56789abcdef4",
      "characteristicID": "12345678-1234-5678-1234-56789abcdef4"
    }
  }
}
~~~~~
{:json #exreadprop title="Example read property"}

Response:

Example of a response:

~~~~~
{
  "id": "12345678-1234-5678-1234-56789abcdef4",
  "value": "dGVzdA==",
  "protocolMap": {
    "ble": {
      "serviceID": "12345678-1234-5678-1234-56789abcdef4",
      "characteristicID": "12345678-1234-5678-1234-56789abcdef4"
    }
  }
}
~~~~~
{:json #exreadpropresp title="Example read property response"}

where-

 - "id" is the id of the device
 - "value" is the bytes that were read in base64 encoding
 - "protocolMap" is the protocol mapping for the property

A failure will generate a standard failed response. Please refer to {{failure}} definition of failed response.

### Broadcast to a device

Method: `POST /{id}/action/broadcast`

Description: Broadcast a payload to a device. The broadcast is performed on the AP where the device was last seen

Parameters:

  - id: the id of the device

Request Body:

An example body of a broadcast:

~~~~~
{
  "id": "12345678-1234-5678-1234-56789abcdef4",
  "protocolMap": {
    "ble": {}
  },
  "cycle": "single",
  "broadcastTime": 3000,
  "broadcastInterval": 500,
  "payload": "AgEaAgoMFv9MABAHch9BsDkgeA=="
}
~~~~~
{:json #exbroadcast title="Example broadcast"}

where-

 - "id" is the id of the device
 - "protocolMap" is the protocol mapping for the property to identify the protocol to be used
 - "cycle" is the broadcast cycle, either "single" or "repeat"
 - "broadcastTime" is the time in milliseconds for the broadcast to run
 - "broadcastInterval" is the time in milliseconds between each broadcast
 - "payload" is the bytes to be broadcast in base64 encoding

Response:

This API responds with a HTTP 200 OK status code and an empty body when successful.

A failure will generate a standard failed response. Please refer to {{failure}} definition of failed response.

# NIPC Extensibility

NIPC is extensible in two ways:
 
 - Protocol mapping: New protocol mapping can extend NIPC with support
   for new non-IP protocols
 - API extensions: API extensions leverage compound statements of basic NIPC
   action APIs to simplify common operations for applications.
 
## Protocol extensions

As described in {{propertymap}} NIPC supports mapping protocol specific
mapping to NIPC properties. BLE and Zigbee are used as examples, but protocol
mapping is extensible to other protocols, so now non-IP protocols can be 
supported by NIPC without a schema change.

~~~~~

     -  property
        |
        |> BLE
        |     - BLE  properties
        |
        |> Zigbee
        |     - Zigbee properties
        |
        |> New protocol 
        |     -  New protocol properties

~~~~~
{: #extprotmap title="Extended protocol mapping"}

As shown in {{extprotmap}}, a protocol mapping can be added by adding
a new technology specific extension to the schema. 

This is performed by adding the new protocol to the technology enum in
the base object definition {{devicedef}}

Furthermore, the protocol objects need to be extended with the new
protocol as well. Protocol objects will be extended as follows:

| Attribute  | Req |   Type |          Example                         |
+------------+-----+--------+------------------------------------------|
| ble        |  T  | object | an object with BLE-specific properties   |
| zigbee     |  T  | object | an object with Zigbee-specific properties|
| newProtocol|  T  | object | an object with newProtocol-specific props|
{: #newprotext title="Adding Protocol mappings"}

In the new protocol object, protocol specific properties can be added.

Protocol mappings need to be IANA registered.
 
## API extensions

/extension

The extension APIs allow for extensibility of the APIs, either IANA 
registered extensions or vendor-specific extensions.
Extension APIs must leverage the basic NIPC defined APIs and combine them in 
compound statements in order to streamline application operation against
devices, make operations more expediant and convenient in one API call.
In principle they do not add any basic functionality. In
the OpenAPI model {{openAPI}} below, we have defined a few example 
extensions.  

# NIPC Error Handling
{: #errorhandling}

The error codes in the NIPC APIs can be generic or specific to the API. 
The generic error codes reuse the HTTP status codes defined in {{!RFC9110}}.
The error codes for the action APIs are divided into the following
categories:  

 - 1000-1099: Errors related to Connection APIs
 - 1100-1199: Errors related to Property APIs
 - 1200-1299: Errors related to Subscription APIs
 - 1300-1399: Errors related to Broadcast APIs

The error codes for the registration APIs are further divided into the following
categories:  

 - 1400-1499: Errors related to Event Registration APIs
 - 1500-1599: Errors related to Property Registration APIs

For errors that are not specific to any API, the error codes have a 
value of 2000 or higher.

The error codes are also categorized according to the technology:  

 - xx00 - xx09: Generic
 - xx10 - xx19: BLE
 - xx20 - xx29: Zigbee
 - xx30 - xx99: Reserved for future use

The specific error codes are defined in the table below:

| Error Code | Description                                  | Category  |
|------------|----------------------------------------------|-----------|
| 1000       | Device already connected                     | action/connection |
| 1001       | No connection found for device               | action/connection |
| 1010       | BLE connection timeout                       | action/connection/ble |
| 1011       | BLE bonding failed                           | action/connection/ble |
| 1012       | BLE connection failed                        | action/connection/ble |
| 1013       | BLE service discovery failed                 | action/connection/ble |
| 1020       | Zigbee connection timeout                    | action/connection/zigbee |
| 1100       | Property not writeable                       | action/property |
| 1101       | Property not readable                        | action/property |
| 1110       | Invalid BLE service or characteristic ID     | action/property/ble |
| 1120       | Invalid Zigbee endpoint or cluster ID        | action/property/zigbee |
| 1200       | Subscription not found                       | action/subscription |
| 1201       | Subscription already started                 | action/subscription |
| 1210       | Invalid BLE service or characteristic ID     | action/subscription/ble |
| 1220       | Invalid Zigbee endpoint or cluster ID        | action/subscription/zigbee |
| 1300       | Invalid broadcast data                       | action/broadcast |
| 1400       | Invalid event identifier                     | registration/event |
| 1500       | Invalid property identifier                  | registration/property |
| 2000       | Generic catch-all error code for any API     | generic   |
| 2001       | Invalid device ID or gateway doesn't recognize the ID | generic   |
| 2002       | Property not found                           | generic   |
{: #errorcodes title="Error Codes"}

The appropriate HTTP status code is returned in the response. 

# Publish/Subscribe Interface

The publish/subscribe interface, or data streaming interface, is an MQTT
publishing interface. Pub/sub topics can be created and managed by means
of the /registration/event NIPC element.

In this memo, we propose the data format to be CBOR {{!RFC8949}}.

## CDDL Definition

We have a CDDL {{!RFC8610}} definition where we define the
DataSubscription struct that will be used by all the messages published 
to the MQTT broker. 

The DataSubscription struct is a CBOR map that will contain the raw data
in bytes and a timestamp of the data. Optionally, the message will also
have a deviceID that corresponds to the SCIM ID of the device if the 
payload is associated to a known device.

Other fields in the CDDL such as apMacAddress and rssi can be optionally
included but these fields can expose the underlying network topology.

Each message also has a subscription choice group that will define the
type of data that is being published.

~~~~ CDDL
{::include data_subscription.cddl}
~~~~
{:cddl}

## CBOR Examples

This section contains a few examples of the DataSubscription struct 
depicted in CBOR diagnostic notation.

~~~
{
    "data": h'02011A020A0C16FF4C001007721F41B0392078',
    "deviceID": "75fde96d-886f-4ac0-a1d5-df79f76e7c9c",
    "timestamp": 1727484393,
    "bleAdvertisement": {
        "macAddress": "C1:5C:00:00:00:01",
        "rssi": -25
    }
}
~~~
{: title="Onboarded BLE Device Advertisement" }

~~~
{
    "data": h'02011A020A0C16FF4C001007721F41B0392078',
    "timestamp": 1727484393,
    "bleAdvertisement": {
        "macAddress": "C1:5C:00:00:00:01",
        "rssi": -25
    }
}
~~~
{: title="Non-onboarded BLE Device Advertisement" }

~~~
{
    "data": h'434630374346303739453036',
    "deviceID": "75fde96d-886f-4ac0-a1d5-df79f76e7c9c",
    "timestamp": 1727484393,
    "bleSubscription": {
        "serviceID": "a4e649f4-4be5-11e5-885d-feff819cdc9f",
        "characteristicID": "c4c1f6e2-4be5-11e5-885d-feff819cdc9f"
    }
}
~~~
{: title="BLE GATT Notification" }

~~~
{
    "deviceID": "75fde96d-886f-4ac0-a1d5-df79f76e7c9c",
    "timestamp": 1727484393,
    "bleConnectionStatus": {
        "macAddress": "C1:5C:00:00:00:01",
        "connected": true
    }
}
~~~
{: title="BLE Connection status event" }

~~~
{
    "data": h'434630374346303739453036',
    "deviceID": "75fde96d-886f-4ac0-a1d5-df79f76e7c9c",
    "timestamp": 1727484393,
    "zigbeeSubscription": {
        "endpointID": 1,
        "clusterID": 6,
        "attributeID": 12,
        "type": 1
    }
}
~~~
{: title="Zigbee Attribute Notification" }

# Examples

This section contains a few examples on how applications can leverage 
NIPC operations to communicate with BLE and Zigbee devices.

## BLE Advertisement

In this example, we will onboard a device, and setup an advertisement
subscription event for that device.

The sequence of operations for this are:  

 - Onboard a device using the SCIM Interface (out of scope of this
   memo)
 - Register an event with the device id to subscribe to advertisements
   POST /register/event 
 - Subscribe to the topic from the data receiver app 
   MQTT subscribe topic

## BLE Property Read/Write

In this example, we will connect to a BLE device and read and write from a
property.

The sequence of operations for this are:  

 - Onboard a device using the SCIM Interface (out of scope of this
   memo)
 - Connect to the BLE device
   POST /action/connection 
 - Read a property from the BLE device
   GET  /action/property
 - Write to a property on the BLE device
   POST /action/property 
 - Disconnect from the BLE device
   DELETE /action/connection 

## Zigbee Property Read/Write

In this example, we will connect a zigbee device to a Zigbee mesh
and read and write from a property

The sequence of operations for this are:  

 - Onboard a device using the SCIM Interface (out of scope of this
   memo)
 - Connect the Zigbee device
   POST /action/connection 
 - Read a property from the Zigbee device
   GET  /action/property  
 - Write to a property on the Zigbee device
   POST  /action/property  
 - Disconnect from the Zigbee device
   DELETE /action/connection 

# Security Considerations

## API authorization 

In order to enable a network wishing to offer NIPC ALG functions, the network
administrator authorizes application(s) to perform operations on the Gateway.
This happens out of band and may be accomplished by means of exchanging tokens
or public keys.
Authorization can be role-based. The 3 primary roles are:  

1. Onboarding: Authorize an onboarding application against a SCIM server
   co-located with the gateway.  
2. Control: Authorize applications that may control devices.
3. Data: Authorize applications that may receive telemetry.  
It is possible to further refine roles down to an API basis.

# IANA Considerations

This section provides guidance to the Internet Assigned Numbers Authority
(IANA) regarding registration of values related to NIPC, in accordance
with {{!RFC8126}}.

## Protocol mapping

## API extensions

## well_known URI

--- back

# OpenAPI definition

The following non-normative model is provide for convenience of
the implementor.

~~~~~~
<CODE BEGINS>
file "openapi.yml"
{::include nipc-openapi/NIPC.yaml}
<CODE ENDS>
~~~~~~
{: #openAPI}
