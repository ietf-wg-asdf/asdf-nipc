---
title: An Application Layer Interface for Non-IP device control (NIPC)
abbrev: NIPC
docname: draft-ietf-asdf-nipc-12
submissionType: IETF
category: std

ipr: trust200902
keyword: Internet-Draft

stand_alone: no
pi: [toc, sortrefs, symrefs]

author:
 - 
    ins: B. Brinckman
    name: Bart Brinckman
    org: Cisco Systems
    city: Brussels
    country: Belgium
    email: bbrinckm@cisco.com
 -
    ins: R. Mohan
    name: Rohit Mohan
    org: Cisco Systems
    street: 170 West Tasman Drive
    code: 95134
    city: San Jose
    country: USA
    email: rohitmo@cisco.com
 -
    ins: B. Sanford
    name: Braeden Sanford
    org: Philips
    city: Cambridge
    country: USA
    email: braeden.sanford@philips.com

informative:
  BLE53:
    title: Bluetooth Core Specification, Version 5.3
    author:
      -
        org: Bluetooth SIG
    date: 2021
  Zigbee22:
    title: zigbee Specification, Version 22 1.0
    author:
      -
        org: Connectivity Standards Alliance
    date: 2017
  Gatt-REST-API:
    title: A RESTful API used to access data in devices using the functionality defined in the Bluetooth GATT profile
    target: https://www.bluetooth.com/bluetooth-resources/gatt-rest-api/
    author:
      -
        org: Bluetooth SIG
    date: 2017
...

--- abstract

This memo describes an API that allows applications to perform operations against a gateway serving one or more devices described by an SDF model. The document describes RESTful application layer interface to perform operations on those devices, as well as a CBOR-based publish-subscribe interface for streaming data. 

--- middle

# Introduction

## Scope

Low-power sensors, actuators and other connected devices introduced in
environments and use cases such as building management, healthcare, workplaces,
manufacturing, logistics and hospitality are often battery-powered. With 
limited power budget, they may not be able to support the IP protocol on their
wired or wireless interfaces, hence they support protocols that require a lower
power budget. Promiment examples of such protocols are {{BLE53}} and
{{Zigbee22}}. These devices typically do require to communicate with devices
or applications that are connected to IP-based networking infrastructure. 
Therefore, applications on the IP network that need to communicate or receive
telemetry from these non-IP low-power devices must do so through a gateway 
function on the IP network. This gateway functions then translates the 
communication to the non-IP protocol that the low-power device supports. 

~~~~~ aasvg
                                                               
    +-------------+              +---------+              +--------+
    | Application |<------------>| Gateway |<------------>| Non-IP |                     
    |             |   IP-based   |         |    Non-IP    | Device |
    +-------------+   Operation  +---------+   Operation  +--------+                 

~~~~~
{: #gw title="Gateway for non-IP Devices"}

There have been efforts to define Gateway functions for devices that support
a particular protocol, such as a BLE GATT REST API for BLE Gateways
({{Gatt-REST-API}}), however they have been limited to a single protocol or
a particular use case. In absence of an open standard describing how
applications on an IP network communicate with non-IP devices, bespoke and
vendor-specific implementations have proliferated. This results in parallel
infrastructure of both gateways and non-IP networks being deployed on a case
by case basis, each connecting separately into the IP network, with a distinct
set of APIs. At the same time, wireless access points supporting both IP-based 
wireless connectivity as well as non-IP based wireless technologies are
deployed ubiquitiously. Many of these wireless access points are equipped with
radios that can transmit and receive different frame types, such as {{BLE53}}
and {{Zigbee22}}. This specification aims to define a Gateway API for these 
Non-IP protocols that can be leveraged by this wireless infrastructure in order
to connect Non-IP devices into IP networks. The specification aims to be
extensible, in order to support existing and future non-IP protocols.

A standardized Non-IP Gateway interface has following benefits:

 - Avoid the need for parallel Non-IP infrastructure.
 - Avoid the need for applications to perform bespoke integrations for
   different environments.
 - Faster and more cost-effective adoption of Non-IP devices in IP network
   environments.

## Non-IP Gateway

A non-IP gateway MUST provide at least following functions:

 - Authentication and authorization of application clients that
   will leverage the gateway API to communicate with Non-IP devices.
 - Access to a database of onboarded devices. Onboarding ensures that 
   the Non-IP Gateway can identify a specific device and has sufficient context
   about the device to service gateway API requests.
 - The ability to consume an interaction model for a class of devices. This 
   allows the gateway to understand how to interact with a device.
 - An API that allows for bi-directional communication to non-IP devices.
 - One or more channels to process requests, responses, and asymmetric
   communications with the non-IP radio resources (Access Points)
   at its disposal.
 - The ability to stream telemetry received from non-IP devices in real-time
   to applications on the IP network.

The definition of the onboarding function is out of scope of this document, but
can be provided by a provisioning interface such as {{!RFC7644}} leveraging 
{{!I-D.ietf-scim-device-model}}. NIPC performs operations on a device or group
object, hence it requires device onboarding to be performed prior to performing
a NIPC operation on a device. NIPC APIs will reference a device or group id 
generated at the time of onboarding as a unique identifier. 

The Application gateway is a network function, so its goal is to proxy payloads 
between Non-IP and IP networks. It is not intended to be a middleware function
that interprets, decodes or modifies these payloads.

~~~~~ aasvg

                         +------------------------------------------+
                         |                                          |
+-----------+   Request  |  +---------+                             |
| onboarding+-------------->|  SCIM   |                             |
|    app    |<--------------+ Server  |                             |
+-----------+  Ctrl Endpt|  +---------+                             |
                         |                                          |
+-----------+            |  +------------+   +-------+   +--------+ |
|  Control  +----REST------>|    NIPC    +-->|  AP   +-->| Device | |
|     &     |            |  |   Gateway  |   +-------+   +--------+ |
| Telemetry |<--pub/sub-----+            |                          |
|    Apps   |            |  +------------+                          |
+-----------+            |                                          |
                         |            Network Deployment            |
                         +------------------------------------------+

~~~~~
{: #arch title="Basic Architecture"}

{{arch}} shows us applications, the NIPC application layer gateway (ALG),
an access point (AP), and a device (D). The applications, application layer
gateway and access point are deployed on an IP-Network. The AP supports a
Non-IP interface, which it uses to communicate with the device.
The Application is deployed in a different administrative domain than the
network elements (ALG & AP).
The role of the application layer gateway is to provide a gateway function
to applications wishing to communicate with non-IP devices in the network
domain served by the gateway.
Applications implementing Non-IP Control can leverage RESTful interfaces
to communicate with Non-IP devices in the network domain and subscribe to
events leveraging a CBOR-based pub/sub interface.

## Terminology

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in BCP
14 {{!RFC2119}} {{!RFC8174}} when, and only when, they appear in all
capitals, as shown here.

# Architecture

## Overview

Non-IP protocols, such as BLE or Zigbee, typically define a number of basic
operations that are similar across protocols. Examples of this are read and 
write data. NIPC provides a unified API to support those operations.

To perform NIPC operations on a device, the gateways needs 2 things:
1) Information about the instance of the device or thing: The device must be
onboarded on the gateway (e.g. by means of SCIM). This allows the NIPC Gateway
to retrieve the device object, identified by an id referenced in the path of 
the NIPC API.
2) Information about the interaction model: The Gateway must be able to perform
protocol-neutral operations, and hence requires a mapping of protocol-neutral
operations to protocol specific operations. These are supplied to the gateway
by means of an SDF model, described in {{!I-D.ietf-asdf-sdf}}.

~~~~~ aasvg

    +------------+   
    |    SCIM    |                      
    |   object   |           +----------------+          
    |    {id}    +---------->|                |
    +------------+           | NIPC Operation |
                             |    - Property  |
                             |    - Action    |
    +------------+           |    - Event     |
    |     SDF    +---------->|                |
    |    model   |           +----------------+
    +------------+  

~~~~~
{: #prereq title="NIPC prerequisites"}

Once these 2 prerequisites have been fulfilled, applications that are
authorized can perform NIPC operations on device ids. NIPC operations
are operations on properties, or constitute actions or events on devices,
as per the affordances defined in an SDF model.

## Onboarding

In order to perform a NIPC operation on a device, the device has to have its 
identity declared to the NIPC gateway. We refer to this as 'onboarding'. Apart
from the device identity, it is also necessary that the device object contains
all required information to bootstrap trust with the device, as well as
establish connectivity, as NIPC operations assume that connectivity is there. 
Allthough onboarding could theoretically be performed in other ways, it is
strongly recommended to leverage {{!RFC7644}} with
{{!I-D.ietf-scim-device-model}}, as the SCIM device schema has been developed
to contain all nessary attributes and extensions to support NIPC.

## Registrations 

NIPC registrations APIs allow applications to declare information that is not
related to a device instance. Registrations can be information about an
interaction model for a class of devices, or information about an application
that is required to interact with the gateway.

### SDF model registrations

The SDF model for a class of devices determines how a gateway may interact with
these devices in a protocol-neutral way. In order to do that, the SDF model
must contain protocol mappings, mapping protocol-neutral SDF affordances
to protocol-specific ones as defined in {{!I-D.mohan-asdf-sdf-protocol-mapping}}. 
The SDF affordances supported by the device, as well as its protocol-mappings,
are provide to the gateway by means of an SDF model registration. 
SDF models are described in {{!I-D.ietf-asdf-sdf}}.

### Data application registrations

An application authorized to perform NIPC operations on devices needs to be
able to define which applications can receive streaming event data from the
gateway. The data-app registrations API allows mapping of an event to a data 
app as well as a protocol.

## NIPC Operations {#nipc-ops}

NIPC operations are protocol-neutral operations on SDF affordances, more 
specifically properties, actions & events. NIPC operations can happen against
affordances that were registered in an SDF model. If connection management is
required to execute a NIPC operation, it is assumed that the gateway implictly
establishes and tears down required connections. 

### Properties APIs

Property APIs allow applications perform operations on properties, such as to
read or write values to them.

### Actions

Action APIs perform actions on devices, such as enabling or disabling a feature
on a device.

### Events

Event APIs allow apps to enable or disable event reporting on devices. Events
are reported over the events publish/subscribe interface.

### Connection management for NIPC Operations

For protocols that require connection management before executing an operation,
a NIPC gateway will perform implicit connection management. When executing a 
NIP operation, a NIPC Gateway can set up a connection with a device as well as
tear down the connection after the operation has completed. A NIPC Gateway
may support explicit connection management as well. Explicit connection
management can be used by an app that wants to perform multiple NIPC operations
in a single connection. Explicit connection management can be performed by 
calling the /devices/{id}/connections API. After establishing an
explicit connection to a device, an application calls a NIPC Operation, the
Gateway will leverage the existing connection and will also not tear the
connection down after the operation completes. The app will have to explicitly
close the connection. 

### Extensions {#extensions}

NIPC is extendable as a NIPC gateway may want to provide a way to execute a
complex set of NIPC operations in a single API call, or may want to perform
an operation that can deliver an outcome more efficiently than a NIPC API. 
An example of an extension that uses compound operation is the bulk API.

Extensions must leverage the /extensions path element. In order to assure
inter-operability, extensions must be IANA registered {{iana-api-ext}}.

## Events publish subscribe interface

Events are published on a publish/subscribe interface. Events can be of
different types:

- Streaming data from devices: Streaming data is activated/deactivated with the
  NIPC events API
- Broadcasts from devices
- Connection events: Devices connecting & disconnecting

## Protocols

### NIPC APIs

NIPC is a protocol that is based on RESTful HTTP {{!RFC9114}}. Along with HTTP
headers and URIs, NIPC uses JSON {{!RFC7159}} payloads to convey NIPC 
operations, such as registrations, actions, event and property operations. This
is the case for both request and response parameters, as well as errors.
NIPC uses the JSON media type "application/nipc+json" that is registered in
{{iana-media-types}}, except for the SDF model registrations APIs, 
where the media type reflects the content as an SDF 
model, and hence is media type "application/sdf+json".
The NIPC property APIs also support the use of other media types to 
describe the content of the property.

### NIPC publish/subscribe events

NIPC publish/subscribe events are encoded in CBOR ({{!RFC8949}}) and can be
delivered over either:

- MQTT
- Webhook
- Websocket

## Paths

### General {#paths-general}

The NIPC HTTP protocol is described in terms of a path relative to a Base URI.
The Base URI MUST NOT contain a query string, as clients MAY append additional 
path information and query parameters as part of forming the request.  The base
URI is a URL that most often consists of the "https" protocol scheme, a domain
name, and an initial path {{!RFC3986}}.  That initial path for NIPC is 
recommended to be /nipc.
For example:

      "https://example.com/nipc/"

Additionally a version number may be added, for example: 

      "https://example.com/nipc/v1/"

After the base or version number, the path must contain a collection identifier.
The collection identifier can be one of the following:

- /registrations: for NIPC registration APIs
- /devices: for NIPC operations on devices
- /groups: for NIPC operations on groups of devices
- /extensions: for NIPC extension APIs

The well-known URI `/.well-known/nipc` defined in {{iana-well-known}} can
be used to discover the base path of the NIPC APIs and the supported versions
and extensions. The response to a GET request on this URI MUST be a JSON
document that contains the base path, and optionally the supported versions and  
extension APIs. The paths MUST be a URI template as defined in {{!RFC6570}}.
The following is an example of a template defining the NIPC base path as well
as supported extensions on a server.

~~~~~ json
{
  "base_path": "/nipc",
  "versions": [
    "/v1"
  ],
  "extensions": [
    "/extensions/{id}/bulk",
    "/extensions/{id}/properties/blob",
    "/extensions/{id}/properties/file",
    "/extensions/{id}/properties/read/conditional",
    "/extensions/{id}/events/conditional",
    "/extensions/{id}/properties/write"
  ]
}
~~~~~
{: #ex-wellknown title="Example response for /.well-known/nipc"}

### NIPC Registrations

Registrations leverage the base path + /registrations. NIPC supports SDF model
registrations and data-app registrations.

paths:

- /registrations/models
- /registrations/data-apps

### NIPC Operations

Every NIPC Operations API pertains to either a device or group of devices, identified by
an id, hence the id will be reflected as the first parameter in the path. 
For example:

      "https://example.com/nipc/v1/{id}"

The second parameter in the path refers to the NIPC operation that the API will
perform on the device. This can be:

 - properties
 - events
 - actions
 - extensions

These are described in {{nipc-ops}}.

## Schema

The NIPC schema leans heavily on the SDF schema, as defined in
{{!I-D.ietf-asdf-sdf}}. NIPC operations map directly to SDF affordances.

### SDF model registrations

In order to perform a NIPC operation on a device, an SDF interaction model 
needs to be declared that provides protocol mappings for the SDF affordances
the operations will be performed on.

The SDF model can be registered by means of a registrations API POST with 
the SDF model in the body of the request. A registered SDF model can be 
fetched by a registrations API GET with an sdfReference.

### NIPC Operations

NIPC operations require 2 key parameters:
1) A device ID identifying the device the operation should be executed on
2) an SDF reference for the SDF affordance the operations pertains to

#### Device ID

All NIPC operations are executed against a device or a group of devices.
Devices or groups of devices are identified by a unique uuid.

| Attribute     | Req |   Type  |          Example                     |
+---------------+-----+---------+--------------------------------------|
| id            |  T  |  uuid   | 12345678-1234-5678-1234-56789abcdef4 |
{: #devicedef title="Definition of a device our group of devices"}

Id is the unique uuid of the device. This id is generated when registering
the device, for example against a SCIM server. As such, this id is a common
identifier, known both to the application as well as the NIPC Server.

### SDF Name

NIPC operations happen against SDF affordances and are referenced with an
global sdfName, which is the full path including the namespace.

The operations are either Properties, Events or Actions and their references
are of type string

For example:

| Attribute | Req |   Type  |          Example                      |
+-----------+-----+---------+---------------------------------------|
| Property  |  T  |  string | https://example.com/heartrate#/<br/>sdfObject/thermostat/sdfProperty/temperature |
{: #nipcopsdef title="Definition of a NIPC operation on a property"}

### Responses 

A NIPC Gateway will respond to a NIPC operation request synchronously, and
provide the result of the completed operation in the HTTP response. 

The exception to the above are NIPC extensions, {{apiextensions}}. These contain 
compound statements, and thus require the gateway to execute multiple
NIPC operations. In this case the NIPC gateway will return HTTP status
code 202 after receiving the request and verifying it is able to execute it.
The client can then perform an HTTP GET of the extensions API to get the
execution status for the request. If a callback URL address was defined in
the request, the NIPC Gateway can optionally perform a callback with a
response to the compound request after the compound statement completes.

Actions also follow an asynchronous pattern, returning HTTP status code 202
when the action is accepted, along with a Location header pointing to the
action instance for status tracking.

A failure response will consist of a HTTP status code of 4xx or 5xx, and 
will follow the {{!RFC9457}} Problem Details format with `application/problem+json`
media type. The response will contain a `type` field with a URI identifying
the error type, and a human-readable `detail` field. The `type` field
is a URI and is described in {{errorhandling}}.

Failure response: 

Example of a failure response:

~~~~~
=============== NOTE: '\\' line wrapping per RFC 8792 ===============

{
  "type": "https://www.iana.org/assignments/nipc-problem-types#inval\
\id-id",
  "status": 400,
  "title": "Invalid Device ID",
  "detail": "Device ID 12345678-1234-5678-1234-56789abcdef4 does not\
\ exist or is not a device"
}
~~~~~
{: #failure title="Example failure response"}

where-

  - "type" is a URI identifying the specific error type
  - "status" is the HTTP status code
  - "title" is a brief, human-readable summary of the error type
  - "detail" is a human-readable explanation specific to this occurrence

# NIPC Registrations

NIPC allows an application to register an SDF model for a class of devices,
as well as a data application that will receive streaming data from the 
gateway.

## SDF model registrations APIs

These APIs allow applications to register an SDF model for a class of devices.
These APIs use the `application/sdf+json` media type, as described in 
{{Section 7.1 of I-D.ietf-asdf-sdf}}.

### Register an SDF model

Method: `POST /registrations/models`

Description: Registers one or more SDF models for a class of devices

Request Body:

 - an SDF document in JSON format containing one of more sdfThings or sdfObjects, similar to the example in {{thermometer-sdf}}.

Response:

Example of a response:

~~~~~
[
 {
  "sdfName": "https://example.com/heartrate#/sdfObject/healthsensor"
 }
]
~~~~~
{:json #exregresp title="Example of a response to an SDF model registration"}

where-

 - "sdfName" is the name of the top-level sdfThing or sdfObject 
    in the SDF model

### Get all SDF models

Method: `GET /registrations/models`

Description: Gets all SDF models registered with the gateway

Response:

Example of a response:

~~~~~
[
 {
  "sdfName": "https://example.com/heartrate#/sdfObject/healthsensor"
 },
 {
  "sdfName": "https://example.com/thermometer#/sdfObject/thermometer"
 }
]
~~~~~
{:json #exgetallresp title="Example get all SDF models response"}

where-

 - "sdfName" is the name of the top-level sdfThing or sdfObject 
    in the SDF model

### Get an SDF model

Method: `GET /registrations/models{?sdfName}`

Description: Gets an SDF model registered with the gateway

Query Parameters: 

 - sdfName: the name of the top-level sdfThing or sdfObject 
    in the SDF model.

Response:

The SDF model is returned in JSON format, similar to the example in 
{{thermometer-sdf}}.

### Delete an SDF model

Method: `DELETE /registrations/models{?sdfName}`

Description: Deletes an SDF model registered with the gateway

Query Parameters: 

 - sdfName: the name of the top-level sdfThing or sdfObject 
    in the SDF model.

Response:

Example of a response:

~~~~~
{
  "sdfName": "https://example.com/heartrate#/sdfObject/healthsensor"
}
~~~~~
{:json #exdelresp title="Example delete SDF model response"}

where-

 - "sdfName" is the name of the top-level sdfThing or sdfObject 
    in the SDF model

### Update an SDF model

Method: `PUT /registrations/models{?sdfName}`

Description: Updates an SDF model registered with the gateway

Query Parameters: 

 - sdfName: the name of the top-level sdfThing or sdfObject 
    in the SDF model.

Request Body:

 - an SDF model in JSON format, similar to the example in {{thermometer-sdf}}.

Response:

Example of a response:

~~~~~
{
  "sdfName": "https://example.com/heartrate#/sdfObject/healthsensor"
}
~~~~~
{:json #exupresp title="Example update SDF model response"}

where-

 - "sdfName" is the name of the top-level sdfThing or sdfObject 
    in the SDF model

## Data application registrations APIs

These APIs allow applications to register a data application that will receive
streaming data from the gateway. These APIs operate on a data app ID.
This ID corresponds to the endpoint app ID of the telemetry endpoint app 
that is registered with the SCIM server. The endpoint app is defined in 
{{Section 6 of I-D.ietf-scim-device-model}}. 

Apart from the endpoint, the API also registers the protocol the data-app supports. These can be one of the following:
- mqttClient: The data-app is an MQTT client, which means that the gateway is an MQTT broker.
- mqttBroker: The data-app is an MQTT broker. The registration API has to include the MQTT broker configuration data, such as the URI, credentials and MQTT topic to publish to.
- webhook: The data-app supports a webhook the gateway can pusbish to. The registration API has to include the webhook URI & credentials.
- websocket: The data-app supports a websocket interface. The registration API has to include the websocket URI & credentials.

### Register a data application

Method: `POST /registrations/data-apps{?dataAppId}`

Description: Registers a data application with the gateway

Query Parameters: 

 - dataAppId: the id of the data application

Request Body:

 - events: a list of events that the data application wants to receive
   streaming data for.

The request body also contains one of the following: 

 - mqttClient: a boolean that denotes that the data application
   is an MQTT client that will receive streaming data over MQTT
 - mqttBroker: an object that contains the MQTT broker information
   where the broker will publish the streaming data. 
    - URI: the URI of the MQTT broker
    - username: the username to authenticate with the MQTT broker
    - password: the password to authenticate with the MQTT broker
    - brokerCACert: the base64-encoded CA certificate of the MQTT broker (optional)
    - customTopic: By default, the topic will be composed of <dataAppId>/<eventName>. You can configure a custom topic to publish the streaming data to (optional)
 - webhook: an object that contains a webhook URL along with any 
    credentials that are required to authenticate the webhook. 
    The webhook URL is the endpoint where the streaming data will be sent.
    - URI: the webhook URL
    - headers: An object that contains the headers to be sent with the webhook
      request. The headers can contain any authentication information
      required by the webhook server.
    - serverCACert: the base64-encoded CA certificate of the webhook server (optional)
 - websocket: an object that contains a websocket URL along with any 
   credentials that are required to authenticate the websocket. 
   The websocket URL is the endpoint where the streaming data will be sent.
    - URI: the websocket URL
    - headers: An object that contains the headers to be sent with the websocket
      request. The headers can contain any authentication information
      required by the websocket server.
    - serverCACert: the base64-encoded CA certificate of the websocket server (optional)

Example of a request body:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

{
  "events": [
    {
      "event": "https://example.com/heartrate#/sdfObject/healthsenso\
r/sdfEvent/fallDetected"
    }
  ],
  "mqttClient": true
}
~~~~~
{:json #exregmqttclientrsp title="Example with mqttClient"}

Example of a request body for a data application that is an MQTT broker:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

{
  "events": [
    {
      "event": "https://example.com/heartrate#/sdfObject/healthsenso\
r/sdfEvent/fallDetected"
    }
  ],
  "mqttBroker": {
    "URI": "mqtt.example.com:1883",
    "username": "user",
    "password": "password",
    "customTopic": "custom/topic"
  }
}
~~~~~
{:json #exregmqttbrokerrsp title="Example with mqttBroker"}

Response:

If successful, the response will be identical to the request body. 

### Update a data application

Method: `PUT /registrations/data-apps{?dataAppId}`

Description: Updates a data application with the gateway

Query Parameters: 

 - dataAppId: the id of the data application

Request Body: Same as the request body for the register data application API.

Response: 

If successful, the response will be identical to the request body.

### Get a data application

Method: `GET /registrations/data-apps{?dataAppId}`

Description: Gets a data application registered with the gateway

Query Parameters: 

 - dataAppId: the id of the data application

Response:

The response will be identical to the request body for the register data
application API.

### Delete a data application

Method: `DELETE /registrations/data-apps{?dataAppId}`

Description: Deletes a data application registered with the gateway

Query Parameters: 

 - dataAppId: the id of the data application

Response:

The response will be identical to the request body for the register data
application API.

# NIPC APIs

The primary goal of the NIPC APIs is to  perform operations on SDF Affordances, such as properties, events & actions.This allows a user of the NIPC API to get or update properties of devices, perform actions on devices, and consume events from devices.

The NIPC APIs consists of 3 main collections which reflect SDF Affordances as defined in {{Section 1.2 of I-D.ietf-asdf-sdf}}: 

 - NIPC Property APIs: These APIs allow applications to get and update device 
   properties.
 - NIPC Event APIs: These APIs allow applications to enable or disable event
   reporting on devices.
 - NIPC Action APIs: These APIs allow applications to perform actions on
   devices.

One or more SDF models must be registered in order to use these NIPC
Property, Event and Action APIs. The SDF models can be a top-level sdfThing with
multiple sdfObjects or a top-level sdfObject. These APIs depend on the SDF 
affordances (i.e. sdfProperty, sdfEvent and sdfAction) defined in
the SDF model and a device ID that is defined in {{I-D.ietf-scim-device-model}}.
An SDF affordance can be referenced using the global name of the SDF affordance
as described in {{Section 4 of I-D.ietf-asdf-sdf}}.

The SDF global name will be used against the registered SDF model to 
determine the protocol-specific protocolmap that the NIPC API will operate on. 
The SDF global name is also percent-encoded as per {{Section 2.1 of !RFC3986}}.

## NIPC Property APIs

These APIs allow applications to get and update device properties. 
These operations may require a connection to the device to be established. 
This connection can be established as part of the same API call implicitly.
If a connection is already active for this device, the existing connection willi
be leveraged without modifying it.

These APIs support multiple media types based on Content-Type and Accept
headers to accommodate different data formats. 

When using `application/nipc+json`, the request and response bodies follow 
the format shown in the examples above, with binary data encoded as 
base64 in the "value" field. 
For other content types, the data is transmitted according to the 
specific format requirements of that media type.

### Write multiple values

Method: `PUT /devices/{id}/properties{?propertyName}`

Description: Write values to one or more properties on a device

Parameters: 

 - id: the id of the device

Query Parameters:

  - propertyName: a single property to update. If this parameter is
    provided, the request body can contain any conten type payload 
    with the value to write to the property. If this parameter is not
    provided, the request body MUST contain an application/nipc+json payload
    with an array of properties to update, each containing a property and a
    value.

Request Body:

  - If the query parameter propertyName is provided, the request body
    can contain any content type payload with the value to write to the property.
    The value is encoded as per the content type of the payload.
    
  or 

  - an array of properties to update, each containing a property and a value.
    The value is the raw binary data, encoded in base64 with padding as per 
    {{Section 5 of !RFC4648}}.

Example body updating multiple properties:

~~~~~ json
=============== NOTE: '\' line wrapping per RFC 8792 ================

[
  {
    "property": "https://example.com/heartrate#/sdfObject/thermostat\
/sdfProperty/temperature",
    "value": "dGVzdA=="
  },
  {
    "property": "https://example.com/heartrate#/sdfObject/thermostat\
/sdfProperty/humidity",
    "value": "eGVzdB=="
  }
]
~~~~~
{:json #exupmprop title="Example updating multiple properties"}

Response: 

If the Accept header is set to `application/nipc+json`, the response will be
an array with a status field set to 200 for each property that was updated, 
or a problem type object for each property that failed to update.

If the Accept header is set to any other media type and the propertyName query parameter is provided, the response will be 204 No Content with no body.

Example of a response:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

[
  {
    "status": 200
  },
  {
    "type": "https://www.iana.org/assignments/nipc-problem-types#inv\
alid-property",
    "status": 400,
    "title": "Invalid Property",
    "detail": "Property https://example.com/heartrate#/sdfObject/the\
rmostat/sdfProperty/temperature does not exist or is not writable"
  }
]
~~~~~
{:json #exupmresp title="Example update multiple properties response"}

where-

 - "properties" is an array of properties that were updated, each containing
   a property and a value

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Read multiple values

Method: `GET /devices/{id}/properties{?propertyName*}`

Description: Read values from one or more properties on a device

Parameters: 

 - id: the id of the device

Query Parameters:

 - propertyName: The property to read. This can be a single property or multiple
   properties. If multiple properties are provided, the request body MUST
   contain an application/nipc+json payload with an array of properties to read.

Response:

If the Accept header is set to `application/nipc+json`, the response will be
an array of properties, each containing a property and a value. The value is
the raw binary data read from the property, encoded in base64 with padding as per {{Section 5 of !RFC4648}}.


Example of a response:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

[
  {
    "property": "https://example.com/heartrate#/sdfObject/thermostat\
/sdfProperty/temperature",
    "value": "dGVzdA=="
  },
  {
    "property": "https://example.com/heartrate#/sdfObject/thermostat\
/sdfProperty/humidity",
    "value": "eGVzdB=="
  }
]
~~~~~
{:json #exreadmresp title="Example read multiple properties response"}

where-

 - "property" is the property that was read from
 - "value" is the bytes that were read in base64 encoding

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

## NIPC Event APIs

These APIs allow applications to enable or disable event reporting on devices.
These operations may require a connection to the device to be established. This
connection can be established as part of the same API call implicitly. If a
connection is already active for this device, the existing connection will be
leveraged without modifying it.

The event is the global name of an `sdfEvent`. 

The ID in the path is the id of the device or group of devices.
An event can be enabled on a group of devices if it is supported by the
underlying protocol. For example, if the underlying protocol is BLE, 
the event can be enabled on a group of devices if the event is an 
advertisement event or connection status event.

If the data application registered for this event is an MQTT broker or 
client, the event is used to construct the MQTT topic for the event.
The topic is constructed using the data application ID, the default 
namespace for the event, and the event itself. For example, if the data 
application ID is `"12345678-1234-5678-1234-56789abcdef4"` 
and the event is 
`"https://example.com/thermometer#/sdfThing/thermometer/sdfEvent/isPresent"`,
the topic will be:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

data-app/<dataAppId>/<namespace>/<json_pointer_to_sdf_event>

data-app/12345678-1234-5678-1234-56789abcdef4/thermometer/sdfThing/\
thermometer/sdfEvent/isPresent
~~~~~

A data application can subscribe to this topic using the topic or it 
can use MQTT wildcards to subscribe to `data-app/+/temperature/#` to 
receive all events for the `temperature` namespace.

If a custom topic is provided for an MQTT broker, the custom topic is
used as the MQTT topic instead.

### Enable event reporting

Method: `POST /devices/{id}/events{?eventName}`

Description: Enables an event on a specific device

Parameters: 

 - id: the id of the device

Query Parameters:

 - eventName: the event to enable

The eventName is a URL encoded string that is the absolute URI that is the global
name of an `sdfEvent`. 

Response:

Returns HTTP status code 201 Created with a Location header pointing to the created event instance.

Example of a successful response:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

HTTP/1.1 201 Created
Location: /devices/12345678-1234-5678-1234-56789abcdef4/events?insta\
nceId=87654321-4321-8765-4321-fedcba9876543
~~~~~

The Location header contains the URI for the created event instance, which can be used to check status or disable the event.

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Disable event reporting

Method: `DELETE /devices/{id}/events{?instanceId}`

Description: Disables an event on a specific device

Parameters:

  - id: the id of the device or group of devices

Query Parameters:

  - instanceId: the instance ID of the event to disable (obtained from the Location header when the event was enabled)

Response:

Returns HTTP status code 204 No Content on successful disable.

~~~~~
HTTP/1.1 204 No Content
~~~~~

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Get status of one or more events

Method: `GET /devices/{id}/events{?instanceId*}`

Description: Get the status of one or more events on a specific device

Parameters:

 - id: the id of the device or group of devices

Query Parameters:

  - instanceId: a comma separated list of event instance IDs to filter by (optional)

Response: 

Example of a response:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

[
  {
    "instanceId": "87654321-4321-8765-4321-fedcba9876543",
    "event": "https://example.com/heartrate#/sdfObject/healthsensor/\
sdfEvent/fallDetected"
  }
]
~~~~~
{:json #exgetmresp title="Example get multiple events status response"}

where-

 - "instanceId" is the unique instance ID for each enabled event
 - "event" is the event URI for each enabled event

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Enable event reporting on a group of devices

Method: `POST /groups/{id}/events`

Description: Enables an event on a group of devices

Parameters: 

 - id: the id of the group of devices

Query Parameters:

 - eventName: the event to enable

The eventName is a URL encoded string that is the absolute URI that is the global
name of an `sdfEvent`. 

Response:

Returns HTTP status code 201 Created with a Location header pointing to the created event instance.

Example of a successful response:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

HTTP/1.1 201 Created
Location: /groups/12345678-1234-5678-1234-56789abcdef4/events?instan\
ceId=87654321-4321-8765-4321-fedcba9876543
~~~~~

The Location header contains the URI for the created event instance, which can be used to check status or disable the event.

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Disable event reporting on a group of devices

Method: `DELETE /groups/{id}/events{?instanceId}`

Description: Disables an event on a group of devices

Parameters:

  - id: the id of the group of devices

Query Parameters:

  - instanceId: the instance ID of the event to disable (obtained from the Location header when the event was enabled)

Response:

Returns HTTP status code 204 No Content on successful disable.

~~~~~
HTTP/1.1 204 No Content
~~~~~

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Get event status on a group of devices

Method: `GET /groups/{id}/events{?instanceId*}`

Description: Get the status of one or more events on a group of devices

Parameters:

 - id: the id of the group of devices

Query Parameters:

  - instanceId: a list of event instance IDs to filter by (optional)

Response: 

Example of a response:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

[
  {
    "instanceId": "87654321-4321-8765-4321-fedcba9876543",
    "event": "https://example.com/heartrate#/sdfObject/healthsensor/\
sdfEvent/fallDetected"
  }
]
~~~~~
{:json #exgetmgevntsresp title="Example get multiple group events status response"}

where-

 - "instanceId" is the unique instance ID for each enabled event
 - "event" is the event URI for each enabled event

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

## NIPC Action APIs

These APIs allow applications to perform actions on devices. These operations
may require a connection to the device to be established. This connection can
be established as part of the same API call implicitly. If a connection is
already active for this device, the existing connection will be leveraged
without modifying it.

### Perform an action

Method: `POST /devices/{id}/actions{?actionName}`

Description: Perform an action on a specific device

Parameters:

  - id: the id of the device

Query Parameters:

  - actionName: the action to perform

Request Body:

The request body is optional and may contain a value. The media type of the value can be defined by the underlying protocol, for example it could be octet-stream for binary data.

Response:

Actions are performed asynchronously. A successful request returns HTTP status code 202 Accepted 
with a Location header pointing to the action instance for status checking.

Example of a successful response:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

HTTP/1.1 202 Accepted
Location: /devices/12345678-1234-5678-1234-56789abcdef4/actions?inst\
anceId=87654321-4321-8765-4321-fedcba9876543
~~~~~

The Location header contains the URI for the action instance, which can be used to check the action status.

### Check action status

Method: `GET /devices/{id}/actions{?instanceId}`

Description: Check the status of an action on a specific device

Parameters:

  - id: the id of the device

Query Parameters:

  - instanceId: the instance ID of the action (obtained from the Location header)

Response:

Example of a response:

~~~~~
{
  "status": "COMPLETED"
}
~~~~~
{:json #exactionstatusresp title="Example action status response"}

where "status" indicates the current state of the action (e.g., "IN_PROGRESS" or "COMPLETED").

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

## NIPC explicit connections management APIs

A lot of protocols do not require connection management, so for these protocols, these APIs will not apply.
NIPC Gateways perform implicit connection management for protocols that require connection management (such as BLE), so in principle the user of the NIPC API does not have to perform connection management. In some cases however, a user might want to keep a connection open, perform an action, evaluate the result and perform a second action based on that result. In this case it is useful to perform explicit connection management so the connections remains established to execute subsequent actions.  These APIs allow applications to explicitly manage device connections.
The examples in this section will be based on BLE, which requires connection management.

### Connect to a device

Method: `POST /devices/{id}/connections`

Description: Connect to a device

Parameters:

  - id: the id of the device

Request Body:

  - Connection retry parameters
  - A protocol map object. In the case of BLE, if no protocol map is included,
    service discovery is performed to discover all supported properties when
    connecting to a device. Optionally, service discovery may be limited to
    properties defined in the "ble" protocol extension. The services to be 
    discovered can be added in an array. Property discover can be buffered
    across connections, so the API also supports caching parameters. 

Example body of a connection without specific discovery of properties:

~~~~~
{
  "retries": 3,
  "retryMultipleAPs": true
}
~~~~~
{:json #exconn title="Example connection"}

where-

 - "retries" defines the number of retries in case the operations does not 
   succeed
 - "retryMultipleAPs" can be used in case there is an infrastructure with 
   multiple access points or radios that can reach the device. If set to "true"
   a different access point may be used for retries.

In case the application would like to discover specific properties of a device,
a protocol mapping can be added that defines what properties should be
discovered.

Example body of a BLE connection with specific discovery of properties:

~~~~~
{
  "retries": 3,
  "retryMultipleAPs": true,
  "sdfProtocolMap": {
    "ble": {
      "services": [
        {
          "serviceID": "12345678-1234-5678-1234-56789abcdef4"
        }
      ],
      "cached": false,
      "cacheIdlePurge": 3600,
      "autoUpdate": true,
      "bonding": "default"
    }
  }
}
~~~~~
{:json #exconnprp title="Example connection with explicit discovery of connections"}

where in the BLE protocol object: 

 - "services" is an array of services defined by their serviceIDs.
 - "cached" refers to whether the services need to be cached for 
   subsequent connects, in order not to perform service discovery on
   each request.
 - "cacheIdlePurge" defines how long (in seconds) the cache should be maintained 
   before purging.
 - some devices support notifications on changes in services, 
   "autoUpdate" allows the network to update services based on 
   notification (on by default)
 - "bonding" allows you to override the bonding method configured when 
   onboarding the device

Response:

Success responses include a protocol mapping with an array of 
discovered properties, as defined in the specific protocol.
For example, for BLE, this is an array of supported services, which in turn
contains an array of charateristics, which in turn contains an array of
descriptors, as shown in {{BLEservices}}.

~~~~~
    services
     - serviceID
        |
        |> characteristics
            - charactericID
            - flags
               |
               |> Descriptors
                   - descriptorID
~~~~~
{: #BLEservices title="BLE Services"}

Example of a response:

~~~~~
{
  "id": "12345678-1234-5678-1234-56789abcdef4",
  "sdfProtocolMap": {
    "ble": [
      {
        "serviceID": "12345678-1234-5678-1234-56789abcdef4",
        "characteristics": [
          {
            "characteristicID": 
              "12345678-1234-5678-1234-56789abcdef4",
            "flags": [
              "read",
              "write"
            ],
            "descriptors": [
              {
                "descriptorID": 
                  "12345678-1234-5678-1234-56789abcdef4"
              }
            ]
          }
        ]
      }
    ]
  }
}
~~~~~
{:json #exconnresp title="Example connection response"}

where-

  - "id" is the id of the device
   - "sdfProtocolMap" contains an Array of BLE services as shown in
   {{BLEservices}}

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Update a connection

Method: `PUT /devices/{id}/connections`

Description: Update cached ServiceMap for a device. Full service discovery will
be performed, unless specific services are described in the API body.

Parameters:

  - id: the id of the device

Request Body:

  - A protocol map object. In the case of BLE, if no protocol map is included,
    service discovery is performed to discover all supported properties when
    connecting to a device. Optionally, service discovery may be limited to
    properties defined in the "ble" protocol extension. The services to be 
    discovered can be added in an array. Property discover can be buffered
    across connections, so the API also supports caching parameters. 

Example body of an update connection:

~~~~~
{
  "sdfProtocolMap": {
    "ble": {
      "services": [
        {
          "serviceID": "12345678-1234-5678-1234-56789abcdef4"
        }
      ],
      "cached": false,
      "cacheIdlePurge": 3600,
      "autoUpdate": true
    }
  }
}
~~~~~
{:json #exupconn title="Example service discovery response"}

where in the BLE protocol object: 

 - "services" is an array of services defined by their serviceIDs
 - "cached" refers to whether the services need to be cached for 
   subsequent connects, in order not to perform service discovery on
   each request
 - "cacheIdlepurge" defines how long the cache should be maintained 
   before purging
 - some devices support notifications on changes in services, 
   "autoUpdate" allows the network to update services based on 
   notification (on by default)

Response:

Success responses include a protocol mapping with an array of 
discovered properties, as defined in the specific protocol.
For example, for BLE, this is an array of supported services, which in turn
contains an array of charateristics, which in turn contains an array of
descriptors, as shown in {{BLEservices}}.

Example of a response:

~~~~~
{
  "id": "12345678-1234-5678-1234-56789abcdef4",
  "sdfProtocolMap": {
    "ble": [
      {
        "serviceID": "12345678-1234-5678-1234-56789abcdef4",
        "characteristics": [
          {
            "characteristicID": 
              "12345678-1234-5678-1234-56789abcdef4",
            "flags": [
              "read",
              "write"
            ],
            "descriptors": [
              {
                "descriptorID": 
                  "12345678-1234-5678-1234-56789abcdef4"
              }
            ]
          }
        ]
      }
    ]
  }
}
~~~~~
{:json #exupconnresp title="Example connection response"}

where-

  - "id" is the id of the device
   - "sdfProtocolMap" contains an Array of BLE services as shown in
   {{BLEservices}}

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Disconnect from a device

Method: `DELETE /devices/{id}/connections`

Description: Disconnect from a device

Parameters:

  - id: the id of the device

Response:

Returns HTTP status code 200 OK with device ID on successful disconnect.

Example of a response:

~~~~~
{
  "id": "12345678-1234-5678-1234-56789abcdef4"
}
~~~~~
{:json #exdisconnresp title="Example disconnect response"}

where "id" is the id of the device.

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Get connection status

Method: `GET /devices/{id}/connections`

Description: Get connection status for a device. Success when device(s)
is/are connected, includes service map for the device if available.
Failure when a device is not connected.

Parameters:

  - id: the id of the device

Response:

Example of a response:

~~~~~
{
  "id": "12345678-1234-5678-1234-56789abcdef4",
  "sdfProtocolMap": {
    "ble": [
      {
        "serviceID": "12345678-1234-5678-1234-56789abcdef4",
        "characteristics": [
          {
            "characteristicID": 
              "12345678-1234-5678-1234-56789abcdef4",
            "flags": [
              "read",
              "write"
            ],
            "descriptors": [
              {
                "descriptorID": 
                  "12345678-1234-5678-1234-56789abcdef4"
              }
            ]
          }
        ]
      }
    ]
  }
}
~~~~~
{:json #exconnstatresp title="Example connection status response"}

where-

  - "id" is the id of the device
  - "sdfProtocolMap" contains an Array of BLE services as shown in {{BLEservices}}

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

# NIPC Extensibility

NIPC is extensible in two ways:
 
 - Protocol mapping: New protocol mapping can extend NIPC with support
   for new non-IP protocols
 - API extensions: API extensions leverage compound statements of basic NIPC
   action APIs to simplify common operations for applications.
 
## Protocol extensions

NIPC supports mapping protocol specific properties to NIPC properties
as described in {{!I-D.mohan-asdf-sdf-protocol-mapping}}.
BLE and Zigbee are used as examples, but protocol
mapping is extensible to other protocols, so now non-IP protocols can be 
supported by NIPC without a schema change.

The protocol objects need to be extended with the new
protocol as well. Protocol objects will be extended as follows:

| Attribute  |   Type |          Example                         |
+------------+--------+------------------------------------------|
| ble        | object | an object with BLE-specific properties   |
| zigbee     | object | an object with Zigbee-specific properties|
| newProtocol| object | an object with newProtocol-specific props|
{: #newprotext title="Adding Protocol mappings"}

In the new protocol object, protocol specific properties can be added.
 
## API extensions {#apiextensions}

/extensions

The extension APIs allow for extensibility of the APIs. Extensions must be IANA registered.
Extension APIs can leverage the basic NIPC defined APIs and combine them in 
compound statements in order to streamline application operation against
devices, make operations more expediant and convenient in one API call. an example of this is the bulk API extension.
They can also introduce new functionality that is specific to a use case or protocol, such as the BLE transmit API.
the OpenAPI model {{NIPCextensions}} below, we have defined a few example extensions.

The extensions can contain long running operations, such as firmware updates,
or other bulk operations that can be performed on a device. For long 
running operations, the extension API will return a 202 Accepted status 
code and a location header with the URL to check the status of the operation.
The status of the operation can be checked by calling the status extension API
with the same device ID. The status extension API will return a 200 OK status code
when the operation is in progress. When the operation is complete, 
the status extension API will return a 303 See Other status code with a 
location header with the URL to check the status of the operation.
The GET operation on the extension API will return a 200 OK status code
with the actual response once the operation is complete.

# NIPC Error Handling
{: #errorhandling}

The error types in the NIPC APIs use URI-based error type identifiers 
as defined in {{iana-problem-details}}. The error types 
can be generic or specific to the API category. The error types are 
organized into the following categories:

  - Generic: Broadly applicable errors, including authorization, 
    invalid identifiers, and generic failures.
  - Property APIs: Errors related to property APIs (read/write).
  - Event APIs: Errors related to event APIs (enable/disable).
  - Protocol specific: Errors related to protocol-specific operations.
  - Extension APIs: Errors related to extension APIs.

The specific error types are defined in the table below:

| Error Type                                 | Description                                  | Category         |
|--------------------------------------------|----------------------------------------------|------------------|
| invalid-id                                 | Invalid device ID or gateway doesn't recognize the ID | Generic          |
| invalid-sdf-url                            | Invalid SDF URL or SDF affordance not found   | Generic           |
| extension-operation-not-executed           | Operation was not executed since the previous operation failed | Generic |
| sdf-model-already-registered               | SDF model already registered                  | Generic           |
| sdf-model-in-use                           | SDF model in use                              | Generic           |
| property-not-readable                      | Property not readable                         | Property APIs     |
| property-not-writable                      | Property not writable                         | Property APIs     |
| event-already-enabled                      | Event already enabled                         | Event APIs        |
| event-not-enabled                          | Event not enabled                             | Event APIs        |
| event-not-registered                       | Event not registered for any data application | Event APIs        |
| protocolmap-ble-already-connected          | Device already connected                      | Protocol specific |
| protocolmap-ble-no-connection              | No connection found for device                | Protocol specific |
| protocolmap-ble-connection-timeout         | BLE connection timeout                        | Protocol specific |
| protocolmap-ble-bonding-failed             | BLE bonding failed                            | Protocol specific |
| protocolmap-ble-connection-failed          | BLE connection failed                         | Protocol specific |
| protocolmap-ble-service-discovery-failed   | BLE service discovery failed                  | Protocol specific |
| protocolmap-ble-invalid-service-or-characteristic | Invalid BLE service or characteristic ID | Protocol specific     |
| protocolmap-zigbee-connection-timeout      | Zigbee connection timeout                     | Protocol specific |
| protocolmap-zigbee-invalid-endpoint-or-cluster | Invalid Zigbee endpoint or cluster ID     | Protocol specific |
| extension-transmit-invalid-data            | Invalid transmit data                         | Transmit APIs     |
| extension-firmware-rollback                | Firmware rollback                             | Extension APIs    |
| extension-firmware-update-failed           | Firmware update failed                        | Extension APIs    |
{: #errorcodes title="Error Codes"}

The appropriate HTTP status code is returned in the response. 

# Publish/Subscribe Interface

The publish/subscribe interface, or data streaming interface, is an MQTT
publishing interface. Pub/sub topics can be created and managed by means
of the /registrations/data-apps API.

In this memo, we propose the data format to be CBOR {{!RFC8949}}.

## CDDL Definition

We have a CDDL {{!RFC8610}} definition where we define the
DataSubscription struct that will be used by all the messages published 
to the MQTT broker. 

The DataSubscription struct is a CBOR map that will contain the raw data
in bytes and a timestamp of the data. Optionally, the message will also
have a deviceID that corresponds to the SCIM ID of the device if the 
payload is associated to a known device.

Other fields in the CDDL such as apMacAddress and rssi can be optionally
included but these fields can expose the underlying network topology.

Each message also has a subscription choice group that will define the
type of data that is being published.

Each MQTT message can be a collection of DataSubscription structs. This
collection is represented as DataBatch in the CDDL. 

~~~~ CDDL
{::include cddl/data_subscription.cddl}
~~~~
{:cddl}

## CBOR Examples

This section contains a few examples of the DataSubscription struct 
depicted in CBOR diagnostic notation.

~~~
[
  {
    "data": h'02011A020A0C16FF4C001007721F41B0392078',
    "deviceID": "75fde96d-886f-4ac0-a1d5-df79f76e7c9c",
    "timestamp": 1727484393,
    "bleAdvertisement": {
        "macAddress": "C1:5C:00:00:00:01",
        "rssi": -25
    }
  }
]
~~~
{: title="Onboarded BLE Device Advertisement" }

~~~
[
  {
    "data": h'02011A020A0C16FF4C001007721F41B0392078',
    "timestamp": 1727484393,
    "bleAdvertisement": {
        "macAddress": "C1:5C:00:00:00:01",
        "rssi": -25
    }
  }
]
~~~
{: title="Non-onboarded BLE Device Advertisement" }

~~~
[
  {
    "data": h'434630374346303739453036',
    "deviceID": "75fde96d-886f-4ac0-a1d5-df79f76e7c9c",
    "timestamp": 1727484393,
    "bleSubscription": {
        "serviceID": "a4e649f4-4be5-11e5-885d-feff819cdc9f",
        "characteristicID": "c4c1f6e2-4be5-11e5-885d-feff819cdc9f"
    }
  }
]
~~~
{: title="BLE GATT Notification" }

~~~
[
  {
    "deviceID": "75fde96d-886f-4ac0-a1d5-df79f76e7c9c",
    "timestamp": 1727484393,
    "bleConnectionStatus": {
        "macAddress": "C1:5C:00:00:00:01",
        "connected": true
    }
  }
]
~~~
{: title="BLE Connection status event" }

~~~
[
  {
    "data": h'434630374346303739453036',
    "deviceID": "75fde96d-886f-4ac0-a1d5-df79f76e7c9c",
    "timestamp": 1727484393,
    "zigbeeSubscription": {
        "endpointID": 1,
        "clusterID": 6,
        "attributeID": 12,
        "type": 1
    }
  }
]
~~~
{: title="Zigbee Attribute Notification" }

# Examples

This section contains a few examples on how applications can leverage 
NIPC operations to communicate with BLE and Zigbee devices.

## Property Read/Write

In this example, we will connect to a device and read and write from a
property.

The sequence of operations for this are:  

  - Onboard a device using the SCIM Interface (out of scope of this
    memo)
  - Register an SDF model for the device

    ~~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    POST /registrations/models
    Content-Type: application/sdf+json
    Accept: application/nipc+json
    Host: localhost

    { ... }

    HTTP/1.1 200 OK
    content-type: application/nipc+json

    [
      {
        "sdfName": "https://example.com/thermometer#/sdfThing/thermom\
    eter"
      }
    ]
    ~~~~~

    Request Body: JSON object with the SDF model, from {{thermometer-sdf}}

  - Read a property from the BLE device

    ~~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    GET /devices/12345678-1234-5678-1234-56789abcdef4/properties?prop\
    ertyName=https%3A%2F%2Fexample.com%2Fthermometer%23%2FsdfThing%2F\
    thermometer%2FsdfProperty%2Fdevice_name
    Accept: application/nipc+json
    Host: localhost

    HTTP/1.1 200 OK
    content-type: application/nipc+json

    [
      {
        "property": "https://example.com/thermometer#/sdfThing/thermo\
    meter/sdfProperty/device_name",
        "value": "dGVzdA=="
      }
    ]
    ~~~~~
 
  - Write to a property on the BLE device

    ~~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    PUT /devices/12345678-1234-5678-1234-56789abcdef4/properties
    Content-Type: application/nipc+json
    Host: localhost

    [
      {
        "property": "https://example.com/thermometer#/sdfThing/thermo\
    meter/sdfProperty/device_name",
        "value": "dGVzdA=="
      }
    ]

    HTTP/1.1 200 OK
    content-type: application/nipc+json

    [
      {
        "property": "https://example.com/thermometer#/sdfThing/thermo\
    meter/sdfProperty/device_name",
        "value": "dGVzdA=="
      }
    ]
    ~~~~~

## Enabling an Event

In this example, we will onboard a device, and setup an advertisement
subscription event for that device.

The sequence of operations for this are:  

  - Onboard a device and endpoint app using the SCIM Interface (out of scope of this
   memo)
  - Register an SDF model for the device

    ~~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    POST /registrations/data-apps?dataAppId=23456789-1234-5678-1234-567\
    89abcdef4
    Content-Type: application/nipc+json
    Accept: application/nipc+json
    Host: localhost

    {
      "events": [
        "https://example.com/thermometer#/sdfThing/thermometer/sdfEve\
    nt/isPresent"
      ],
      "mqttClient": true
    }

    HTTP/1.1 200 OK
    content-type: application/nipc+json

    {
      "events": [
        "https://example.com/thermometer#/sdfThing/thermometer/sdfEve\
    nt/isPresent"
      ],
      "mqttClient": true
    }
    ~~~~~

    Request Body: JSON object with the SDF model, from {{thermometer-sdf}}
    
  - Register the data app with the event 

    ~~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    POST /registrations/data-apps?dataAppId=23456789-1234-5678-1234-567\
    89abcdef4
    Content-Type: application/nipc+json
    Accept: application/nipc+json
    Host: localhost

    {
      "events": [
        "https://example.com/thermometer#/sdfThing/thermometer/sdfEve\
    nt/isPresent"
      ],
      "mqttClient": true
    }

    HTTP/1.1 200 OK
    content-type: application/nipc+json

    {
      "events": [
        "https://example.com/thermometer#/sdfThing/thermometer/sdfEve\
    nt/isPresent"
      ],
      "mqttClient": true
    }
    ~~~~~

  - Enable the advertisement event

    ~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    POST /devices/12345678-1234-5678-1234-56789abcdef4/events?eventNa\
    me=https%23%2F%2Fexample.com%2Fthermometer%23%2FsdfThing%2Fthermo\
    meter%2FsdfEvent%2FisPresent
    Host: localhost
    Content-Length: 0

    HTTP/1.1 201 Created
    Location: /devices/12345678-1234-5678-1234-56789abcdef4/events?in\
    stanceId=87654321-4321-8765-4321-fedcba9876543
    ~~~~

  - Check the status of the event

    ~~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    GET /devices/12345678-1234-5678-1234-56789abcdef4/events?instance\
    Id=87654321-4321-8765-4321-fedcba9876543
    Host: localhost

    HTTP/1.1 200 OK
    content-type: application/nipc+json

    {
      "event": "https://example.com/thermometer#/sdfThing/thermometer\
    /sdfEvent/isPresent"
    }
    ~~~~~

# Security Considerations {#security-considerations}

## API authorization 

In order to enable a network wishing to offer NIPC ALG functions, the network
administrator authorizes application(s) to perform operations on the Gateway.
This happens out of band and may be accomplished by means of exchanging tokens
or public keys.
Authorization can be role-based. The 3 primary roles are:  

1. Onboarding: Authorize an onboarding application against a SCIM server
   co-located with the gateway.  
2. Control: Authorize applications that may control devices.
3. Data: Authorize applications that may receive telemetry.  
It is possible to further refine roles down to an API basis.

# IANA Considerations

This section provides guidance to the Internet Assigned Numbers Authority
(IANA) regarding registration of values related to NIPC, in accordance
with {{!RFC8126}}.

## Media Type Registration {#iana-media-types}

This document registers the "application/nipc+json" media type 
for messages of the NIPC APIs defined in this document carrying
parameters encoded in JSON. 

Type name: application

Subtype name: nipc+json

Required parameters: none

Optional parameters: none

Encoding considerations: Encoding considerations are identical to those specified for the "application/json" media type.

Security considerations: See the {{security-considerations}} section of this document.

Interoperability considerations: none

Published specification: This document, the NIPC API specification.

Applications that use this media type:

Fragment identifier considerations: none

Additional information:

- Deprecated alias names for this type: none
 
- Magic number(s): none

- File extension(s): none

- Macintosh file type code(s): none

Person & email address to contact for further information:

Intended usage: LIMITED USE

Restrictions on usage: To be used for NIPC APIs as defined in this document.

Author:

Change controller: IETF

## API extensions {#iana-api-ext}

IANA is requested to create a new registry called "NIPC API extensions". 

The registry must contain following attributes:

- Extension URI 
- Extension name
- Description
- Openapi model describing the extension. This model must be reviewed by an expert.  

Following API extensions are described in this document:

| Extension URI                                | Extension name       | Description                                    | Model reference    |
|----------------------------------------------|----------------------|------------------------------------------------|--------------------|
| /extensions/{id}/bulk                         | Bulk API             | Call multiple NIPC's in a single request       | {{NIPCextensions}} |
| /extensions/{id}/properties/file              | File write API       | Write a file with multiple property ops        | {{NIPCextensions}} |
| /extensions/{id}/properties/blob              | Binary write API     | Write a binary blob with multiple property ops | {{NIPCextensions}} |
| /extensions/{id}/properties/read/conditional | Read conditional API | Read a property until a condition is fulfilled | {{NIPCextensions}} |
| /extensions/{id}/events/conditional          | Event conditional API| Enable an event until a condition is fulfilled | {{NIPCextensions}} |
| /extensions/{id}/transmit                 | Transmit API         | Transmits a payload to a device                | {{NIPCextensions}} |

## Well-known URIs {#iana-well-known}

IANA is requested to register the following well-known URI in the "Well-Known URIs" registry as defined by {{!RFC8615}}:

| URI Suffix | Change Controller | Specification Document            |
|------------|-------------------|-----------------------------------|
| nipc       | IETF              | This document, [](#paths-general) |

The well-known URI for NIPC is:

    /.well-known/nipc

## Problem Details for NIPC APIs {#iana-problem-details}

IANA is requested to create a new registry, the "NIPC Problem Type" registry, 
with following URL: [](https://www.iana.org/assignments/nipc-problem-types).

Registrations MUST use the prefix []("https://iana.org/assignments/nipc-problem-types#") for the type URI. 

The registration requests MUST use the template defined in {{Section 4.2 of RFC9457}}.

IANA is requested to register the following URIs in the "NIPC Problem Type" 
registry:

| Problem Type URI                                                                 | Description                                  | Reference         |
|----------------------------------------------------------------------------------|----------------------------------------------|-------------------|
| https://www.iana.org/assignments/nipc-problem-types#invalid-id              | Invalid device ID or gateway doesn't recognize the ID | This document   |
| https://www.iana.org/assignments/nipc-problem-types#invalid-sdf-url         | Invalid SDF URL or SDF affordance not found   | This document   |
| https://www.iana.org/assignments/nipc-problem-types#extension-operation-not-executed | Operation was not executed since the previous operation failed | This document   |
| https://www.iana.org/assignments/nipc-problem-types#sdf-model-already-registered | SDF model already registered                  | This document   |
| https://www.iana.org/assignments/nipc-problem-types#sdf-model-in-use        | SDF model in use                              | This document   |
| https://www.iana.org/assignments/nipc-problem-types#property-not-readable   | Property not readable                         | This document   |
| https://www.iana.org/assignments/nipc-problem-types#property-read-failed    | Property read failed                          | This document   |
| https://www.iana.org/assignments/nipc-problem-types#property-not-writable   | Property not writable                         | This document   |
| https://www.iana.org/assignments/nipc-problem-types#property-write-failed   | Property write failed                         | This document   |
| https://www.iana.org/assignments/nipc-problem-types#event-already-enabled   | Event already enabled                         | This document   |
| https://www.iana.org/assignments/nipc-problem-types#event-not-enabled       | Event not enabled                             | This document   |
| https://www.iana.org/assignments/nipc-problem-types#event-not-registered    | Event not registered for any data application | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-ble-already-connected | Device already connected                      | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-ble-no-connection | No connection found for device                | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-ble-connection-timeout | BLE connection timeout                        | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-ble-bonding-failed | BLE bonding failed                            | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-ble-connection-failed | BLE connection failed                         | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-ble-service-discovery-failed | BLE service discovery failed                  | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-ble-invalid-service-or-characteristic | Invalid BLE service or characteristic ID      | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-zigbee-connection-timeout | Zigbee connection timeout                     | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-zigbee-invalid-endpoint-or-cluster | Invalid Zigbee endpoint or cluster ID         | This document   |
| https://www.iana.org/assignments/nipc-problem-types#extension-broadcast-invalid-data | Invalid transmit data                         | This document   |
| https://www.iana.org/assignments/nipc-problem-types#extension-firmware-rollback | Firmware rollback                             | This document   |
| https://www.iana.org/assignments/nipc-problem-types#extension-firmware-update-failed | Firmware update failed                        | This document   |

Each Problem Type URI is intended for use as the "type" member in Problem Details responses as described.

--- back

# OpenAPI definition

The following non-normative model is provide for convenience of
the implementor.

~~~~~~
<CODE BEGINS>
file "openapi.yml"
{::include nipc-openapi/NIPC.yaml.folded}
<CODE ENDS>
~~~~~~
{: #openAPI}

# Protocol mapping

NIPC requires that a protocol mapping be provided as part of the SDF
model for a device or have one provided using the NIPC action APIs with 
embedded protocol mapping. The protocol mapping is a JSON object that 
describes the underlying technology used to communicate with the device 
along with any additional information needed to communicate with the 
device.

The JSON format of the protocol mapping is provided as a non-normative
OpenAPI model for the convenience of the implementor. 

## Protocol mapping OpenAPI model

~~~~~~
<CODE BEGINS>
file "ProtocolMap.yaml"
{::include nipc-openapi/protocolmaps/ProtocolMap.yaml.folded}
<CODE ENDS>
~~~~~~
{: #protocolmapmodel}

## Protocol map for BLE

~~~~~
<CODE BEGINS>
file "ProtocolMap-BLE.yaml"
{::include nipc-openapi/protocolmaps/ProtocolMap-BLE.yaml.folded}
<CODE ENDS>
~~~~~~
{: #protocolmapble}

## Protocol map for Zigbee

~~~~~
<CODE BEGINS>
file "ProtocolMap-Zigbee.yaml"
{::include nipc-openapi/protocolmaps/ProtocolMap-Zigbee.yaml.folded}
<CODE ENDS>
~~~~~~
{: #protocolmapzigbee}

# NIPC API extensions {#NIPCextensions}

The following OpenAPI models define a few example extensions to the 
NIPC API.

## NIPC API write binary blob extension

~~~~~
<CODE BEGINS>
file "Extension-Blob.yaml"
{::include nipc-openapi/extensions/Extension-Blob.yaml.folded}
<CODE ENDS>
~~~~~

## NIPC API bulk operations extension

~~~~~
<CODE BEGINS>
file "Extension-Bulk.yaml"
{::include nipc-openapi/extensions/Extension-Bulk.yaml.folded}
<CODE ENDS>
~~~~~

## NIPC API write file extension

~~~~~
<CODE BEGINS>
file "Extension-File.yaml"
{::include nipc-openapi/extensions/Extension-File.yaml.folded}
<CODE ENDS>
~~~~~

## NIPC API conditional read extension

~~~~~
<CODE BEGINS>
file "Extension-ReadConditional.yaml"
{::include nipc-openapi/extensions/Extension-ReadConditional.yaml.folded}
<CODE ENDS>
~~~~~

## NIPC API conditional event extension

~~~~~
<CODE BEGINS>
file "Extension-EventConditional.yaml"
{::include nipc-openapi/extensions/Extension-EventConditional.yaml.folded}
<CODE ENDS>
~~~~~

## NIPC API property extensions

~~~~~
<CODE BEGINS>
file "Extension-Property.yaml"
{::include nipc-openapi/extensions/Extension-Property.yaml.folded}
<CODE ENDS>
~~~~~

# Example SDF model with protocol mappings for BLE 
{: #thermometer-sdf}

~~~~~
<CODE BEGINS>
file "thermometer.sdf.json"
{::include nipc-sdf-example/thermometer.sdf.json}
<CODE ENDS>
~~~~~
{: title="Example SDF model with protocol mappings for BLE"}
