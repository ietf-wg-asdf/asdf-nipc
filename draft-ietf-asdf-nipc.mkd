---
title: An Application Layer Interface for Non-Internet-Connected Physical Components (NIPC)
abbrev: NIPC
docname: draft-ietf-asdf-nipc-15
submissionType: IETF
category: std

ipr: trust200902
keyword: Internet-Draft

stand_alone: no
pi: [toc, sortrefs, symrefs]

author:
 - 
    ins: B. Brinckman
    name: Bart Brinckman
    org: Cisco Systems
    city: Brussels
    country: Belgium
    email: bbrinckm@cisco.com
 -
    ins: R. Mohan
    name: Rohit Mohan
    org: Cisco Systems
    street: 170 West Tasman Drive
    code: 95134
    city: San Jose
    country: USA
    email: rohitmo@cisco.com
 -
    ins: B. Sanford
    name: Braeden Sanford
    org: Philips
    city: Cambridge
    country: USA
    email: braeden.sanford@philips.com

informative:
  BLE53:
    title: Bluetooth Core Specification, Version 5.3
    author:
      -
        org: Bluetooth SIG
    date: 2021
  Zigbee22:
    title: zigbee Specification, Version 22 1.0
    author:
      -
        org: Connectivity Standards Alliance
    date: 2017
  Gatt-REST-API:
    title: A RESTful API used to access data in devices using the functionality defined in the Bluetooth GATT profile
    target: https://www.bluetooth.com/bluetooth-resources/gatt-rest-api/
    author:
      -
        org: Bluetooth SIG
    date: 2017
...

--- abstract

This memo describes an API that allows applications to perform operations against a gateway serving one or more devices described by an SDF model. The document describes a RESTful application layer interface to perform operations on those devices, as well as a CBOR-based publish-subscribe interface for streaming data. 

--- middle

# Introduction

## Motivation

Low‑power sensors, actuators, and other connected devices deployed for building management, healthcare, workplace, manufacturing, logistics, and hospitality use cases are often resource and battery constrained. Many lack native IP connectivity and instead attach via heterogeneous non‑IP operational networks. Common non‑IP protocols include BLE {{BLE53}} and Zigbee {{Zigbee22}}. When IP is available, constrained application protocols such as CoAP {{?RFC7252}} may be used. These devices still need to exchange data with IP‑based applications. Accordingly, applications on the IP network obtain telemetry from and issue operations to such devices through an application‑layer gateway. This gateway bridges the application network and one or more separate operational networks where devices are connected, allowing applications on the IP network to perform operations on devices connected to these other operational networks.

~~~~~ aasvg
                                                               
    +-------------+              +---------+              +--------+
    | Application |<------------>| Gateway |<------------>| Device |                     
    |             | Application  |         |    Device    |        |
    +-------------+   network    +---------+    network   +--------+                 

~~~~~
{: #gw title="Gateway for non-IP Devices"}

There have been efforts to define Gateway functions for devices that support
a particular protocol, such as a BLE GATT REST API for BLE Gateways
({{Gatt-REST-API}}), however they have been limited to a single protocol or
a particular use case. In absence of an open standard describing how
applications on an IP network communicate with devices on other operational networks, bespoke and
vendor-specific implementations have proliferated. 
Each deployment then requires: (1) defining or adapting yet another API, and (2) deploying additional gateway functions, increasing operational and integration cost. 
This specification defines a single, extensible application layer interface for cross-network and cross-protocol device interaction through a network gateway. The intent is to support multiple network and network protocols (and versions) concurrently, allow incremental addition of new protocols via mapping, and reduce redundant infrastructure by enabling multiple applications to share one standardized gateway function.

A standardized Application Layer Gateway interface has following benefits:

 1. Eliminates repeated bespoke integration effort across deployments.
 2. Avoids deploying multiple overlapping gateway functions for different networks, protocols or use cases.
 3. Reduces time and operational cost to integrate new networks and devices.

## Non-IP Gateway

A Non-Internet-Connected Physical Components (NIPC) gateway is an application layer gateway (ALG) that implements APIs for applications to communicate with devices on different networks, leveraging different protocols. These NIPC APIs consist of reading or writing properties of devices, invoking actions on devices, as well as enabling or disabling events on devices.

In order to perform NIPC operations on a device, 2 prerequisites must be fulfilled:
- The device is onboarded (its identity and any credentials/trust material are provisioned). Onboarding is out of scope of this document. It may be performed via SCIM {{!RFC7644}} with {{!I-D.ietf-scim-device-model}}.
- An interaction model for the class of devices must be registered with the gateway. This allows the gateway to understand how to interact with the device in a protocol-neutral way. The interaction model is provided to the gateway by means of an SDF model, described in {{!I-D.ietf-asdf-sdf}}.

Once these prerequisites are met, the gateway can resolve a referenced SDF affordance into the protocol-specific operations required for that device.

A NIPC gateway provides following functions:

 - Authentication and authorization of application clients that will leverage the NIPC APIs. 
 - Maintain a repository of onboarded device objects.
 - Accept and validate SDF interaction model registrations.
 - Expose APIs for property, action, and event operations.
 - Perform implicit connection management to devices where required; optionally support explicit connection management.
 - Stream events (publish/subscribe) to authorized data applications.
 - Proxy payloads between networks without interpreting or modifying application data.
 - Operate one or more channels to supported wired or wireless networks.
 - Optionally provide a bridge between devices on one or more device networks connected to the NIPC-Gateway. This may include translating between different protocols, if   multiple protocols are supported on the device network(s).

The gateway’s role is to proxy traffic between IP and non-IP networks; it is not intended to be middleware that inspects, decodes, or transforms device payloads.

~~~~~ aasvg

                         +------------------------------------------+
                         |                                          |
+-----------+   Request  |  +---------+                             |
| onboarding+-------------->|  SCIM   |                             |
|    app    |<--------------+ Server  |                             |
+-----------+  Ctrl Endpt|  +---------+                             |
                         |                                          |
+-----------+            |  +------------+   +-------+   +--------+ |
|  Control  +----REST------>|    NIPC    +-->|  AP   +-->| Device | |
|     &     |            |  |   Gateway  |   +-------+   +--------+ |
| Telemetry |<--pub/sub-----+            |                          |
|    Apps   |            |  +------------+                          |
+-----------+            |                                          |
                         |            Network Deployment            |
                         +------------------------------------------+

~~~~~
{: #arch title="Basic Architecture"}

{{arch}} illustrates the basic components: applications, the NIPC application‑layer gateway (ALG), an access point (AP), and a device (D). The applications, ALG, and AP reside on an IP network; the AP provides a wireless or wired interface to the device. Applications often operate in a different administrative domain than the ALG and AP, so the ALG will ahve to support authorization. The ALG bridges the IP application domain and the device network, be it an IP-based or non-IP device network. This enables applications to perform operations on devices attached to those device networks. Applications use a JSON-based {{!RFC8259}} RESTful NIPC APIs for property, action, and event operations, and a CBOR‑based {{!RFC8949}} publish/subscribe interface for event streaming.

## Terminology

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in BCP
14 {{!RFC2119}} {{!RFC8174}} when, and only when, they appear in all
capitals, as shown here.

## Glossary

 - NIPC: Non-IP Control, the application layer interface defined in this
   document.
 - NIPC Gateway: An application layer gateway that implements the NIPC
   interface.
 - SDF: Semantic Device Format, a standardized format to describe devices
   and their interaction models, as defined in {{!I-D.ietf-asdf-sdf}}.
 - SDF Affordance: An interaction point on a device as defined in an SDF
   model. Examples of affordances are properties, actions & events.
 - SDF Global Name: Absolute URI (with fragment) identifying an SDF affordance.
 - SCIM: System for Cross-domain Identity Management, a standardized
   protocol to manage identity information, as defined in {{!RFC7644}}.
 - ALG: Application Layer Gateway.
 - IoT: Internet of Things.
 - Protocol Mapping / sdfProtocolMap: Mapping from protocol-neutral SDF affordances to protocol-specific operations.
 - BLE: Bluetooth Low Energy protocol.
 - Zigbee: Low-power mesh networking protocol.
 - GATT: Generic Attribute Profile used in BLE for services/characteristics/descriptors.
 - Service (BLE): Top-level GATT grouping of characteristics.
 - Characteristic (BLE): GATT data element supporting read/write/notify.
 - Descriptor (BLE): Metadata element attached to a characteristic.
 - Bonding (BLE): Procedure to establish trusted, reusable security keys.
 - Service Discovery (BLE): Procedure to enumerate GATT services/characteristics/descriptors.
 - Device Onboarding: Registration of a device identity and metadata before NIPC operations.
 - Device ID / Group ID: UUID identifying a device or a group of devices.
 - UUID: Universally unique identifier (128-bit).
 - Data Application / Data App: Registered application receiving streamed event data.
 - MQTT: Publish/subscribe messaging protocol used for streaming.
 - Webhook: HTTP callback endpoint for push delivery.
 - Websocket: Bidirectional TCP-based message channel over HTTP.
 - Publish/Subscribe Interface: Streaming channel for events (CBOR-encoded payloads).
 - CBOR: Concise Binary Object Representation; compact binary data format.
 - CDDL: Concise Data Definition Language; schema language for CBOR data.
 - JSON: JavaScript Object Notation; text encoding used for API payloads.
 - Access Point (AP): Network element with non-IP radio interface communicating with devices.

# Architecture

## Overview

A Non‑Internet‑Connected Physical Components (NIPC) gateway is an application‑layer gateway (ALG) that exposes APIs enabling applications to perform operations on devices attached to networks connected to the gateway. NIPC defines two API categories:
- Registrations: register SDF models for classes of devices and register data applications that receive streaming event data.
- Operations: perform protocol‑neutral device interactions (read/write properties, invoke actions, enable/disable events) across heterogeneous networks and protocols.

To execute NIPC operations on a device, both prerequisites MUST be met:
1. Device onboarding: The device identity and required trust material are provisioned (e.g., via SCIM {{!RFC7644}} with {{!I-D.ietf-scim-device-model}}). This yields the device ID referenced in NIPC API paths.
2. Interaction model: An SDF model {{!I-D.ietf-asdf-sdf}} is registered, providing protocol‑neutral affordances and mappings to protocol‑specific operations.

~~~~~ aasvg

    +------------+   
    |    SCIM    |                      
    |   object   |           +----------------+          
    |    {ID}    +---------->|                |
    +------------+           | NIPC Operation |
                             |    - Property  |
                             |    - Action    |
    +------------+           |    - Event     |
    |     SDF    +---------->|                |
    |    model   |           +----------------+
    +------------+  

~~~~~
{: #prereq title="NIPC prerequisites"}

Once both prerequisites are met, authorized applications can perform NIPC operations on devices identified by their IDs. See {{security-considerations}} for authorization details. NIPC operations act on SDF affordances—properties, actions, and events—defined in the registered SDF model. Certain NIPC operations may also be performed on groups of devices identified by a group ID.

## Onboarding

Onboarding is the process of declaring a device’s identity to the NIPC gateway and provisioning the trust material required to communicate with the device. The device object MUST include sufficient information to bootstrap trust and establish connectivity, as NIPC operations assume connectivity can be established without separate API calls. While onboarding can be performed in various ways, it is RECOMMENDED to use SCIM {{!RFC7644}} with the device schema {{!I-D.ietf-scim-device-model}}, which defines the necessary attributes and extensions to support NIPC. As per {{Section 4.2 of !RFC7643}}, group objects may also be declared, and leveraged in NIPC operations.

## Registrations 

NIPC registration APIs allow applications to declare information about a device class or authorize a data application. These APIs do not operate on specific devices or groups of devices.

NIPC supports two registration types:
1. SDF model registration: Registers an SDF interaction model for a class of devices.
2. Data application authorization: Authorizes an application to receive streaming event data.
Optionally, the SDF model reference and/or data‑app registration MAY be included in the device’s SCIM object. See {{!I-D.ietf-scim-device-model}} and {{!I-D.ietf-asdf-sdf-protocol-mapping}} for details.

### SDF model registrations

The SDF model for a class of devices determines how a gateway can interact with
these devices in a protocol-neutral way. To enable this, the SDF model
must contain protocol mappings, mapping protocol-neutral SDF affordances
to protocol-specific operations as defined in {{!I-D.ietf-asdf-sdf-protocol-mapping}}. 
The SDF affordances supported by the device, as well as its protocol-mappings,
are provided to the gateway by means of SDF model registration. 
SDF models are described in {{!I-D.ietf-asdf-sdf}}.

### Data application registrations

NIPC operations can enable or disable event reporting on a device. Events are reported through a publish-subscribe interface.
Applications that are authorized to perform NIPC operations on devices can define which applications are permitted to receive streaming event data for that device. The data-app registrations API maps an event to an application that is authorized to receive that data. The registration also defines what protocol will be used to deliver the data (e.g., MQTT, webhook, websocket).i This registration basically allows applications to determine which data-streams are consumed by which data-applications.

## NIPC Operations {#nipc-ops}

###  Overview {#nipc-ops-overview}

NIPC APIs are exposed over HTTP {{!RFC9110}}. Requests and responses use JSON {{!RFC8259}} unless another media type is negotiated via Content-Type and Accept. The default media type is “application/nipc+json” (see {{iana-media-types}}). SDF model registrations use “application/sdf+json”. Property APIs MAY use other media types appropriate to the property payload. 

Failures use Problem Details {{!RFC9457}} with application/problem+json.

NIPC operations are protocol-neutral operations on SDF affordances, more specifically properties, actions & events. NIPC operations can happen against
affordances registered in an SDF model. Operations reference affordances by their SDF global name. If the underlying protocol requires a connection, the gateway establishes and tears down the connection implicitly unless an explicit connection is already in place.

NIPC exposes three operation groups:
- Properties APIs: These APIs allow applications to perform operations on properties, such as to read or write values to them.
- Actions APIs: These APIs perform actions on devices, such as enabling or disabling a feature on a device.
- Events APIs: These APIs allow apps to enable or disable event reporting on devices. Events are reported over the events publish/subscribe interface.

### Properties

Property operations allow clients to read and write values for SDF properties.

Requests and responses use application/nipc+json unless another media type is negotiated via Content‑Type and Accept.
When using JSON, binary property values are base64‑encoded with padding per {{Section 5 of !RFC4648}}.
Multiple properties MAY be read or written in a single request. When a single property is addressed via a query parameter, non‑JSON media types MAY be used for the payload.
On success, the response returns either 200 with per‑property status (JSON) or 204 No Content for single, non‑JSON writes.

### Actions

Action operations invoke SDF actions on devices.

A successful action request returns 202 Accepted with a Location header referencing the action instance.
Clients poll the instance URI to obtain status (e.g., IN_PROGRESS, COMPLETED).
Request bodies are optional and MAY carry action input in a media type appropriate to the underlying protocol (e.g., octet‑stream).

### Events

Event operations enable and disable device event reporting.

Enabling an event returns 201 Created with a Location header referencing the event instance.
Disabling an event uses the instance identifier and returns 204 No Content on success (for a single device) or a per‑device status list (for a group).
Event payloads are delivered via the publish/subscribe interface encoded in CBOR {{!RFC8949}}.

### Groups

Where supported by the underlying protocol, operations MAY target a group of devices identified by a group ID. Responses for group operations return per‑device results; failures for individual devices are reported using Problem Details entries within the array.

### Connection management for NIPC Operations

For protocols that require connection setup, the gateway performs implicit connection management during an operation (establish on demand; tear down on completion). Gateways MAY support explicit connection management; when an explicit connection is active, operations reuse it and do not tear it down. Explicit connection management is described in {{nipc-connection-management-apis}}.

### Extensions {#extensions}

NIPC supports API extensions for compound or specialized operations. Extensions can execute a set of NIPC operations in a single request or provide more efficient mechanisms for specific use cases (e.g., a bulk operation).

Extensions MUST use the “/extensions” path element. To ensure interoperability, extensions MUST be registered with IANA as defined in {{iana-api-ext}}.

## Events publish subscribe interface

Events are delivered via a publish/subscribe interface. NIPC events are encoded in CBOR ({{!RFC8949}}) and can be transported over MQTT, Webhook or Websocket.

CBOR is used for the publish/subscribe interface as Non-IP payloads are typically binary. CBOR encodes binary payloads efficiently, and is more compact than JSON, therefore reducing the amount of data that needs to be transmitted to the application.

Events types include: 
- Streaming data from devices: Streaming data is activated/deactivated with the NIPC events API
- Broadcasts from devices (e.g advertisements in BLE)
- Connection events: Devices connecting & disconnecting

## Paths

### General {#paths-general}

The NIPC HTTP protocol is described in terms of a path relative to a Base URI.
The Base URI MUST NOT contain a query string, as clients MAY append additional 
path information and query parameters as part of forming the request.  The base
URI is a URL that most often consists of the "https" protocol scheme, a domain
name, and an initial path {{!RFC3986}}.  That initial path for NIPC is 
recommended to be /nipc.
For example:

      "https://example.com/nipc/"

Additionally a version number may be added, for example: 

      "https://example.com/nipc/v1/"

After the base or version number, the path must contain a collection identifier.
The collection identifier can be one of the following:

- /registrations: for NIPC registration APIs
- /devices: for NIPC operations on devices
- /groups: for NIPC operations on groups of devices
- /extensions: for NIPC extension APIs

The well-known URI `/.well-known/nipc` defined in {{iana-well-known}} can
be used to discover the base path of the NIPC APIs and the supported versions
and extensions. The response to a GET request on this URI MUST be a JSON
document that contains the base path, and optionally the supported versions and  
extension APIs. The paths MUST be a URI template as defined in {{!RFC6570}}.
The following is an example of a template defining the NIPC base path as well
as supported extensions on a server.

~~~~~ json
{
  "base_path": "/nipc",
  "versions": [
    "/v1"
  ],
  "extensions": [
    "/extensions/{id}/bulk",
    "/extensions/{id}/properties/blob",
    "/extensions/{id}/properties/file",
    "/extensions/{id}/properties/read/conditional",
    "/extensions/{id}/events/conditional",
    "/extensions/{id}/properties/write"
  ]
}
~~~~~
{: #ex-wellknown title="Example response for /.well-known/nipc"}

A formal CBOR definition of the well-known response is as follows:

~~~~ CDDL
{::include cddl/nipc_well_known.cddl}
~~~~
{:cddl}

### NIPC Registrations

Registrations leverage the base path + /registrations. NIPC supports SDF model
registrations and data-app registrations.

paths:

- /registrations/models
- /registrations/data-apps

### NIPC Operations

Every NIPC Operations API pertains to either a device or group of devices, identified by
an ID, hence the ID must be reflected as the first parameter in the path. 
For example:

      "https://example.com/nipc/v1/{id}"

The second parameter in the path refers to the NIPC operation that the API will
perform on the device. This can be:

 - properties
 - events
 - actions
 - extensions

These are described in {{nipc-ops}}.

## Schema

The NIPC schema leans heavily on the SDF schema, as defined in
{{!I-D.ietf-asdf-sdf}}. NIPC operations map directly to SDF affordances.

### SDF model registrations

To execute NIPC operations, an SDF interaction model for the device class MUST be registered. The model MUST include protocol mappings that relate protocol‑neutral SDF affordances to protocol‑specific operations.

Registration is performed via POST /registrations/models with the SDF model in the request body. A registered model can be retrieved via GET /registrations/models using the model identifier (sdfName).

### NIPC Operations

NIPC operations require two parameters:
1. Device ID: the UUID identifying the target device (or group).
2. sdfName: the SDF global name (absolute URI with fragment) of the affordance (property, action, or event) on which the operation acts.

#### Device ID

All NIPC operations are executed against a device or a group of devices.
Devices or groups of devices are identified by a unique UUID, adhering to {{!RFC9562}}.

| Attribute     | Type |          Example                     |
|---------------+------+--------------------------------------|
| id            | uuid | 1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30 |
{: #devicedef title="Definition of a device or group of devices"}

ID is a UUID assigned during onboarding (e.g., by a SCIM server). The identifier is returned when the device object is created and is used by both the application and the NIPC gateway. The application must store this UUID in order to use it to identify the device on which it wants to perform NIPC operations.
If the NIPC gateway is not co‑located with the SCIM server, it retrieves the device object from SCIM using this ID.

### SDF Name

Operations act on SDF affordances and reference them by SDF global name—an absolute URI with fragment that includes the namespace. The affordance referenced MAY be a property, action, or event; the reference is carried as a string.

For example:

| NIPC Operation | Example SDF Name used in the API                                              |
|-----------|------------------------------------------------------------------------------------|
| Property  | https://example.com/heartrate#/<br/>sdfObject/thermostat/sdfProperty/temperature   |
| Event     | https://example.com/heartrate#<br/>/sdfObject/healthsensor/sdfEvent/fallDetected   |
| Action    | https://example.com/heartrate#/<br/>sdfObject/thermostat/sdfAction/resetThermostat |
{: #nipcopsdef title="Example SDF names for NIPC operations"}

### Responses 

A NIPC Gateway will respond to a NIPC operation request synchronously, and
provide the result of the completed operation in the HTTP response. 

Exceptions to this are following:
1. Extensions: Extension APIs (see {{apiextensions}}) execute compound operationsand thus require the gateway to execute multiple
NIPC operations. On acceptance, the gateway returns 202 Accepted. Clients poll the extension URI (GET) for execution status. If a callback URI was supplied in the request, the gateway MAY send the final result upon completion.
2. Actions: Action requests return 202 Accepted with a Location header pointing to the action instance used for status tracking.

A failure response must contain an HTTP status code of 4xx or 5xx, and use {{!RFC9457}} Problem Details with `application/problem+json` media type. 

- type: a URI identifying the error (see {{errorhandling}})
- status: the 4xx or 5xx HTTP status code
- title: a brief, human‑readable summary
- detail: a human‑readable explanation specific to this occurrence
- Additional members MAY be included as permitted by {{!RFC9457}}.

Example of a failure response:

~~~~~
=============== NOTE: '\\' line wrapping per RFC 8792 ===============

{
  "type": "https://www.iana.org/assignments/nipc-problem-types#inval\
\id-id",
  "status": 400,
  "title": "Invalid Device ID",
  "detail": "Device ID 1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30 does not\
\ exist or is not a device"
}
~~~~~
{: #failure title="Example failure response"}

where-

  - "type" is a URI identifying the specific error type
  - "status" is the HTTP status code
  - "title" is a brief, human-readable summary of the error type
  - "detail" is a human-readable explanation specific to this occurrence

# NIPC Registrations

NIPC allows an application to register an SDF model for a class of devices,
as well as a data application that will receive streaming data from the 
gateway.

## SDF model registrations APIs

These APIs allow applications to register an SDF model for a class of devices.
These APIs use the `application/sdf+json` media type, as described in 
{{Section 7.1 of I-D.ietf-asdf-sdf}}.

### Register an SDF model

Method: `POST /registrations/models`

Description: Registers one or more SDF models for a class of devices

Request Body:

 - an SDF document in JSON format containing one or more sdfThings or sdfObjects, similar to the example in {{thermometer-sdf}}.

Response:

Example of a response:

~~~~~
[
 {
  "sdfName": "https://example.com/heartrate#/sdfObject/healthsensor"
 }
]
~~~~~
{:json #exregresp title="Example of a response to an SDF model registration"}

where-

 - "sdfName" is the name of the top-level sdfThing or sdfObject 
    in the SDF model

The `sdfName` in the response is wrapped in an object to allow for future
extensions to the response. 

### Get all SDF models

Method: `GET /registrations/models`

Description: Gets all SDF models registered with the gateway

Response:

Example of a response:

~~~~~
[
 {
  "sdfName": "https://example.com/heartrate#/sdfObject/healthsensor"
 },
 {
  "sdfName": "https://example.com/thermometer#/sdfObject/thermometer"
 }
]
~~~~~
{:json #exgetallresp title="Example get all SDF models response"}

where-

 - "sdfName" is the name of the top-level sdfThing or sdfObject 
    in the SDF model

### Get an SDF model

Method: `GET /registrations/models{?sdfName}`

Description: Gets an SDF model registered with the gateway

Query Parameters: 

 - sdfName: the name of the top-level sdfThing or sdfObject 
    in the SDF model.

Response:

The SDF model is returned in JSON format, similar to the example in 
{{thermometer-sdf}}.

### Delete an SDF model

Method: `DELETE /registrations/models{?sdfName}`

Description: Deletes an SDF model registered with the gateway

Query Parameters: 

 - sdfName: the name of the top-level sdfThing or sdfObject 
    in the SDF model.

Response:

Example of a response:

~~~~~
{
  "sdfName": "https://example.com/heartrate#/sdfObject/healthsensor"
}
~~~~~
{:json #exdelresp title="Example delete SDF model response"}

where-

 - "sdfName" is the name of the top-level sdfThing or sdfObject 
    in the SDF model

### Update an SDF model

Method: `PUT /registrations/models{?sdfName}`

Description: Updates an SDF model registered with the gateway

Query Parameters: 

 - sdfName: the name of the top-level sdfThing or sdfObject 
    in the SDF model.

Request Body:

 - an SDF model in JSON format, similar to the example in {{thermometer-sdf}}.

Response:

Example of a response:

~~~~~
{
  "sdfName": "https://example.com/heartrate#/sdfObject/healthsensor"
}
~~~~~
{:json #exupresp title="Example update SDF model response"}

where-

 - "sdfName" is the name of the top-level sdfThing or sdfObject 
    in the SDF model

## Data application registrations APIs

These APIs allow applications to register a data application that will receive
streaming data from the gateway. These APIs operate on a data app ID.
This ID corresponds to the endpoint app ID of the telemetry endpoint app 
that is registered with the SCIM server. The endpoint app is defined in 
{{Section 6 of I-D.ietf-scim-device-model}}.

Apart from the endpoint app ID, the API also registers the protocol the data-app supports. These can be one of the following:

- mqttClient: The data-app is an MQTT client, which means that the gateway is an MQTT broker.
- mqttBroker: The data-app is an MQTT broker. The registration API has to include the MQTT broker configuration data, such as the URI, credentials and MQTT topic to publish to.
- webhook: The data-app supports a webhook the gateway can publish to. The registration API has to include the webhook URI & credentials.
- websocket: The data-app supports a websocket interface. The registration API has to include the websocket URI & credentials.

### Register a data application

Method: `POST /registrations/data-apps{?dataAppId}`

Description: Registers a data application with the gateway

Query Parameters: 

 - dataAppId: the ID of the data application

Request Body:

 - events: a list of events that the data application wants to receive
   streaming data for.

The request body also contains one of the following: 

 - mqttClient: a boolean that denotes that the data application
   is an MQTT client that will receive streaming data over MQTT
 - mqttBroker: an object that contains the MQTT broker information
   where the broker will publish the streaming data. 
    - URI: the URI of the MQTT broker.
    - username: the username to authenticate with the MQTT broker
    - password: the password to authenticate with the MQTT broker
    - brokerCACert: the base64-encoded CA certificate of the MQTT broker (optional)
    - customTopic: By default, the topic will be composed of `data-app/<dataAppId>/<namespace>/<json_pointer_to_sdf_event>`, as described in {{nipc-event-apis}}.
      You can configure a custom topic to publish the streaming data to (optional)
 - webhook: an object that contains a webhook URL along with any 
    credentials that are required to authenticate the webhook. 
    The webhook URL is the endpoint where the streaming data will be sent.
    - URI: the webhook URL. The URL MUST include the scheme used by the webhook server (e.g., "https://"). It is up to the implementation to support different schemes. If a scheme is not supported, the NIPC gateway MUST return an error response with type
      "https://www.iana.org/assignments/nipc-problem-types#unsupported-uri-scheme".
    - headers: An object that contains the headers to be sent with the webhook
      request. The headers can contain any authentication information
      required by the webhook server. Each header is represented as a key-value pair in the object.
    - serverCACert: the CA certificate of the webhook server, encoded as per {{!RFC7468}} and newlines encoded as '\n' (optional)
 - websocket: an object that contains a websocket URL along with any 
   credentials that are required to authenticate the websocket. 
   The websocket URL is the endpoint where the streaming data will be sent.
    - URI: the websocket URL. The URL MUST include the scheme used by the websocket server (e.g., "wss://"). It is up to the implementation to support different schemes. If a scheme is not supported, the NIPC gateway MUST return an error response with type
      "https://www.iana.org/assignments/nipc-problem-types#unsupported-uri-scheme".
    - headers: An object that contains the headers to be sent with the websocket
      request. The headers can contain any authentication information
      required by the websocket server. Each header is represented as a key-value pair in the object.
    - serverCACert: the CA certificate of the websocket server, encoded as per {{!RFC7468}} and newlines encoded as '\n' (optional)

Example of a request body:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

{
  "events": [
    {
      "event": "https://example.com/heartrate#/sdfObject/healthsenso\
r/sdfEvent/fallDetected"
    }
  ],
  "mqttClient": true
}
~~~~~
{:json #exregmqttclientrsp title="Example with mqttClient"}

Example of a request body for a data application that is an MQTT broker:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

{
  "events": [
    {
      "event": "https://example.com/heartrate#/sdfObject/healthsenso\
r/sdfEvent/fallDetected"
    }
  ],
  "mqttBroker": {
    "URI": "mqtt.example.com:1883",
    "username": "user",
    "password": "password",
    "customTopic": "custom/topic"
  }
}
~~~~~
{:json #exregmqttbrokerrsp title="Example with mqttBroker"}

Response:

If successful, the response will be identical to the request body. 

### Update a data application

Method: `PUT /registrations/data-apps{?dataAppId}`

Description: Updates a data application with the gateway

Query Parameters: 

 - dataAppId: the ID of the data application

Request Body: Same as the request body for the register data application API.

Response: 

If successful, the response will be identical to the request body.

### Get a data application

Method: `GET /registrations/data-apps{?dataAppId}`

Description: Gets a data application registered with the gateway

Query Parameters: 

 - dataAppId: the ID of the data application

Response:

The response will be identical to the request body for the register data
application API.

### Delete a data application

Method: `DELETE /registrations/data-apps{?dataAppId}`

Description: Deletes a data application registered with the gateway

Query Parameters: 

 - dataAppId: the ID of the data application

Response:

The response will be identical to the request body for the register data
application API.

# NIPC APIs

The primary goal of the NIPC APIs is to  perform operations on SDF Affordances, such as properties, events & actions.This allows a user of the NIPC API to get or update properties of devices, perform actions on devices, and consume events from devices.

The NIPC APIs consist of three main collections which reflect SDF Affordances as defined in {{Section 1.2 of I-D.ietf-asdf-sdf}}: 

 - NIPC Property APIs: These APIs allow applications to get and update device 
   properties.
 - NIPC Event APIs: These APIs allow applications to enable or disable event
   reporting on devices.
 - NIPC Action APIs: These APIs allow applications to perform actions on
   devices.

One or more SDF models must be registered in order to use these NIPC
Property, Event and Action APIs. The SDF models can be a top-level sdfThing with
multiple sdfObjects or a top-level sdfObject. These APIs depend on the SDF 
affordances (i.e. sdfProperty, sdfEvent and sdfAction) defined in
the SDF model and a device ID that is defined in {{I-D.ietf-scim-device-model}}.
An SDF affordance can be referenced using the global name of the SDF affordance
as described in {{Section 4 of I-D.ietf-asdf-sdf}}.

The SDF global name will be used against the registered SDF model to 
determine the protocol-specific protocolmap that the NIPC API will operate on. 
The SDF global name is also percent-encoded as per {{Section 2.1 of !RFC3986}}.

## NIPC Property APIs

These APIs allow applications to get and update device properties. 
These operations may require a connection to the device to be established. 
This connection can be established as part of the same API call implicitly.
If a connection is already active for this device, the existing connection will
be leveraged without modifying it.

These APIs support multiple media types based on Content-Type and Accept
headers to accommodate different data formats. 

When using `application/nipc+json`, the request and response bodies follow 
the format shown in the examples above, with binary data encoded as 
base64 in the "value" field. 
For other content types, the data is transmitted according to the 
specific format requirements of that media type.

### Write multiple values

Method: `PUT /devices/{id}/properties{?propertyName}`

Description: Write values to one or more properties on a device

Parameters: 

 - id: the ID of the device

Query Parameters:

  - propertyName: a single property to update. If this parameter is
    provided, the request body can contain any content type payload 
    with the value to write to the property. If this parameter is not
    provided, the request body MUST contain an application/nipc+json payload
    with an array of properties to update, each containing a property and a
    value.

Request Body:

  - If the query parameter propertyName is provided, the request body
    can contain any content type payload with the value to write to the property.
    The value is encoded as per the content type of the payload.
    
  or 

  - an array of properties to update, each containing a property and a value.
    The value is the raw binary data, encoded in base64 with padding as per 
    {{Section 5 of !RFC4648}}.

Example body updating multiple properties:

~~~~~ json
=============== NOTE: '\' line wrapping per RFC 8792 ================

[
  {
    "property": "https://example.com/heartrate#/sdfObject/thermostat\
/sdfProperty/temperature",
    "value": "dGVzdA=="
  },
  {
    "property": "https://example.com/heartrate#/sdfObject/thermostat\
/sdfProperty/humidity",
    "value": "eGVzdB=="
  }
]
~~~~~
{:json #exupmprop title="Example updating multiple properties"}

Response: 

If the Accept header is set to `application/nipc+json`, the response will be
an array with a status field set to 200 for each property that was updated, 
or a problem type object for each property that failed to update.

If the Accept header is set to any other media type and the propertyName query parameter is provided, the response will be 204 No Content with no body.

Example of a response:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

[
  {
    "status": 200
  },
  {
    "type": "https://www.iana.org/assignments/nipc-problem-types#inv\
alid-property",
    "status": 400,
    "title": "Invalid Property",
    "detail": "Property https://example.com/heartrate#/sdfObject/the\
rmostat/sdfProperty/temperature does not exist or is not writable"
  }
]
~~~~~
{:json #exupmresp title="Example update multiple properties response"}

where-

 - "properties" is an array of properties that were updated, each containing
   a property and a value

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Read multiple values

Method: `GET /devices/{id}/properties{?propertyName*}`

Description: Read values from one or more properties on a device

Parameters: 

 - id: the ID of the device

Query Parameters:

 - propertyName: The property to read. This can be a single property or multiple
   properties. If multiple properties are provided, the request body MUST
   contain an application/nipc+json payload with an array of properties to read.

Response:

If the Accept header is set to `application/nipc+json`, the response will be
an array of properties, each containing a property and a value. The value is
the raw binary data read from the property, encoded in base64 with padding as per {{Section 5 of !RFC4648}}.


Example of a response:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

[
  {
    "property": "https://example.com/heartrate#/sdfObject/thermostat\
/sdfProperty/temperature",
    "value": "dGVzdA=="
  },
  {
    "property": "https://example.com/heartrate#/sdfObject/thermostat\
/sdfProperty/humidity",
    "value": "eGVzdB=="
  }
]
~~~~~
{:json #exreadmresp title="Example read multiple properties response"}

where-

 - "property" is the property that was read from
 - "value" is the bytes that were read in base64 encoding

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

## NIPC Event APIs {#nipc-event-apis}

These APIs allow applications to enable or disable event reporting on devices.
These operations may require a connection to the device to be established. This
connection can be established as part of the same API call implicitly. If a
connection is already active for this device, the existing connection will be
leveraged without modifying it.

The event is the global name of an `sdfEvent`. 

The ID in the path is the ID of the device or group of devices.
An event can be enabled on a group of devices if it is supported by the
underlying protocol. For example, if the underlying protocol is BLE, 
the event can be enabled on a group of devices if the event is an 
advertisement event or connection status event.

If the data application registered for this event is an MQTT broker or 
client, the event is used to construct the MQTT topic for the event.
The topic is constructed using the data application ID, the default 
namespace for the event, and the event itself. For example, if the data 
application ID is `"0927ce7c-b258-4bfa-a345-bcc9f74385b4"` 
and the event is 
`"https://example.com/thermometer#/sdfThing/thermometer/sdfEvent/isPresent"`,
the topic will be:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

data-app/<dataAppId>/<namespace>/<json_pointer_to_sdf_event>

data-app/0927ce7c-b258-4bfa-a345-bcc9f74385b4/thermometer/sdfThing/\
thermometer/sdfEvent/isPresent
~~~~~

A data application can subscribe to this topic using the topic or it 
can use MQTT wildcards to subscribe to `data-app/+/temperature/#` to 
receive all events for the `temperature` namespace.

If a custom topic is provided for an MQTT broker, the custom topic is
used as the MQTT topic instead.

### Enable event reporting

Method: `POST /devices/{id}/events{?eventName}`

Description: Enables an event on a specific device

Parameters: 

 - id: the ID of the device

Query Parameters:

 - eventName: the event to enable

The eventName is a URL encoded string that is the absolute URI that is the global
name of an `sdfEvent`. 

Response:

Returns HTTP status code 201 Created with a Location header pointing to the created event instance.

Example of a successful response:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

HTTP/1.1 201 Created
Location: /devices/1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30/events?insta\
nceId=02ee282c-8915-4b2e-bbd2-88966773134a
~~~~~

The Location header contains the URI for the created event instance, which can be used to check status or disable the event.

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Disable event reporting

Method: `DELETE /devices/{id}/events{?instanceId}`

Description: Disables an event on a specific device

Parameters:

  - id: the ID of the device or group of devices

Query Parameters:

  - instanceId: the instance ID of the event to disable (obtained from the Location header when the event was enabled)

Response:

Returns HTTP status code 204 No Content on successful disable.

~~~~~
HTTP/1.1 204 No Content
~~~~~

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Get status of one or more events

Method: `GET /devices/{id}/events{?instanceId*}`

Description: Get the status of one or more events on a specific device

Parameters:

 - id: the ID of the device or group of devices

Query Parameters:

  - instanceId: a comma separated list of event instance IDs to filter by (optional)

Response: 

Example of a response:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

[
  {
    "instanceId": "02ee282c-8915-4b2e-bbd2-88966773134a",
    "event": "https://example.com/heartrate#/sdfObject/healthsensor/\
sdfEvent/fallDetected"
  }
]
~~~~~
{:json #exgetmresp title="Example get multiple events status response"}

where-

 - "instanceId" is the unique instance ID for each enabled event
 - "event" is the event URI for each enabled event

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Enable event reporting on a group of devices

Method: `POST /groups/{id}/events`

Description: Enables an event on a group of devices

Parameters: 

 - id: the ID of the group of devices

Query Parameters:

 - eventName: the event to enable

The eventName is a URL encoded string that is the absolute URI that is the global
name of an `sdfEvent`. 

Response:

Returns HTTP status code 201 Created with a Location header pointing to the created event instance.

Example of a successful response:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

HTTP/1.1 201 Created
Location: /groups/0dc729d7-f6c3-491d-9b9d-e7176d2be243/events?instan\
ceId=f1b9f26b-21ce-4deb-9d57-289ba7e17cce
~~~~~

The Location header contains the URI for the created event instance, which can be used to check status or disable the event.

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Disable event reporting on a group of devices

Method: `DELETE /groups/{id}/events{?instanceId}`

Description: Disables an event on a group of devices

Parameters:

  - id: the ID of the group of devices

Query Parameters:

  - instanceId: the instance ID of the event to disable (obtained from the Location header when the event was enabled)

Response:

Returns HTTP status code 200 with a list of the event status for the group of devices.
If the event was successfully disabled on a device, the response will contain
the device ID and SDF event name for that device. If the event could not be disabled
on a device, the response will contain a problem type error response for that device.

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

[
  {
    "event": "https://example.com/heartrate#/sdfObject/healthsensor/\
sdfEvent/fallDetected",
    "deviceId": "1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30"
  },
  {
    "event": "https://example.com/heartrate#/sdfObject/healthsensor/\
sdfEvent/fallDetected",
    "deviceId": "d62c7fb2-a216-4811-a388-053b17fdbedc"
  },
  {
    "event": "https://example.com/heartrate#/sdfObject/healthsensor/\
sdfEvent/fallDetected",
    "deviceId": "01b52a23-b98c-454c-ba9e-086a43bdfd79"
  },
  {
    "type": "https://www.iana.org/assignments/nipc-problem-types#eve\
nt-not-enabled",
    "status": 400,
    "title": "Event Not Enabled",
    "deviceId": "9171ec16-e3c1-4ccf-ad23-b92a1a3f069d",
    "detail": "Failed to disable the event for device 9171ec16-e3c1-\
    4ccf-ad23-b92a1a3f069d"
  }
]
~~~~~

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Get event status on a group of devices

Method: `GET /groups/{id}/events{?instanceId}`

Description: Get the status of one or more events on a group of devices

Parameters:

 - id: the ID of the group of devices

Query Parameters:

  - instanceId: The instance ID of the event to get the status for

Response: 

Returns HTTP status code 200 with a list of the event status for the group of devices.
If the event was successfully enabled on a device, the response will contain
the device ID and SDF event name for that device. If the event could not be enabled
on a device, the response will contain a problem type error response for that device.

Example of a response:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

[
  {
    "event": "https://example.com/heartrate#/sdfObject/healthsensor/\
sdfEvent/fallDetected",
    "deviceId": "1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30"
  },
  {
    "event": "https://example.com/heartrate#/sdfObject/healthsensor/\
sdfEvent/fallDetected",
    "deviceId": "d62c7fb2-a216-4811-a388-053b17fdbedc"
  },
  {
    "event": "https://example.com/heartrate#/sdfObject/healthsensor/\
sdfEvent/fallDetected",
    "deviceId": "01b52a23-b98c-454c-ba9e-086a43bdfd79"
  },
  {
    "type": "https://www.iana.org/assignments/nipc-problem-types#eve\
nt-not-enabled",
    "status": 400,
    "title": "Event Not Enabled",
    "deviceId": "9171ec16-e3c1-4ccf-ad23-b92a1a3f069d",
    "detail": "Failed to disable the event for device 9171ec16-e3c1-\
4ccf-ad23-b92a1a3f069d"
  }
]
~~~~~
{:json #exgetmgevntsresp title="Example get multiple group events status response"}

where-

 - "instanceId" is the unique instance ID for each enabled event
 - "event" is the event URI for each enabled event

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

## NIPC Action APIs

These APIs allow applications to perform actions on devices. These operations
may require a connection to the device to be established. This connection can
be established as part of the same API call implicitly. If a connection is
already active for this device, the existing connection will be leveraged
without modifying it.

### Perform an action

Method: `POST /devices/{id}/actions{?actionName}`

Description: Perform an action on a specific device

Parameters:

  - id: the ID of the device

Query Parameters:

  - actionName: the action to perform

Request Body:

The request body is optional and may contain a value. The media type of the value can be defined by the underlying protocol, for example it could be octet-stream for binary data.

Response:

Actions are performed asynchronously. A successful request returns HTTP status code 202 Accepted 
with a Location header pointing to the action instance for status checking.

Example of a successful response:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

HTTP/1.1 202 Accepted
Location: /devices/1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30/actions?inst\
anceId=02ee282c-8915-4b2e-bbd2-88966773134a
~~~~~

The Location header contains the URI for the action instance, which can be used to check the action status.

### Check action status

Method: `GET /devices/{id}/actions{?instanceId}`

Description: Check the status of an action on a specific device

Parameters:

  - id: the ID of the device

Query Parameters:

  - instanceId: the instance ID of the action (obtained from the Location header)

Response:

Example of a response:

~~~~~
{
  "status": "COMPLETED"
}
~~~~~
{:json #exactionstatusresp title="Example action status response"}

where "status" indicates the current state of the action (e.g., "IN_PROGRESS" or "COMPLETED").

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

## NIPC explicit connections management APIs {#nipc-connection-management-apis}

Many protocols do not require connection management, so for these protocols, these APIs will not apply.
NIPC Gateways perform implicit connection management for protocols that require connection management (such as BLE), so in principle the user of the NIPC API does not have to perform connection management. In some cases however, a user might want to keep a connection open, perform an action, evaluate the result and perform a second action based on that result. In this case it is useful to perform explicit connection management so the connection remains established to execute subsequent actions.  These APIs allow applications to explicitly manage device connections.
The examples in this section will be based on BLE, which requires connection management.

### Connect to a device

Method: `POST /devices/{id}/connections`

Description: Connect to a device

Parameters:

  - id: the ID of the device

Request Body:

  - Connection retry parameters
  - A protocol map object. In the case of BLE, if no protocol map is included,
    service discovery is performed to discover all supported properties when
    connecting to a device. Optionally, service discovery may be limited to
    properties defined in the "ble" protocol extension. The services to be 
    discovered can be added in an array. Property discovery can be buffered
    across connections, so the API also supports caching parameters. 

Example body of a connection without specific discovery of properties:

~~~~~
{
  "retries": 3,
  "retryMultipleAPs": true
}
~~~~~
{:json #exconn title="Example connection"}

where-

 - "retries" defines the number of retries in case the operation does not 
   succeed
 - "retryMultipleAPs" can be used in case there is an infrastructure with 
   multiple access points or radios that can reach the device. If set to "true"
   a different access point may be used for retries.

In case the application would like to discover specific properties of a device,
a protocol mapping can be added that defines what properties should be
discovered.

Example body of a BLE connection with specific discovery of properties:

~~~~~
{
  "retries": 3,
  "retryMultipleAPs": true,
  "sdfProtocolMap": {
    "ble": {
      "services": [
        {
          "serviceID": "00001809-0000-1000-8000-00805f9b34fb"
        }
      ],
      "cached": false,
      "cacheIdlePurge": 3600,
      "autoUpdate": true,
      "bonding": "default"
    }
  }
}
~~~~~
{:json #exconnprp title="Example connection with explicit discovery of connections"}

where in the BLE protocol object: 

 - "services" is an array of services defined by their serviceIDs.
 - "cached" refers to whether the services need to be cached for 
   subsequent connects, in order not to perform service discovery on
   each request.
 - "cacheIdlePurge" defines how long (in seconds) the cache should be maintained 
   before purging.
 - some devices support notifications on changes in services, 
   "autoUpdate" allows the network to update services based on 
   notification (on by default)
 - "bonding" allows you to override the bonding method configured when 
   onboarding the device

Response:

Success responses include a protocol mapping with an array of 
discovered properties, as defined in the specific protocol.
For example, for BLE, this is an array of supported services, which in turn
contains an array of characteristics, which in turn contains an array of
descriptors, as shown in {{BLEservices}}.

~~~~~
    services
     - serviceID
        |
        |> characteristics
            - characteristicID
            - flags
               |
               |> Descriptors
                   - descriptorID
~~~~~
{: #BLEservices title="BLE Services"}

Example of a response:

~~~~~
{
  "id": "1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30",
  "sdfProtocolMap": {
    "ble": [
      {
        "serviceID": "00001809-0000-1000-8000-00805f9b34fb",
        "characteristics": [
          {
            "characteristicID": 
              "00002a1c-0000-1000-8000-00805f9b34fb",
            "flags": [
              "read",
              "write"
            ],
            "descriptors": [
              {
                "descriptorID": 
                  "00002902-0000-1000-8000-00805f9b34fb"
              }
            ]
          }
        ]
      }
    ]
  }
}
~~~~~
{:json #exconnresp title="Example connection response"}

where-

  - "id" is the ID of the device
   - "sdfProtocolMap" contains an Array of BLE services as shown in
   {{BLEservices}}

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Update a connection

Method: `PUT /devices/{id}/connections`

Description: Update cached ServiceMap for a device. Full service discovery will
be performed, unless specific services are described in the API body.

Parameters:

  - id: the ID of the device

Request Body:

  - A protocol map object. In the case of BLE, if no protocol map is included,
    service discovery is performed to discover all supported properties when
    connecting to a device. Optionally, service discovery may be limited to
    properties defined in the "ble" protocol extension. The services to be 
    discovered can be added in an array. Property discovery can be buffered
    across connections, so the API also supports caching parameters. 

Example body of an update connection:

~~~~~
{
  "sdfProtocolMap": {
    "ble": {
      "services": [
        {
          "serviceID": "00001809-0000-1000-8000-00805f9b34fb"
        }
      ],
      "cached": false,
      "cacheIdlePurge": 3600,
      "autoUpdate": true
    }
  }
}
~~~~~
{:json #exupconn title="Example service discovery response"}

where in the BLE protocol object: 

 - "services" is an array of services defined by their serviceIDs
 - "cached" refers to whether the services need to be cached for 
   subsequent connects, in order not to perform service discovery on
   each request
 - "cacheIdlePurge" defines how long the cache should be maintained 
   before purging
 - some devices support notifications on changes in services, 
   "autoUpdate" allows the network to update services based on 
   notification (on by default)

Response:

Success responses include a protocol mapping with an array of 
discovered properties, as defined in the specific protocol.
For example, for BLE, this is an array of supported services, which in turn
contains an array of characteristics, which in turn contains an array of
descriptors, as shown in {{BLEservices}}.

Example of a response:

~~~~~
{
  "id": "1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30",
  "sdfProtocolMap": {
    "ble": [
      {
        "serviceID": "00001809-0000-1000-8000-00805f9b34fb",
        "characteristics": [
          {
            "characteristicID": 
              "00002a1c-0000-1000-8000-00805f9b34fb",
            "flags": [
              "read",
              "write"
            ],
            "descriptors": [
              {
                "descriptorID": 
                  "00002902-0000-1000-8000-00805f9b34fb"
              }
            ]
          }
        ]
      }
    ]
  }
}
~~~~~
{:json #exupconnresp title="Example connection response"}

where-

  - "id" is the ID of the device
   - "sdfProtocolMap" contains an Array of BLE services as shown in
   {{BLEservices}}

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Disconnect from a device

Method: `DELETE /devices/{id}/connections`

Description: Disconnect from a device

Parameters:

  - id: the ID of the device

Response:

Returns HTTP status code 200 OK with device ID on successful disconnect.

Example of a response:

~~~~~
{
  "id": "1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30"
}
~~~~~
{:json #exdisconnresp title="Example disconnect response"}

where "id" is the ID of the device.

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Get connection status

Method: `GET /devices/{id}/connections`

Description: Get connection status for a device. Success when device(s)
is/are connected, includes service map for the device if available.
Failure when a device is not connected.

Parameters:

  - id: the ID of the device

Response:

Example of a response:

~~~~~
{
  "id": "1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30",
  "sdfProtocolMap": {
    "ble": [
      {
        "serviceID": "00001809-0000-1000-8000-00805f9b34fb",
        "characteristics": [
          {
            "characteristicID": 
              "00002a1c-0000-1000-8000-00805f9b34fb",
            "flags": [
              "read",
              "write"
            ],
            "descriptors": [
              {
                "descriptorID": 
                  "00002902-0000-1000-8000-00805f9b34fb"
              }
            ]
          }
        ]
      }
    ]
  }
}
~~~~~
{:json #exconnstatresp title="Example connection status response"}

where-

  - "id" is the ID of the device
  - "sdfProtocolMap" contains an Array of BLE services as shown in {{BLEservices}}

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

# NIPC Extensibility

NIPC is extensible in two ways:
 
 - Protocol mapping: New protocol mapping can extend NIPC with support
   for new non-IP protocols
 - API extensions: API extensions leverage compound statements of basic NIPC
   action APIs to simplify common operations for applications.
 
## Protocol extensions

NIPC supports mapping protocol specific properties to NIPC properties
as described in {{!I-D.ietf-asdf-sdf-protocol-mapping}}.
BLE and Zigbee are used as examples, but protocol
mapping is extensible to other protocols, so now non-IP protocols can be 
supported by NIPC without a schema change.

The protocol objects need to be extended with the new
protocol as well. Protocol objects will be extended as follows:

| Attribute  |   Type |          Example                         |
+------------+--------+------------------------------------------|
| ble        | object | an object with BLE-specific properties   |
| zigbee     | object | an object with Zigbee-specific properties|
| newProtocol| object | an object with newProtocol-specific props|
{: #newprotext title="Adding Protocol mappings"}

In the new protocol object, protocol specific properties can be added.
 
## API extensions {#apiextensions}

/extensions

The extension APIs allow for extensibility of the APIs. Extensions must be IANA registered.
Extension APIs can leverage the basic NIPC defined APIs and combine them in 
compound statements in order to streamline application operation against
devices, make operations more expedient and convenient in one API call. An example of this is the bulk API extension.
They can also introduce new functionality that is specific to a use case or protocol, such as the BLE transmit API.
the OpenAPI model {{NIPCextensions}} below, we have defined a few example extensions.

The extensions can contain long running operations, such as firmware updates,
or other bulk operations that can be performed on a device. For long 
running operations, the extension API will return a 202 Accepted status 
code and a location header with the URL to check the status of the operation.
The status of the operation can be checked by calling the status extension API
with the same device ID. The status extension API will return a 200 OK status code
when the operation is in progress. When the operation is complete, 
the status extension API will return a 303 See Other status code with a 
location header with the URL to check the status of the operation.
The GET operation on the extension API will return a 200 OK status code
with the actual response once the operation is complete.

# NIPC Error Handling
{: #errorhandling}

The error types in the NIPC APIs use URI-based error type identifiers 
as defined in {{iana-problem-details}}. The error types 
can be generic or specific to the API category. The error types are 
organized into the following categories:

  - Generic: Broadly applicable errors, including authorization, 
    invalid identifiers, and generic failures.
  - Property APIs: Errors related to property APIs (read/write).
  - Event APIs: Errors related to event APIs (enable/disable).
  - Protocol specific: Errors related to protocol-specific operations.
  - Extension APIs: Errors related to extension APIs.

The specific error types are defined in the table below:

| Error Type                                 | Description                                  | Category         |
|--------------------------------------------|----------------------------------------------|------------------|
| invalid-id                                 | Invalid device ID or gateway doesn't recognize the ID | Generic          |
| invalid-sdf-url                            | Invalid SDF URL or SDF affordance not found   | Generic           |
| extension-operation-not-executed           | Operation was not executed since the previous operation failed | Generic |
| sdf-model-already-registered               | SDF model already registered                  | Generic           |
| sdf-model-in-use                           | SDF model in use                              | Generic           |
| unsupported-uri-scheme                     | Unsupported URI scheme                        | Generic           |
| property-not-readable                      | Property not readable                         | Property APIs     |
| property-not-writable                      | Property not writable                         | Property APIs     |
| event-already-enabled                      | Event already enabled                         | Event APIs        |
| event-not-enabled                          | Event not enabled                             | Event APIs        |
| event-not-registered                       | Event not registered for any data application | Event APIs        |
| protocolmap-ble-already-connected          | Device already connected                      | Protocol specific |
| protocolmap-ble-no-connection              | No connection found for device                | Protocol specific |
| protocolmap-ble-connection-timeout         | BLE connection timeout                        | Protocol specific |
| protocolmap-ble-bonding-failed             | BLE bonding failed                            | Protocol specific |
| protocolmap-ble-connection-failed          | BLE connection failed                         | Protocol specific |
| protocolmap-ble-service-discovery-failed   | BLE service discovery failed                  | Protocol specific |
| protocolmap-ble-invalid-service-or-characteristic | Invalid BLE service or characteristic ID | Protocol specific     |
| protocolmap-zigbee-connection-timeout      | Zigbee connection timeout                     | Protocol specific |
| protocolmap-zigbee-invalid-endpoint-or-cluster | Invalid Zigbee endpoint or cluster ID     | Protocol specific |
| extension-transmit-invalid-data            | Invalid transmit data                         | Transmit APIs     |
| extension-firmware-rollback                | Firmware rollback                             | Extension APIs    |
| extension-firmware-update-failed           | Firmware update failed                        | Extension APIs    |
{: #errorcodes title="Error Codes"}

The appropriate HTTP status code is returned in the response. 

# Publish/Subscribe Interface

The publish/subscribe interface, or data streaming interface, is an MQTT
publishing interface. Pub/sub topics can be created and managed by means
of the /registrations/data-apps API.

In this memo, we propose the data format to be CBOR {{!RFC8949}}.

## CDDL Definition

We have a CDDL {{!RFC8610}} definition where we define the
DataSubscription struct that will be used by all the messages published 
to the MQTT broker. 

The DataSubscription struct is a CBOR map that will contain the raw data
in bytes and a timestamp of the data. Optionally, the message will also
have a deviceID that corresponds to the SCIM ID of the device if the 
payload is associated to a known device.

Other fields in the CDDL such as apMacAddress and rssi can be optionally
included but these fields can expose the underlying network topology.

Each message also has a subscription choice group that will define the
type of data that is being published.

Each MQTT message can be a collection of DataSubscription structs. This
collection is represented as DataBatch in the CDDL. 

~~~~ CDDL
{::include cddl/data_subscription.cddl}
~~~~
{:cddl}

## CBOR Examples

This section contains a few examples of the DataSubscription struct 
depicted in CBOR diagnostic notation.

~~~
[
  {
    "data": h'02011A020A0C16FF4C001007721F41B0392078',
    "deviceID": "1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30",
    "timestamp": 1727484393,
    "bleAdvertisement": {
        "macAddress": "C1:5C:00:00:00:01",
        "rssi": -25
    }
  }
]
~~~
{: title="Onboarded BLE Device Advertisement" }

~~~
[
  {
    "data": h'02011A020A0C16FF4C001007721F41B0392078',
    "timestamp": 1727484393,
    "bleAdvertisement": {
        "macAddress": "C1:5C:00:00:00:01",
        "rssi": -25
    }
  }
]
~~~
{: title="Non-onboarded BLE Device Advertisement" }

~~~
[
  {
    "data": h'434630374346303739453036',
    "deviceID": "1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30",
    "timestamp": 1727484393,
    "bleSubscription": {
        "serviceID": "a4e649f4-4be5-11e5-885d-feff819cdc9f",
        "characteristicID": "c4c1f6e2-4be5-11e5-885d-feff819cdc9f"
    }
  }
]
~~~
{: title="BLE GATT Notification" }

~~~
[
  {
    "deviceID": "1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30",
    "timestamp": 1727484393,
    "bleConnectionStatus": {
        "macAddress": "C1:5C:00:00:00:01",
        "connected": true
    }
  }
]
~~~
{: title="BLE Connection status event" }

~~~
[
  {
    "data": h'434630374346303739453036',
    "deviceID": "1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30",
    "timestamp": 1727484393,
    "zigbeeSubscription": {
        "endpointID": 1,
        "clusterID": 6,
        "attributeID": 12,
        "type": 1
    }
  }
]
~~~
{: title="Zigbee Attribute Notification" }

# Examples

This section contains a few examples on how applications can leverage 
NIPC operations to communicate with BLE and Zigbee devices.

## Property Read/Write

In this example, we will connect to a device and read and write from a
property.

The sequence of operations for this are:  

  - Onboard a device using the SCIM Interface (out of scope of this
    memo)
  - Register an SDF model for the device

    ~~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    POST /registrations/models
    Content-Type: application/sdf+json
    Accept: application/nipc+json
    Host: localhost

    { ... }

    HTTP/1.1 200 OK
    content-type: application/nipc+json

    [
      {
        "sdfName": "https://example.com/thermometer#/sdfThing/thermom\
    eter"
      }
    ]
    ~~~~~

    Request Body: JSON object with the SDF model, from {{thermometer-sdf}}

  - Read a property from the BLE device

    ~~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    GET /devices/1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30/properties?prop\
    ertyName=https%3A%2F%2Fexample.com%2Fthermometer%23%2FsdfThing%2F\
    thermometer%2FsdfProperty%2Fdevice_name
    Accept: application/nipc+json
    Host: localhost

    HTTP/1.1 200 OK
    content-type: application/nipc+json

    [
      {
        "property": "https://example.com/thermometer#/sdfThing/thermo\
    meter/sdfProperty/device_name",
        "value": "dGVzdA=="
      }
    ]
    ~~~~~
 
  - Write to a property on the BLE device

    ~~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    PUT /devices/1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30/properties
    Content-Type: application/nipc+json
    Host: localhost

    [
      {
        "property": "https://example.com/thermometer#/sdfThing/thermo\
    meter/sdfProperty/device_name",
        "value": "dGVzdA=="
      }
    ]

    HTTP/1.1 200 OK
    content-type: application/nipc+json

    [
      {
        "property": "https://example.com/thermometer#/sdfThing/thermo\
    meter/sdfProperty/device_name",
        "value": "dGVzdA=="
      }
    ]
    ~~~~~

## Enabling an Event on a Device

In this example, we will onboard a device, and setup an advertisement
subscription event for that device.

The sequence of operations for this are:  

  - Onboard a device and endpoint app using the SCIM Interface (out of scope of this
   memo)
  - Register an SDF model for the device

    ~~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    POST /registrations/models
    Content-Type: application/sdf+json
    Accept: application/nipc+json
    Host: localhost

    { ... }

    HTTP/1.1 200 OK
    content-type: application/nipc+json

    [
      {
        "sdfName": "https://example.com/thermometer#/sdfThing/thermom\
    eter"
      }
    ]
    ~~~~~

    Request Body: JSON object with the SDF model, from {{thermometer-sdf}}
    
  - Register the data app with the event 

    ~~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    POST /registrations/data-apps?dataAppId=0927ce7c-b258-4bfa-a345-\
    bcc9f74385b4
    Content-Type: application/nipc+json
    Accept: application/nipc+json
    Host: localhost

    {
      "events": [
        "https://example.com/thermometer#/sdfThing/thermometer/sdfEve\
    nt/isPresent"
      ],
      "mqttClient": true
    }

    HTTP/1.1 200 OK
    content-type: application/nipc+json

    {
      "events": [
        "https://example.com/thermometer#/sdfThing/thermometer/sdfEve\
    nt/isPresent"
      ],
      "mqttClient": true
    }
    ~~~~~

  - Enable the advertisement event

    ~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    POST /devices/1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30/events?eventNa\
    me=https%23%2F%2Fexample.com%2Fthermometer%23%2FsdfThing%2Fthermo\
    meter%2FsdfEvent%2FisPresent
    Host: localhost
    Content-Length: 0

    HTTP/1.1 201 Created
    Location: /devices/1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30/events?in\
    stanceId=02ee282c-8915-4b2e-bbd2-88966773134a
    ~~~~

  - Check the status of the event

    ~~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    GET /devices/1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30/events?instance\
    Id=02ee282c-8915-4b2e-bbd2-88966773134a
    Host: localhost

    HTTP/1.1 200 OK
    content-type: application/nipc+json

    {
      "event": "https://example.com/thermometer#/sdfThing/thermometer\
    /sdfEvent/isPresent"
    }
    ~~~~~

## Enabling an Event on a Group of Devices

In this example, we will enable an advertisement subscription event
for a group of devices.

The sequence of operations for this are:  

  - Onboard devices and endpoint app using the SCIM Interface (out of scope of this
   memo)
  - Register an SDF model for the devices

    ~~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    POST /registrations/models
    Content-Type: application/sdf+json
    Accept: application/nipc+json
    Host: localhost

    { ... }

    HTTP/1.1 200 OK
    content-type: application/nipc+json

    [
      {
        "sdfName": "https://example.com/thermometer#/sdfThing/thermom\
    eter"
      }
    ]
    ~~~~~

    Request Body: JSON object with the SDF model, from {{thermometer-sdf}}
    
  - Register the data app with the event 

    ~~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    POST /registrations/data-apps?dataAppId=0927ce7c-b258-4bfa-a345-\
    bcc9f74385b4
    Content-Type: application/nipc+json
    Accept: application/nipc+json
    Host: localhost

    {
      "events": [
        "https://example.com/thermometer#/sdfThing/thermometer/sdfEve\
    nt/isPresent"
      ],
      "mqttClient": true
    }

    HTTP/1.1 200 OK
    content-type: application/nipc+json

    {
      "events": [
        "https://example.com/thermometer#/sdfThing/thermometer/sdfEve\
    nt/isPresent"
      ],
      "mqttClient": true
    }
    ~~~~~

  - Enable the advertisement event on a group of devices

    ~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    POST /groups/0dc729d7-f6c3-491d-9b9d-e7176d2be243/events?eventNa\
    me=https%23%2F%2Fexample.com%2Fthermometer%23%2FsdfThing%2Fthermo\
    meter%2FsdfEvent%2FisPresent
    Host: localhost
    Content-Length: 0

    HTTP/1.1 201 Created
    Location: /groups/0dc729d7-f6c3-491d-9b9d-e7176d2be243/events?in\
    stanceId=f1b9f26b-21ce-4deb-9d57-289ba7e17cce
    ~~~~

  - Check the status of the event

    ~~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    GET /groups/0dc729d7-f6c3-491d-9b9d-e7176d2be243/events?instance\
    Id=f1b9f26b-21ce-4deb-9d57-289ba7e17cce
    Host: localhost

    HTTP/1.1 200 OK
    content-type: application/nipc+json

    [
      {
        "event": "https://example.com/heartrate#/sdfObject/healthsen\
    sor/sdfEvent/fallDetected",
        "deviceId": "1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30"
      },
      {
        "event": "https://example.com/heartrate#/sdfObject/healthsen\
    sor/sdfEvent/fallDetected",
        "deviceId": "d62c7fb2-a216-4811-a388-053b17fdbedc"
      },
      {
        "event": "https://example.com/heartrate#/sdfObject/healthsen\
    sor/sdfEvent/fallDetected",
        "deviceId": "01b52a23-b98c-454c-ba9e-086a43bdfd79"
      },
      {
        "type": "https://www.iana.org/assignments/nipc-problem-types\
    #event-not-enabled",
        "status": 400,
        "title": "Event Not Enabled",
        "deviceId": "9171ec16-e3c1-4ccf-ad23-b92a1a3f069d",
        "detail": "Failed to disable the event for device 9171ec16-e\
3c1-4ccf-ad23-b92a1a3f069d"
      }
    ]
    ~~~~~

# Implementation Status
{:removeinrfc="true"}

This section records the status of known implementations of the
protocol defined by this specification at the time of posting of
this Internet-Draft, and is based on a proposal described in
{{?RFC7942}}.  The description of implementations in this section is
intended to assist the IETF in its decision processes in
progressing drafts to RFCs.  Please note that the listing of any
individual implementation here does not imply endorsement by the
IETF.  Furthermore, no effort has been spent to verify the
information presented here that was supplied by IETF contributors.
This is not intended as, and must not be construed to be, a
catalog of available implementations or their features.  Readers
are advised to note that other implementations may exist.

According to {{?RFC7942}}, "this will allow reviewers and working
groups to assign due consideration to documents that have the
benefit of running code, which may serve as evidence of valuable
experimentation and feedback that have made the implemented
protocols more mature.  It is up to the individual working groups
to use this information as they see fit".

## TieDie IoT

Organization: Cisco Systems, North Carolina State University

Description: Open-source implementation of the NIPC APIs and gateway functionality for BLE. Client libraries for Python and Java are also provided.

Level of maturity: Open-source prototype

Coverage: All NIPC APIs for BLE protocol mapping

Version compatibility: All versions up to draft-14

Licensing: Apache License, Version 2.0

URL: [](https://github.com/iot-onboarding/tiedie)

## Cisco Sensor Connect for IoT Services

Organization: Cisco Systems

Description: Commercial solution that delivers advanced BLE capabilities over Cisco Wireless infrastructure.

Level of maturity: Beta

Coverage: All NIPC APIs for BLE protocol mapping

Version compatibility: draft-12, draft-13, draft-14

Licensing: Proprietary

URL: [](https://developer.cisco.com/docs/spaces-connect-for-iot-services/)

# Security Considerations {#security-considerations}

## API authorization 

In order to enable a network wishing to offer NIPC ALG functions, the network
administrator authorizes application(s) to perform operations on the Gateway.
This happens out of band and may be accomplished by means of exchanging tokens
or public keys.
Authorization can be role-based. The 3 primary roles are:  

1. Onboarding: Authorize an onboarding application against a SCIM server
   co-located with the gateway.  
2. Control: Authorize applications that may control devices.
3. Data: Authorize applications that may receive telemetry.  
It is possible to further refine roles down to an API basis.

# IANA Considerations

This section provides guidance to the Internet Assigned Numbers Authority
(IANA) regarding registration of values related to NIPC, in accordance
with {{!RFC8126}}.

## Media Type Registration {#iana-media-types}

This document registers the "application/nipc+json" media type 
for messages of the NIPC APIs defined in this document carrying
parameters encoded in JSON. 

Type name: application

Subtype name: nipc+json

Required parameters: none

Optional parameters: none

Encoding considerations: Encoding considerations are identical to those specified for the "application/json" media type.

Security considerations: See the {{security-considerations}} section of this document.

Interoperability considerations: none

Published specification: This document, the NIPC API specification.

Applications that use this media type:

Fragment identifier considerations: none

Additional information:

- Deprecated alias names for this type: none
 
- Magic number(s): none

- File extension(s): none

- Macintosh file type code(s): none

Person & email address to contact for further information:

Intended usage: LIMITED USE

Restrictions on usage: To be used for NIPC APIs as defined in this document.

Author:

Change controller: IETF

## API extensions {#iana-api-ext}

IANA is requested to create a new registry called "NIPC API extensions". 

The registry must contain following attributes:

- Extension URI 
- Extension name
- Description
- Openapi model describing the extension. This model must be reviewed by an expert.  

Following API extensions are described in this document:

| Extension URI                                | Extension name       | Description                                    | Model reference    |
|----------------------------------------------|----------------------|------------------------------------------------|--------------------|
| /extensions/{id}/bulk                         | Bulk API             | Call multiple NIPC's in a single request       | {{NIPCextensions}} |
| /extensions/{id}/properties/file              | File write API       | Write a file with multiple property ops        | {{NIPCextensions}} |
| /extensions/{id}/properties/blob              | Binary write API     | Write a binary blob with multiple property ops | {{NIPCextensions}} |
| /extensions/{id}/properties/read/conditional | Read conditional API | Read a property until a condition is fulfilled | {{NIPCextensions}} |
| /extensions/{id}/events/conditional          | Event conditional API| Enable an event until a condition is fulfilled | {{NIPCextensions}} |
| /extensions/{id}/transmit                 | Transmit API         | Transmits a payload to a device                | {{NIPCextensions}} |

## Well-known URIs {#iana-well-known}

IANA is requested to register the following well-known URI in the "Well-Known URIs" registry as defined by {{!RFC8615}}:

| URI Suffix | Change Controller | Specification Document            |
|------------|-------------------|-----------------------------------|
| nipc       | IETF              | This document, [](#paths-general) |

The well-known URI for NIPC is:

    /.well-known/nipc

## Problem Details for NIPC APIs {#iana-problem-details}

IANA is requested to create a new registry, the "NIPC Problem Type" registry, 
with following URL: [](https://www.iana.org/assignments/nipc-problem-types).

Registrations MUST use the prefix []("https://iana.org/assignments/nipc-problem-types#") for the type URI. 

The registration requests MUST use the template defined in {{Section 4.2 of RFC9457}}.

IANA is requested to register the following URIs in the "NIPC Problem Type" 
registry:

| Problem Type URI                                                                 | Description                                  | Reference         |
|----------------------------------------------------------------------------------|----------------------------------------------|-------------------|
| https://www.iana.org/assignments/nipc-problem-types#invalid-id              | Invalid device ID or gateway doesn't recognize the ID | This document   |
| https://www.iana.org/assignments/nipc-problem-types#invalid-sdf-url         | Invalid SDF URL or SDF affordance not found   | This document   |
| https://www.iana.org/assignments/nipc-problem-types#extension-operation-not-executed | Operation was not executed since the previous operation failed | This document   |
| https://www.iana.org/assignments/nipc-problem-types#sdf-model-already-registered | SDF model already registered                  | This document   |
| https://www.iana.org/assignments/nipc-problem-types#sdf-model-in-use        | SDF model in use                              | This document   |
| https://www.iana.org/assignments/nipc-problem-types#unsupported-uri-scheme  | Unsupported URI scheme                        | This document   |
| https://www.iana.org/assignments/nipc-problem-types#property-not-readable   | Property not readable                         | This document   |
| https://www.iana.org/assignments/nipc-problem-types#property-read-failed    | Property read failed                          | This document   |
| https://www.iana.org/assignments/nipc-problem-types#property-not-writable   | Property not writable                         | This document   |
| https://www.iana.org/assignments/nipc-problem-types#property-write-failed   | Property write failed                         | This document   |
| https://www.iana.org/assignments/nipc-problem-types#event-already-enabled   | Event already enabled                         | This document   |
| https://www.iana.org/assignments/nipc-problem-types#event-not-enabled       | Event not enabled                             | This document   |
| https://www.iana.org/assignments/nipc-problem-types#event-not-registered    | Event not registered for any data application | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-ble-already-connected | Device already connected                      | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-ble-no-connection | No connection found for device                | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-ble-connection-timeout | BLE connection timeout                        | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-ble-bonding-failed | BLE bonding failed                            | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-ble-connection-failed | BLE connection failed                         | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-ble-service-discovery-failed | BLE service discovery failed                  | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-ble-invalid-service-or-characteristic | Invalid BLE service or characteristic ID      | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-zigbee-connection-timeout | Zigbee connection timeout                     | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-zigbee-invalid-endpoint-or-cluster | Invalid Zigbee endpoint or cluster ID         | This document   |
| https://www.iana.org/assignments/nipc-problem-types#extension-broadcast-invalid-data | Invalid transmit data                         | This document   |
| https://www.iana.org/assignments/nipc-problem-types#extension-firmware-rollback | Firmware rollback                             | This document   |
| https://www.iana.org/assignments/nipc-problem-types#extension-firmware-update-failed | Firmware update failed                        | This document   |

Each Problem Type URI is intended for use as the "type" member in Problem Details responses as described.

--- back

# OpenAPI definition

The following non-normative model is provide for convenience of
the implementor.

~~~~~~
<CODE BEGINS> file "openapi.yml"
{::include nipc-openapi/NIPC.yaml.folded}
<CODE ENDS>
~~~~~~
{: #openAPI}

# Protocol mapping

NIPC requires that a protocol mapping be provided as part of the SDF
model for a device or have one provided using the NIPC action APIs with 
embedded protocol mapping. The protocol mapping is a JSON object that 
describes the underlying technology used to communicate with the device 
along with any additional information needed to communicate with the 
device.

The OpenAPI model for the SDF protocol mapping is provided in {{Appendix B of I-D.ietf-asdf-sdf-protocol-mapping}}.

# NIPC API extensions {#NIPCextensions}

The following OpenAPI models define a few example extensions to the 
NIPC API.

## NIPC API write binary blob extension

~~~~~
<CODE BEGINS> file "Extension-Blob.yaml"
{::include nipc-openapi/extensions/Extension-Blob.yaml.folded}
<CODE ENDS>
~~~~~

## NIPC API bulk operations extension

~~~~~
<CODE BEGINS> file "Extension-Bulk.yaml"
{::include nipc-openapi/extensions/Extension-Bulk.yaml.folded}
<CODE ENDS>
~~~~~

## NIPC API write file extension

~~~~~
<CODE BEGINS> file "Extension-File.yaml"
{::include nipc-openapi/extensions/Extension-File.yaml.folded}
<CODE ENDS>
~~~~~

## NIPC API conditional read extension

~~~~~
<CODE BEGINS> file "Extension-ReadConditional.yaml"
{::include nipc-openapi/extensions/Extension-ReadConditional.yaml.folded}
<CODE ENDS>
~~~~~

## NIPC API conditional event extension

~~~~~
<CODE BEGINS> file "Extension-EventConditional.yaml"
{::include nipc-openapi/extensions/Extension-EventConditional.yaml.folded}
<CODE ENDS>
~~~~~

## NIPC API property extensions

~~~~~
<CODE BEGINS> file "Extension-Property.yaml"
{::include nipc-openapi/extensions/Extension-Property.yaml.folded}
<CODE ENDS>
~~~~~

# Example SDF model with protocol mappings for BLE 
{: #thermometer-sdf}

~~~~~
<CODE BEGINS> file "thermometer.sdf.json"
{::include nipc-sdf-example/thermometer.sdf.json}
<CODE ENDS>
~~~~~
{: title="Example SDF model with protocol mappings for BLE"}
