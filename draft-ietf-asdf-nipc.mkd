---
title: An Application Layer Interface for Non-Internet-Connected Physical Components (NIPC)
abbrev: NIPC
docname: draft-ietf-asdf-nipc-16
submissionType: IETF
category: std

ipr: trust200902
keyword: Internet-Draft
venue:
  group: "A Semantic Definition Format for Data and Interactions of Things"
  type: "Working Group"
  mail: "asdf@ietf.org"
  github: "ietf-wg-asdf/asdf-nipc"

stand_alone: no
pi: [toc, sortrefs, symrefs]

author:
 - 
    ins: B. Brinckman
    name: Bart Brinckman
    org: Cisco Systems
    city: Brussels
    country: Belgium
    email: bbrinckm@cisco.com
 -
    ins: R. Mohan
    name: Rohit Mohan
    org: Cisco Systems
    street: 170 West Tasman Drive
    code: 95134
    city: San Jose
    country: USA
    email: rohitmo@cisco.com
 -
    ins: B. Sanford
    name: Braeden Sanford
    org: Philips
    city: Cambridge
    country: USA
    email: braeden.sanford@philips.com

informative:
  BLE53:
    title: Bluetooth Core Specification, Version 5.3
    author:
      -
        org: Bluetooth SIG
    date: 2021
  Zigbee22:
    title: Zigbee Specification, Version 22 1.0
    author:
      -
        org: Connectivity Standards Alliance
    date: 2017
  Gatt-REST-API:
    title: A RESTful API used to access data in devices using the functionality defined in the Bluetooth GATT profile
    target: https://www.bluetooth.com/bluetooth-resources/gatt-rest-api/
    author:
      -
        org: Bluetooth SIG
    date: 2017
...

--- abstract

This memo describes an API that allows applications to perform operations against a gateway serving one or more devices described by an SDF model. The document describes a RESTful application layer interface to perform operations on those devices, as well as a CBOR-based publish-subscribe interface for streaming data. 

--- middle

# Introduction

## Motivation

Low‑power sensors, actuators, and other connected devices deployed for building management, healthcare, workplace, manufacturing, logistics, and hospitality use cases are often resource and battery constrained. Many lack native IP connectivity and instead attach via heterogeneous non‑IP operational networks. Common non‑IP protocols include BLE {{BLE53}} and Zigbee {{Zigbee22}}. When IP is available, constrained application protocols such as CoAP {{?RFC7252}} may be used. These devices still need to exchange data with IP‑based applications. Accordingly, applications on the IP network obtain telemetry from and issue operations to such devices through an application‑layer gateway. This gateway bridges the application network and one or more separate operational networks where devices are connected, allowing applications on the IP network to perform operations on devices connected to these other operational networks.

~~~~~ aasvg
                                                               
    +-------------+              +---------+              +--------+
    | Application |<------------>| Gateway |<------------>| Device |                     
    |             | Application  |         |    Device    |        |
    +-------------+   network    +---------+    network   +--------+                 

~~~~~
{: #gw title="Gateway for non-Internet-Connected Devices"}

There have been efforts to define Gateway functions for devices that support
a particular protocol, such as a BLE GATT REST API for BLE Gateways
({{Gatt-REST-API}}), however they have been limited to a single protocol or
a particular use case. In absence of an open standard describing how
applications on an IP network communicate with devices on other operational networks, bespoke and
vendor-specific implementations have proliferated. 
Each deployment then requires: (1) defining or adapting yet another API, and (2) deploying additional gateway functions, increasing operational and integration cost. 
This specification defines a single, extensible application layer interface for cross-network and cross-protocol device interaction through a network gateway. The intent is to support multiple network and network protocols (and versions) concurrently, allow incremental addition of new protocols via mapping, and reduce redundant infrastructure by enabling multiple applications to share one standardized gateway function.

A standardized Application Layer Gateway interface has the following benefits:

 1. Eliminates repeated bespoke integration effort across deployments.
 2. Avoids deploying multiple overlapping gateway functions for different networks, protocols or use cases.
 3. Reduces time and operational cost to integrate new networks and devices.

## Non-IP Gateway

A Non-Internet-Connected Physical Components (NIPC) gateway is an application layer gateway (ALG) that implements APIs for applications to communicate with devices on different networks, leveraging different protocols. These NIPC APIs consist of reading or writing properties of devices, invoking actions on devices, as well as enabling or disabling events on devices.

In order to perform NIPC operations on a device, 2 prerequisites must be fulfilled:

- The gateway has access to a device object, that contains its identity, in the form of a unique UUID and any credentials/trust material required to communicate with the device. Provisioning this device object is out of scope of this document. It may be performed via SCIM {{!RFC7644}} with {{!I-D.ietf-scim-device-model}}.
- An interaction model for the class of devices must be available to the gateway. This allows the gateway to understand how to interact with the device in a protocol-neutral way. The interaction model is provided to the gateway by means of an SDF model, described in {{!RFC9880}}.

Once these prerequisites are met, the gateway can resolve a referenced SDF affordance into the protocol-specific operations required for that device.

A NIPC gateway provides the following functions:

 - Authentication and authorization of application clients that will leverage the NIPC APIs. 
 - Maintain a repository of device objects.
 - Accept and validate SDF interaction model registrations.
 - Expose APIs for property, action, and event operations.
 - Perform implicit connection management to devices where required; optionally support explicit connection management.
 - Stream events (publish/subscribe) to authorized data applications.
 - Proxy payloads between networks without interpreting or modifying application data.
 - Operate one or more channels to supported wired or wireless networks.
 - Optionally provide a bridge between devices on one or more device networks connected to the NIPC-Gateway. This may include translating between different protocols, if multiple protocols are supported on the device network(s).

The gateway’s role is to proxy traffic between application and device networks; it is not intended to be middleware that inspects, decodes, or transforms device payloads.

~~~~~ aasvg

                         +------------------------------------------+
                         |                                          |
+-----------+   Request  |  +---------+                             |
| onboarding+-------------->|  SCIM   |                             |
|    app    |<--------------+ Server  |                             |
+-----------+  Ctrl Endpt|  +---------+                             |
                         |                                          |
+-----------+            |  +------------+   +-------+   +--------+ |
|  Control  +----REST------>|    NIPC    +-->|  AP   +-->| Device | |
|     &     |            |  |   Gateway  |   +-------+   +--------+ |
| Telemetry |<--pub/sub-----+            |                          |
|    Apps   |            |  +------------+                          |
+-----------+            |                                          |
                         |            Network Deployment            |
                         +------------------------------------------+

~~~~~
{: #arch title="Basic Architecture"}

{{arch}} illustrates the basic components: applications, the NIPC application‑layer gateway (ALG), an access point (AP), and a device (D). The applications, ALG, and AP reside on an IP network; the AP provides a wireless or wired interface to the device. Applications often operate in a different administrative domain than the ALG and AP, so the ALG will have to support authorization. The ALG bridges the IP application domain and the device network, be it an IP-based or non-IP device network. This enables applications to perform operations on devices attached to those device networks. Applications use a JSON-based {{!RFC8259}} RESTful NIPC APIs for property, action, and event operations, and a CBOR‑based {{!RFC8949}} publish/subscribe interface for event streaming.

## Terminology

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in BCP
14 {{!RFC2119}} {{!RFC8174}} when, and only when, they appear in all
capitals, as shown here.

## Glossary

 - NIPC: Non-IP Control, the application layer interface defined in this
   document.
 - NIPC Gateway: An application layer gateway that implements the NIPC
   interface.
 - SDF: Semantic Device Format, a standardized format to describe devices
   and their interaction models, as defined in {{!RFC9880}}.
 - SDF Affordance: An interaction point on a device as defined in an SDF
   model. Examples of affordances are properties, actions, and events.
 - SDF Global Name: Absolute URI (with fragment) identifying an SDF affordance.
 - SCIM: System for Cross-domain Identity Management, a standardized
   protocol to manage identity information, as defined in {{!RFC7644}}.
 - ALG: Application Layer Gateway.
 - IoT: Internet of Things.
 - Protocol Mapping / sdfProtocolMap: Mapping from protocol-neutral SDF affordances to protocol-specific operations.
 - BLE: Bluetooth Low Energy protocol.
 - Zigbee: Low-power mesh networking protocol.
 - GATT: Generic Attribute Profile used in BLE for services/characteristics/descriptors.
 - Service (BLE): Top-level GATT grouping of characteristics.
 - Characteristic (BLE): GATT data element supporting read/write/notify.
 - Descriptor (BLE): Metadata element attached to a characteristic.
 - Bonding (BLE): Procedure to establish trusted, reusable security keys.
 - Service Discovery (BLE): Procedure to enumerate GATT services/characteristics/descriptors.
 - Device ID / Group ID: UUID identifying a device or a group of devices.
 - UUID: Universally unique identifier (128-bit).
 - Data Application / Data App: Registered application receiving streamed event data.
 - MQTT: Publish/subscribe messaging protocol used for streaming.
 - Webhook: HTTP callback endpoint for push delivery.
 - Websocket: Bidirectional TCP-based message channel over HTTP.
 - Publish/Subscribe Interface: Streaming channel for events (CBOR-encoded payloads).
 - CBOR: Concise Binary Object Representation; compact binary data format.
 - CDDL: Concise Data Definition Language; schema language for CBOR data.
 - JSON: JavaScript Object Notation; text encoding used for API payloads.
 - Access Point (AP): Network element with a radio interface communicating with devices.

# Architecture

## Overview

A Non‑Internet‑Connected Physical Components (NIPC) gateway is an application‑layer gateway (ALG) that exposes APIs enabling applications to perform operations on devices attached to networks connected to the gateway. NIPC defines two API categories:

- Registrations: register SDF models for classes of devices and register data applications that receive streaming event data.
- Operations: perform protocol‑neutral device interactions (read/write properties, invoke actions, enable/disable events) across heterogeneous networks and protocols.

To execute NIPC operations on a device, both prerequisites MUST be met:

1. The NIPC gateway has access to device instance information: The device object contains its identity, in the form of a unique UUID and any credentials/trust material required to communicate with the device (e.g., via SCIM {{!RFC7644}} with {{!I-D.ietf-scim-device-model}}). This device object is identified by the device ID referenced in NIPC API paths.
2. The NIPC gateway has access to an interaction model (device class information): An SDF model {{!RFC9880}} is registered, providing protocol‑neutral affordances and mappings to protocol‑specific operations.

~~~~~ aasvg

    +------------+   
    |    SCIM    |                      
    |   object   |           +----------------+          
    |    {ID}    +---------->|                |
    +------------+           | NIPC Operation |
                             |    - Property  |
                             |    - Action    |
    +------------+           |    - Event     |
    |     SDF    +---------->|                |
    |    model   |           +----------------+
    +------------+  

~~~~~
{: #prereq title="NIPC prerequisites"}

Once both prerequisites are met, authorized applications can perform NIPC operations on devices identified by their IDs. See {{security-considerations}} for authorization details. NIPC operations act on SDF affordances—properties, actions, and events—defined in the registered SDF model. Certain NIPC operations may also be performed on groups of devices identified by a group ID.

### Device instance information

In order for the NIPC gateway to perform operations on a device, it must have access to the device's instance information. This includes the device’s identity and any credentials or trust material required to communicate with the device. The device object MUST include a unique identity (UUID) and sufficient information to bootstrap trust and establish connectivity, as NIPC operations assume connectivity can be established without separate API calls. While provisioning devices instance information can be performed in various ways, it is RECOMMENDED to use SCIM {{!RFC7644}} with the device schema {{!I-D.ietf-scim-device-model}}, which defines the necessary attributes and extensions to support NIPC. As per {{Section 4.2 of !RFC7643}}, group objects may also be declared, and leveraged in NIPC operations.

### Device class information 

Device class information is declared through SDF models. These SDF models define the protocol-neutral affordances of a class of devices, as well as protocol mappings that relate these affordances to protocol-specific operations. The SDF model for a class of devices can be registered through NIPC registration APIs, as described in {{nipc-registrations}}. 

The SDF model reference and/or data‑app registration MAY also be included in a device's SCIM object. See {{!I-D.ietf-scim-device-model}} and {{!I-D.ietf-asdf-sdf-protocol-mapping}} for details.

## NIPC Registrations {#nipc-registrations}

NIPC registration APIs allow applications to register objects that are not tied to specific device instances.

NIPC supports two registration types:

1. SDF model registration: Registers an SDF interaction model for a class of devices.
2. Data application authorization: Authorizes an application to receive streaming event data.

### SDF model registrations

The SDF model for a class of devices determines how a gateway can interact with
these devices in a protocol-neutral way. To enable this, the SDF model
must contain protocol mappings, mapping protocol-neutral SDF affordances
to protocol-specific operations as defined in {{!I-D.ietf-asdf-sdf-protocol-mapping}}. 
The SDF affordances supported by the device, as well as its protocol-mappings,
are provided to the gateway by means of SDF model registration. 
SDF models are described in {{!RFC9880}}.

### Data application registrations

NIPC operations can enable or disable event reporting on a device. Events are reported through a publish-subscribe interface.
Applications that are authorized to perform NIPC operations on devices can define which applications are permitted to receive streaming event data for that device. The data-app registrations API maps an event to an application that is authorized to receive that data. The registration also defines what protocol will be used to deliver the data (e.g., MQTT, webhook, websocket). This registration basically allows applications to determine which data-streams are consumed by which data-applications.

## NIPC Operations {#nipc-ops}

### Overview {#nipc-ops-overview}

NIPC APIs are exposed over HTTP {{!RFC9110}}. Requests and responses use JSON {{!RFC8259}} unless another media type is negotiated via Content-Type and Accept. A media type for an SDF affordance can also be stipulated in the SDF ContentFormat data quality, as described in {{Section 4.7 of !RFC9880}}. The default media type is “application/nipc+json” (see {{iana-media-types}}). SDF model registrations use “application/sdf+json”. Property APIs MAY use other media types appropriate to the property payload. 

Failures use Problem Details {{!RFC9457}} with application/problem+json.

NIPC operations are protocol-neutral operations on SDF affordances, more specifically properties, actions & events. NIPC operations can happen against
affordances registered in an SDF model. Operations reference affordances by their SDF global name. If the underlying protocol requires a connection, the gateway establishes and tears down the connection implicitly unless an explicit connection is already in place.

NIPC exposes four operation groups:

- Properties APIs: These APIs allow applications to perform operations on properties, such as to read or write values to them.
- Actions APIs: These APIs perform actions on devices, such as enabling or disabling a feature on a device.
- Events APIs: These APIs allow apps to enable or disable event reporting on devices. Events are reported over the events publish/subscribe interface.
- Trigger APIs: These APIs allow an action or an event on one device to trigger an action on another device.

### Properties

Property operations allow clients to read and write values for SDF properties.

Requests and responses use application/nipc+json unless another media type is negotiated via Content‑Type and Accept.
When using JSON, binary property values are base64‑encoded with padding per {{Section 5 of !RFC4648}}.
Multiple properties MAY be read or written in a single request. When a single property is addressed via a query parameter, non‑JSON media types MAY be used for the payload.
On success, the response returns either 200 with per‑property status (JSON) or 204 No Content for single, non‑JSON writes.

### Actions

Action operations invoke SDF actions on devices.

A successful action request returns 202 Accepted with a Location header referencing the action instance.
Clients poll the instance URI to obtain status (e.g., IN_PROGRESS, COMPLETED).
Request bodies are optional and MAY carry action input in a media type appropriate to the underlying protocol (e.g., octet‑stream).

### Events

Event operations enable and disable device event reporting.

Enabling an event returns 201 Created with a Location header referencing the event instance.
Disabling an event uses the instance identifier and returns 204 No Content on success (for a single device) or 200 Success with a per‑device status list (for a group).
Event payloads are delivered via the publish/subscribe interface encoded in CBOR {{!RFC8949}}.

### Triggers

Triggers allow an action or an event on one device to trigger an action on another device. Triggers are not protocol-specific. As an example, an event on a BLE device can trigger an action on a Zigbee device.

Creating a trigger returns 201 Created with a Location header referencing the trigger instance.
Deleting a trigger uses the instance identifier and returns 204 No Content on success (for a single device) or 200 Success with a per‑device trigger list (for a group).

### Groups

Where supported by the underlying protocol, operations MAY target a group of devices identified by a group ID. Responses for group operations return per‑device results; failures for individual devices are reported using Problem Details entries within the array.

### Connection management for NIPC Operations

For protocols that require connection setup, the gateway performs implicit connection management during an operation (establish on demand; tear down on completion). Gateways MAY support explicit connection management; when an explicit connection is active, operations reuse it and do not tear it down. Explicit connection management is described in {{nipc-connection-management-apis}}.

### Extensions {#extensions}

NIPC supports API extensions for compound or specialized operations. Extensions can execute a set of NIPC operations in a single request or provide more efficient mechanisms for specific use cases (e.g., a bulk operation).

Extensions MUST use the “/extensions” path element. To ensure interoperability, extensions MUST be registered with IANA as defined in {{iana-api-ext}}.

## Events publish subscribe interface

Events are delivered via a publish/subscribe interface. NIPC events are encoded in CBOR ({{!RFC8949}}) and can be transported over MQTT, Webhook or Websocket.

CBOR is used for the publish/subscribe interface as Non-IP payloads are typically binary. CBOR encodes binary payloads efficiently, and is more compact than JSON, therefore reducing the amount of data that needs to be transmitted to the application.

Event types include:

- Streaming data from devices: Streaming data is activated/deactivated with the NIPC events API
- Broadcasts from devices (e.g., advertisements in BLE)
- Connection events: Devices connecting & disconnecting

## Paths

### General {#paths-general}

The NIPC HTTP protocol is described in terms of a path relative to a Base URI.
The Base URI MUST NOT contain a query string, as clients MAY append additional 
path information and query parameters as part of forming the request.  The base
URI is a URL that most often consists of the "https" protocol scheme, a domain
name, and an initial path {{!RFC3986}}.  That initial path for NIPC is 
recommended to be /nipc.
For example:

      "https://example.com/nipc/"

Additionally a version number may be added, for example: 

      "https://example.com/nipc/v1/"

After the base or version number, the path must contain a collection identifier.
The collection identifier can be one of the following:

- /registrations: for NIPC registration APIs
- /devices: for NIPC operations on devices
- /groups: for NIPC operations on groups of devices
- /extensions: for NIPC extension APIs

The well-known URI `/.well-known/nipc` defined in {{iana-well-known}} can
be used to discover the base path of the NIPC APIs and the supported versions
and extensions. The response to a GET request on this URI MUST be a JSON
document that contains the base path, and optionally the supported versions and  
extension APIs. The paths MUST be a URI template as defined in {{!RFC6570}}.
The following is an example of a template defining the NIPC base path as well
as supported extensions on a server.

~~~~~ json
{
  "base_path": "/nipc",
  "versions": [
    "/v1"
  ],
  "extensions": [
    "/extensions/{id}/bulk",
    "/extensions/{id}/properties/blob",
    "/extensions/{id}/properties/file",
    "/extensions/{id}/properties/read/conditional",
    "/extensions/{id}/events/conditional",
    "/extensions/{id}/properties/write"
  ]
}
~~~~~
{: #ex-wellknown title="Example response for /.well-known/nipc" sourcecode-markers="true"}

A formal CBOR definition of the well-known response is as follows:

~~~~ cddl
{::include cddl/nipc_well_known.cddl.folded}
~~~~
{:cddl sourcecode-markers="true" sourcecode-name="nipc_well_known.cddl"}

### NIPC Registrations {#nipc-registrations-paths}

Registrations leverage the base path + /registrations. NIPC supports SDF model
registrations and data-app registrations.

paths:

- /registrations/models
- /registrations/data-apps

### NIPC Operations

Every NIPC Operations API pertains to either a device or group of devices, identified by
an ID, hence the ID must be reflected as the first parameter in the path. 
For example:

      "https://example.com/nipc/v1/{id}"

The second parameter in the path refers to the NIPC operation that the API will
perform on the device. This can be:

 - properties
 - events
 - actions
 - triggers
 - extensions

These are described in {{nipc-ops}}.

## Schema

The NIPC schema leans heavily on the SDF schema, as defined in
{{!RFC9880}}. NIPC operations map directly to SDF affordances.

### SDF model registrations

To execute NIPC operations, an SDF interaction model for the device class MUST be registered. The model MUST include protocol mappings that relate protocol‑neutral SDF affordances to protocol‑specific operations.

Registration is performed via POST /registrations/models with the SDF model in the request body. A registered model can be retrieved via GET /registrations/models using the model identifier (sdfName).

### NIPC Operations

NIPC operations require two parameters:

1. Device ID: the UUID identifying the target device (or group).
2. sdfName: the SDF global name (absolute URI with fragment) of the affordance (property, action, or event) on which the operation acts.

#### Device ID

All NIPC operations are executed against a device or a group of devices.
Devices or groups of devices are identified by a unique UUID, adhering to {{!RFC9562}}.

| Attribute     | Type |          Example                     |
|---------------+------+--------------------------------------|
| id            | uuid | 1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30 |
{: #devicedef title="Definition of a device or group of devices"}

ID is a UUID assigned to uniquely identify a device to the NIPC Gateway (e.g., by a SCIM server) and the application calling the APIs. The NIPC Gateway must have access to a device object identified by this device ID and the application must store this UUID in order to use it to identify the device on which it wants to perform NIPC operations.

#### SDF Name

Operations act on SDF affordances and reference them by SDF global name—an absolute URI with fragment that includes the namespace. The affordance referenced MAY be a property, action, or event; the reference is carried as a string.

For example:

| NIPC Operation | Example SDF Name used in the API                                              |
|-----------|------------------------------------------------------------------------------------|
| Property  | https://example.com/heartrate#/<br/>sdfObject/thermostat/sdfProperty/temperature   |
| Event     | https://example.com/heartrate#<br/>/sdfObject/healthsensor/sdfEvent/fallDetected   |
| Action    | https://example.com/heartrate#/<br/>sdfObject/thermostat/sdfAction/resetThermostat |
{: #nipcopsdef title="Example SDF names for NIPC operations"}

### Parameters

To minimize deployment risk arising from inconsistent URI path normalization and handling of percent‑encoded reserved characters in path elements (notably “/” encoded as “%2F”) across common HTTP servers and intermediaries (e.g., Jetty, Tomcat, Apache httpd, NGINX), NIPC uses query parameters (except the primary {id} path segment) rather than additional path segments for values that can legitimately contain reserved characters (such as SDF global names). Although {{?RFC3986}} and {{?RFC9110}} require that reserved characters not be normalized or decoded in ways that alter semantics, misinterpretation of these rules has led to security vulnerabilities (path confusion, cache poisoning, authorization bypass) and to conservative default configurations that reject encoded slashes. In proxy deployments, relaxing these defaults often triggers security review friction. Representing such values in the query component avoids reliance on tolerant path normalization behavior, reduces ambiguity for intermediaries, and aligns with prevailing “safe” operational profiles; a malformed or unsupported parameter can be rejected with a 4xx status without exposing downstream services to traversal or normalization discrepancies.

### Responses  {#responses}

A NIPC Gateway must respond to a NIPC operation request synchronously, and provide the result of the completed operation in the HTTP response. 

Exceptions to this are the following:

1. Extensions: Extension APIs (see {{apiextensions}}) execute compound operations and thus require the gateway to execute multiple
NIPC operations. On acceptance, the gateway returns 202 Accepted. Clients poll the extension URI (GET) for execution status. If a callback URI was supplied in the request, the gateway MAY send the final result upon completion.
2. Actions: Action requests return 202 Accepted with a Location header pointing to the action instance used for status tracking.

A failure response must contain an HTTP status code of 4xx or 5xx, and use {{!RFC9457}} Problem Details with `application/problem+json` media type. 

All NIPC failure responses must include the following attributes:

- type: a URI identifying the error (see {{errorhandling}})
- status: the 4xx or 5xx HTTP status code
- title: a brief, human‑readable summary
- detail: a human‑readable explanation specific to this occurrence
Additional attributes MAY be included as permitted by {{!RFC9457}}.

~~~~ cddl
{::include cddl/api/failure_response.cddl.folded}
~~~~
{:cddl sourcecode-markers="true" sourcecode-name="failure_response.cddl"}

Example of a failure response:

~~~~~ json
=============== NOTE: '\\' line wrapping per RFC 8792 ===============

{
  "type": "https://www.iana.org/assignments/nipc-problem-types#inval\
\id-id",
  "status": 400,
  "title": "Invalid Device ID",
  "detail": "Device ID 1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30 does not\
\ exist or is not a device"
}
~~~~~
{: #failure title="Example failure response" sourcecode-markers="true"}

# NIPC Registration APIs

## SDF model registrations APIs

SDF model registration APIs allow applications to register an SDF model for a class of devices.
These APIs use the `application/sdf+json` media type, as described in {{Section 7.1 of RFC9880}}.

### Register an SDF model

Method: `POST /registrations/models`

Description: Registers one or more SDF models for a class of devices.

Request Body:

 - The SDF document in JSON format containing one or more sdfThings or sdfObjects, similar to the example in {{thermometer-sdf}}.
 - The SDF document MUST contain protocol mappings, as described in {{!I-D.ietf-asdf-sdf-protocol-mapping}}.

Response:

A list containing objects where each object has an "sdfName" which is the global name of the top-level sdfThing or sdfObject in the SDF model.

~~~~ cddl
{::include cddl/api/sdf_reference.cddl.folded}
~~~~
{:cddl sourcecode-markers="true" sourcecode-name="sdf_reference.cddl"}

Example of a response:

~~~~~ json
[
 {
  "sdfName": "https://example.com/heartrate#/sdfObject/healthsensor"
 }
]
~~~~~
{:json #exregresp title="Example of a response to an SDF model registration" sourcecode-markers="true"}

### Get all SDF models

Method: `GET /registrations/models`

Description: Gets all SDF models registered with the gateway.

Response:

A list containing objects where each object has an "sdfName" which is the global name of the top-level sdfThing or sdfObject in the SDF model.

~~~~ cddl
{::include cddl/api/sdf_reference.cddl.folded}
~~~~
{:cddl sourcecode-markers="true" sourcecode-name="sdf_reference.cddl"}

Example of a response:

~~~~~ json
[
 {
  "sdfName": "https://example.com/heartrate#/sdfObject/healthsensor"
 },
 {
  "sdfName": "https://example.com/thermometer#/sdfObject/thermometer"
 }
]
~~~~~
{:json #exgetallresp title="Example of a response to get all SDF models" sourcecode-markers="true"}


### Get an SDF model

Method: `GET /registrations/models{?sdfName}`

Description: Gets an SDF model registered with the gateway.

Query Parameters:

 - sdfName: the name of the top-level sdfThing or sdfObject in the SDF model.

Response:

 - The SDF model is returned in JSON format, similar to the example in {{thermometer-sdf}}.

### Delete an SDF model

Method: `DELETE /registrations/models{?sdfName}`

Description: Deletes an SDF model registered with the gateway.

Query Parameters:

 - sdfName: the name of the top-level sdfThing or sdfObject in the SDF model.

Response:

 - A list containing objects where each object has an "sdfName" which is the global name of the top-level sdfThing or sdfObject in the SDF model

~~~~ cddl
{::include cddl/api/sdf_reference.cddl.folded}
~~~~
{:cddl sourcecode-markers="true" sourcecode-name="sdf_reference.cddl"}

Example of a response:

~~~~~ json
{
  "sdfName": "https://example.com/heartrate#/sdfObject/healthsensor"
}
~~~~~
{:json #exregdelresp title="Example of a response to an SDF model registration" sourcecode-markers="true"}

### Update an SDF model

Method: `PUT /registrations/models{?sdfName}`

Description: Updates an SDF model registered with the gateway.

Query Parameters:

 - sdfName: the name of the top-level sdfThing or sdfObject in the SDF model.

Request Body:

 - An SDF model in JSON format, similar to the example in {{thermometer-sdf}}.

Response:

 - A list containing objects where each object has an "sdfName" which is the global name of the top-level sdfThing or sdfObject in the SDF model

~~~~ cddl
{::include cddl/api/sdf_reference.cddl.folded}
~~~~
{:cddl sourcecode-markers="true" sourcecode-name="sdf_reference.cddl"}

Example of a response:

~~~~~ json
{
  "sdfName": "https://example.com/heartrate#/sdfObject/healthsensor"
}
~~~~~
{:json #exregupresp title="Example of a response to an SDF model registration" sourcecode-markers="true"}

## Data application registrations APIs

Data-app registration APIs allow applications to register a data application that will receive streaming data from the gateway. These APIs operate on a data app ID. This ID corresponds to the endpoint app ID of the telemetry endpoint app that is registered with the SCIM server as an authorized endpoint that can receive data for a device. The endpoint app is defined in {{Section 6 of I-D.ietf-scim-device-model}}.

Apart from the endpoint app ID, the API also configures the protocol the data-app supports. These should be one of the following:

- mqttClient: The data-app is an MQTT client, which means that the NIPC gateway must act as an MQTT broker.
- mqttBroker: The data-app is an MQTT broker, which means that the NIPC gateway must act as an MQTT client. The MQTT broker configuration data, such as the URI, credentials and MQTT topic must also be provided in the registration API.
- webhook: The data-app supports a webhook the gateway can publish to. The registration API has to include the webhook URI & credentials.
- websocket: The data-app supports a websocket interface. The registration API has to include the websocket URI & credentials.

### Register a data application {#register-data-app}

Method: `POST /registrations/data-apps{?dataAppId}`

Description: Registers a data application with the gateway.

Query Parameters:

 - dataAppId: the ID of the data application

Request Body:

 - events: a list of events that the data application is authorized for.
 - mqttClient: a boolean that denotes that the data application is an MQTT client.
 - mqttBroker: The data app is an MQTT broker. This object contains the MQTT broker information:
    - URI: the URI of the MQTT broker.
    - username: the username to authenticate with the MQTT broker.
    - password: the password to authenticate with the MQTT broker.
    - brokerCACert: the base64-encoded CA certificate of the MQTT broker (optional).
    - customTopic: By default, the topic will be composed of `data-app/<dataAppId>/<namespace>/<json_pointer_to_sdf_event>`, as described in {{nipc-event-apis}}. In this attribute, a custom topic can be configured (optional).
 - webhook: The data app supports a webhook. This object contains a webhook URL along with any credentials that are required to authenticate the webhook. 
    - URI: the webhook URI. The URI MUST include the scheme used by the webhook server (e.g., "https://"). It is up to the implementation to support different schemes. If a scheme is not supported, the NIPC gateway MUST return an error response with type "https://www.iana.org/assignments/nipc-problem-types#unsupported-uri-scheme".
    - headers: An object that contains the headers to be sent with the webhook request. The headers can contain any authentication information required by the webhook server. Each header is represented as a key-value pair in the object.
    - serverCACert: the CA certificate of the webhook server, encoded as per {{!RFC7468}} and newlines encoded as '\n' (optional)
 - websocket: The data app supports a websocket. This object contains a websocket URL along with any credentials that are required to authenticate the websocket. 
   The websocket URL is the endpoint where the streaming data will be sent.
    - URI: the websocket URI. The URI MUST include the scheme used by the websocket server (e.g., "wss://"). It is up to the implementation to support different schemes. If a scheme is not supported, the NIPC gateway MUST return an error response with type "https://www.iana.org/assignments/nipc-problem-types#unsupported-uri-scheme".
    - headers: An object that contains the headers to be sent with the websocket request. The headers can contain any authentication information required by the websocket server. Each header is represented as a key-value pair in the object.
    - serverCACert: the CA certificate of the websocket server, encoded as per {{!RFC7468}} and newlines encoded as '\n' (optional)

~~~~ cddl
{::include cddl/api/data_app.cddl.folded}
~~~~
{:cddl sourcecode-markers="true" sourcecode-name="data_app.cddl"}

Example of a request body:

~~~~~ json
=============== NOTE: '\' line wrapping per RFC 8792 ================

{
  "events": [
    {
      "event": "https://example.com/heartrate#/sdfObject/healthsenso\
r/sdfEvent/fallDetected"
    }
  ],
  "mqttClient": true
}
~~~~~
{:json #exregmqttclientrsp title="Example with mqttClient" sourcecode-markers="true"}

Example of a request body for a data application that is an MQTT broker:

~~~~~ json
=============== NOTE: '\' line wrapping per RFC 8792 ================

{
  "events": [
    {
      "event": "https://example.com/heartrate#/sdfObject/healthsenso\
r/sdfEvent/fallDetected"
    }
  ],
  "mqttBroker": {
    "URI": "mqtt.example.com:1883",
    "username": "user",
    "password": "password",
    "customTopic": "custom/topic"
  }
}
~~~~~
{:json #exregmqttbrokerrsp title="Example with mqttBroker" sourcecode-markers="true"}

Response:

 - If successful, the response will be identical to the request body. 

### Update a data application

Method: `PUT /registrations/data-apps{?dataAppId}`

Description: Updates a data application registration. 

Query Parameters:

 - dataAppId: the ID of the data application

Request Body:

 - The request body is identical to the request body for the register data application API {{register-data-app}}.

Response:

 - If successful, the response will be identical to the request body.

### Get a data application

Method: `GET /registrations/data-apps{?dataAppId}`

Description: Gets a data application object registered with the gateway.

Query Parameters:

 - dataAppId: the ID of the data application

Response:

  The response will be identical to the request body for the register data application API {{register-data-app}}.

### Delete a data application

Method: `DELETE /registrations/data-apps{?dataAppId}`

Description: Deletes a data application registered with the gateway.

Query Parameters:

 - dataAppId: the ID of the data application

Response:

 - If successful, the response will be identical to the request body for the register data application API {{register-data-app}}.

# NIPC Operation APIs

The NIPC operation APIs perform protocol‑neutral interactions on SDF affordances, properties, events, and actions. This allows applications to read and update device properties, invoke actions, and consume events.

NIPC defines three API collections aligned with the SDF Affordances defined in {{Section 1.2 of !RFC9880}}:

 - Properties: read and write device properties.
 - Events: enable and disable device event reporting.
 - Actions: invoke device actions.

To invoke NIPC operations APIs on a device, one or more SDF models MUST be registered for that device. The SDF model MAY have a top‑level sdfThing (with multiple sdfObjects) or a top‑level sdfObject. Operations depend on affordances (sdfProperty, sdfEvent, sdfAction) defined in the registered SDF model and on a device ID (see {{!I-D.ietf-scim-device-model}}). Affordances are referenced by their SDF global name (absolute URI with fragment) as described in {{Section 4 of !RFC9880}}.

The NIPC Gateway must match the SDF global name against the registered SDF model to resolve the protocol mapping (protocolmap) the gateway will execute. When carried in a URI, the SDF global name MUST be percent‑encoded per {{Section 2.1 of !RFC3986}}.

## NIPC Property APIs

These APIs allow applications to read and update device properties. If the underlying protocol requires a connection, the gateway establishes it implicitly for the operation; when an explicit connection is already active, operations reuse it without modification.

Requests and responses support content negotiation via Content-Type and Accept. 
When using "application/nipc+json", payloads must follow the examples above. Binary property values must be base64‑encoded with padding per {{Section 5 of !RFC4648}} in the "value" field. For other media types, payload semantics must follow the selected media type.

### Update one or multiple values

Method: `PUT /devices/{id}/properties{?propertyName}`

Description: Write values to one or more properties on a device

Parameters:

 - id: the ID of the device

Query Parameters:

 - propertyName: Identifies a single property to update. If present, the request body MAY use any media type appropriate to the property payload.

 -or-

 - If absent, the request body MUST be application/nipc+json and contain an array of update items, each with a property and a value.

Request Body:

  - If the query parameter propertyName is provided, the request body MAY use any media type appropriate to the property payload. The value is encoded as per the content type of the payload.

 -or-

  - If the query parameter propertyName is NOT provided, the request body must be an array of properties to update, each containing a property and a value. The value attribute contains the raw binary data, which must be encoded in base64 with padding as per {{Section 5 of !RFC4648}}.

~~~~ cddl
{::include cddl/api/property_value_array.cddl.folded}
~~~~
{:cddl sourcecode-markers="true" sourcecode-name="property_value_array.cddl"}

Example body for updating multiple properties:

~~~~~ json
=============== NOTE: '\' line wrapping per RFC 8792 ================

[
  {
    "property": "https://example.com/heartrate#/sdfObject/thermostat\
/sdfProperty/temperature",
    "value": "dGVzdA=="
  },
  {
    "property": "https://example.com/heartrate#/sdfObject/thermostat\
/sdfProperty/humidity",
    "value": "eGVzdB=="
  }
]
~~~~~
{:json #exupmprop title="Example updating multiple properties" sourcecode-markers="true"}

Response:

 - If the Accept header is set to `application/nipc+json`, the response must be an array with a status field set to 200 for each property that was updated, or a problem type object for each property that failed to update. The "properties" array must be an array of properties that were updated, each containing a property and a value.

 -or-

 - If the Accept header is set to any other media type and the propertyName query parameter is provided, the response must be 204 No Content with no body.

~~~~ cddl
{::include cddl/api/property_value_response_array.cddl.folded}
~~~~
{:cddl sourcecode-markers="true" sourcecode-name="property_value_response_array.cddl"}

Example of a response:

~~~~~ json
=============== NOTE: '\' line wrapping per RFC 8792 ================

[
  {
    "status": 200
  },
  {
    "type": "https://www.iana.org/assignments/nipc-problem-types#inv\
alid-property",
    "status": 400,
    "title": "Invalid Property",
    "detail": "Property https://example.com/heartrate#/sdfObject/the\
rmostat/sdfProperty/temperature does not exist or is not writable"
  }
]
~~~~~
{:json #exupmresp title="Example update multiple properties response" sourcecode-markers="true"}

### Read one or multiple values

Method: `GET /devices/{id}/properties{?propertyName*}`

Description: Read values from one or more properties on a device

Parameters:

 - id: the ID of the device

Query Parameters:

 - propertyName: The property to read. This can be a single property or multiple properties. If multiple properties are provided, the request body MUST contain an application/nipc+json payload with an array of properties to read.

Response:

 - If the Accept header is set to `application/nipc+json`, the response must be an array of properties, each containing a property and a value. The value must be the raw binary data read from the property, encoded in base64 with padding as per {{Section 5 of !RFC4648}}. The array must contain objects with 2 attributes:
       - property: The property that was read.
       - value: The bytes that were read in base64 encoding

 -or-

 - If the Accept header is set to any other media type and a single propertyName query parameter is provided, the request body MAY use any media type appropriate to the property payload. The value is encoded as per the content type of the payload.

~~~~ cddl
{::include cddl/api/property_value_read_response_array.cddl.folded}
~~~~
{:cddl sourcecode-markers="true" sourcecode-name="property_value_read_response_array.cddl"} 

Example of a response:

~~~~~ json
=============== NOTE: '\' line wrapping per RFC 8792 ================

[
  {
    "property": "https://example.com/heartrate#/sdfObject/thermostat\
/sdfProperty/temperature",
    "value": "dGVzdA=="
  },
  {
    "property": "https://example.com/heartrate#/sdfObject/thermostat\
/sdfProperty/humidity",
    "value": "eGVzdB=="
  }
]
~~~~~
{:json #exreadmresp title="Example read multiple properties response" sourcecode-markers="true"}

## NIPC Event APIs {#nipc-event-apis}

Event APIs enable or disable reporting of device events. For certain protocols, a connection may be required. If the underlying protocol requires a connection, the gateway establishes it implicitly for the operation. If an explicitly created connection is already active, it is reused without modification.

Events are referenced by the SDF global name of an sdfEvent. The {id} path segment identifies a device or a group of devices. A group event MAY be enabled only if the underlying protocol supports group activation (e.g., BLE advertisement or connection status events).

If the data application registered for this event is an MQTT broker or client, the event SDF global name may be used to construct the MQTT topic for the event. The topic is constructed using the data application ID, the default namespace for the event, and the event itself. 
For example, if the data application ID is "0927ce7c-b258-4bfa-a345-bcc9f74385b4"
and the event is "https://example.com/thermometer#/sdfThing/thermometer/sdfEvent/isPresent", the topic will be:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

data-app/<dataAppId>/<namespace>/<json_pointer_to_sdf_event>

data-app/0927ce7c-b258-4bfa-a345-bcc9f74385b4/thermometer/sdfThing/\
thermometer/sdfEvent/isPresent
~~~~~

A data application may subscribe to this topic using the topic or it  may use MQTT wildcards to subscribe to `data-app/+/temperature/#` to receive all events for the `temperature` namespace.

If a customTopic was supplied in the data‑app registration (mqttBroker case), that topic MUST be used instead of the constructed default.

### Enable event reporting

Method: `POST /devices/{id}/events{?eventName}`

Description: Enables an event on a device

Parameters:

 - id: the ID of the device

Query Parameters:

 - eventName: the event to enable. The eventName must be a URL encoded string that is the absolute URI that is the global name of an `sdfEvent`. 

Response:

 - Returns HTTP status code 201 Created with a Location header pointing to the created event instance.

Example of a successful response:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

HTTP/1.1 201 Created
Location: /devices/1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30/events?insta\
nceId=02ee282c-8915-4b2e-bbd2-88966773134a
~~~~~

The Location header must contain the URI for the created event instance, which may be used to check status or disable the event.

### Disable event reporting

Method: `DELETE /devices/{id}/events{?instanceId}`

Description: Disables an event on a device

Parameters:

 - id: the ID of the device or group of devices

Query Parameters:

 - instanceId: the instance ID of the event to disable (obtained from the Location header when the event was enabled)

Response:

 - Returns HTTP status code 204 No Content on successful disable.

~~~~~
HTTP/1.1 204 No Content
~~~~~

### Get status of one or more events

Method: `GET /devices/{id}/events{?instanceId*}`

Description: Get the status of one or more events on a specific device

Parameters:

 - id: the ID of the device or group of devices

Query Parameters:

 - instanceId: a comma separated list of event instance IDs to filter by (optional)

Response: 
The response must be an array of events, each containing an instanceID and an event.
 - instanceId: must be the unique instance ID for each enabled event.
 - event: must be the event URI for each enabled event.

~~~~ cddl
{::include cddl/api/event_status_array.cddl.folded}
~~~~
{:cddl sourcecode-markers="true" sourcecode-name="event_status_array.cddl"}

Example of a response:

~~~~~ json
=============== NOTE: '\' line wrapping per RFC 8792 ================

[
  {
    "instanceId": "02ee282c-8915-4b2e-bbd2-88966773134a",
    "event": "https://example.com/heartrate#/sdfObject/healthsensor/\
sdfEvent/fallDetected"
  }
]
~~~~~
{:json #exgetmresp title="Example get multiple events status response" sourcecode-markers="true"}

### Enable event reporting on a group of devices

Method: `POST /groups/{id}/events`

Description: Enables an event on a group of devices

Parameters:

 - id: the ID of the group of devices

Query Parameters:

 - eventName: the event to enable. The eventName is a URL encoded string that is the absolute URI that is the global
name of an `sdfEvent`. 

Response:

 - The response must return HTTP status code 201 Created with a Location header pointing to the created event instance. The Location header must contain the URI for the created event instance, which can be used to check status or disable the event.

Example of a successful response:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

HTTP/1.1 201 Created
Location: /groups/0dc729d7-f6c3-491d-9b9d-e7176d2be243/events?instan\
ceId=f1b9f26b-21ce-4deb-9d57-289ba7e17cce
~~~~~

### Disable event reporting on a group of devices

Method: `DELETE /groups/{id}/events{?instanceId}`

Description: Disables an event on a group of devices

Parameters:

 - id: the ID of the group of devices

Query Parameters:

 - instanceId: the instance ID of the event to disable (obtained from the Location header when the event was enabled)

Response:

MUST return 200 OK with an array of per‑device event status entries. For each device where the event was successfully disabled, the entry MUST include deviceId and event (SDF global name). For each device where disabling failed, the entry MUST be a Problem Details error object for that device.

~~~~ cddl
{::include cddl/api/group_event_status_response_array.cddl.folded}
~~~~
{:cddl sourcecode-markers="true" sourcecode-name="group_event_status_response_array.cddl"}

Example of a response:

~~~~~ json
=============== NOTE: '\' line wrapping per RFC 8792 ================

[
  {
    "event": "https://example.com/heartrate#/sdfObject/healthsensor/\
sdfEvent/fallDetected",
    "deviceId": "1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30"
  },
  {
    "event": "https://example.com/heartrate#/sdfObject/healthsensor/\
sdfEvent/fallDetected",
    "deviceId": "d62c7fb2-a216-4811-a388-053b17fdbedc"
  },
  {
    "event": "https://example.com/heartrate#/sdfObject/healthsensor/\
sdfEvent/fallDetected",
    "deviceId": "01b52a23-b98c-454c-ba9e-086a43bdfd79"
  },
  {
    "type": "https://www.iana.org/assignments/nipc-problem-types#eve\
nt-not-enabled",
    "status": 400,
    "title": "Event Not Enabled",
    "deviceId": "9171ec16-e3c1-4ccf-ad23-b92a1a3f069d",
    "detail": "Failed to disable the event for device 9171ec16-e3c1-\
    4ccf-ad23-b92a1a3f069d"
  }
]
~~~~~

### Get event status on a group of devices

Method: `GET /groups/{id}/events{?instanceId}`

Description: Get the status of one or more events for a group of devices

Parameters:

 - id: the ID of the group of devices

Query Parameters:

 - instanceId: the instance ID of the event to disable (obtained from the Location header when the event was enabled).

Response: 

MUST return 200 OK with an array of per‑device event status entries. For each device where the event was successfully enabled, the entry MUST include deviceId and event (SDF global name). For each device where enabling failed, the entry MUST be a Problem Details error object for that device.

~~~~ cddl
{::include cddl/api/group_event_status_response_array.cddl.folded}
~~~~
{:cddl sourcecode-markers="true" sourcecode-name="group_event_status_response_array.cddl"} 

Example of a response:

~~~~~ json
=============== NOTE: '\' line wrapping per RFC 8792 ================

[
  {
    "event": "https://example.com/heartrate#/sdfObject/healthsensor/\
sdfEvent/fallDetected",
    "deviceId": "1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30"
  },
  {
    "event": "https://example.com/heartrate#/sdfObject/healthsensor/\
sdfEvent/fallDetected",
    "deviceId": "d62c7fb2-a216-4811-a388-053b17fdbedc"
  },
  {
    "event": "https://example.com/heartrate#/sdfObject/healthsensor/\
sdfEvent/fallDetected",
    "deviceId": "01b52a23-b98c-454c-ba9e-086a43bdfd79"
  },
  {
    "type": "https://www.iana.org/assignments/nipc-problem-types#eve\
nt-not-enabled",
    "status": 400,
    "title": "Event Not Enabled",
    "deviceId": "9171ec16-e3c1-4ccf-ad23-b92a1a3f069d",
    "detail": "Failed to disable the event for device 9171ec16-e3c1-\
4ccf-ad23-b92a1a3f069d"
  }
]
~~~~~
{:json #exgetmgevntsresp title="Example get multiple group events status response" sourcecode-markers="true"}

## NIPC Action APIs

NIPC Action APIs invoke device actions. If the underlying protocol requires a connection, the gateway establishes it implicitly for the operation. If an explicitly established connection is already active, the operation MUST reuse it without modification.

### Perform an action

Method: `POST /devices/{id}/actions{?actionName}`

Description: Perform an action on a specific device

Parameters:

  - id: the ID of the device

Query Parameters:

  - actionName: the action to perform

Request Body:

The request body is optional and may contain a value. The media type of the value can be defined by the underlying protocol, for example it could be octet-stream for binary data.

Response:

Actions are performed asynchronously. A successful request returns HTTP status code 202 Accepted with a Location header pointing to the action instance for status checking. The Location header contains the URI for the action instance, which can be used to check the action status.

Example of a successful response:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

HTTP/1.1 202 Accepted
Location: /devices/1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30/actions?inst\
anceId=02ee282c-8915-4b2e-bbd2-88966773134a
~~~~~

### Check action status

Method: `GET /devices/{id}/actions{?instanceId}`

Description: Check the status of an action on a specific device

Parameters:

  - id: the ID of the device

Query Parameters:

  - instanceId: the instance ID of the action (obtained from the Location header)

Response:
MUST return 200 OK with an action status, which may be "in progress" or "completed".

~~~~ cddl
{::include cddl/api/action_response.cddl.folded}
~~~~
{:cddl sourcecode-markers="true" sourcecode-name="action_response.cddl"}

Example of a response:

~~~~~ json
{
  "status": "COMPLETED"
}
~~~~~
{:json #exactionstatusresp title="Example action status response" sourcecode-markers="true"}

## NIPC Trigger APIs

Triggers APIs do not actually execute an operation on a device or group of devices, but install a trigger that registers an operation. When triggered the registered operation gets executed. 

Triggers can be installed for devices or groups of devices, represented by their id as a path parameter.

The trigger can be an action or an event. the global name of the trigger is passed as a path parameter. 

The operation is always an action. Since an action can be executed against both a device and a group, the trigger API also supports actions on both devices and groups of devices. The action is defined by its full NIPC URI to be executed, for example: "/devices/3171ec43-42a5-4415-ab4b-afd0dfbe9615/actions?actionName=https://example.com/AlarmSystem#/sdfObject/bell/sdfAction/ring"

If a NIPC Gateway supports multiple protocols, then a trigger can be defined on a devices that supports one protocol and triggers an action on a device that supports a different protocol. As an example, an event on a BLE device can trigger an action on a Zigbee device.

### Create a trigger on a device

Method: `POST /devices/{id}/triggers{?sdfName}`

Description: Creates a trigger on an affordance of a device. A trigger will trigger an action on another device or a group of devices.

Parameters:

 - id: the ID of the device

Query Parameters:

 - sdfName: the sdfName of the affordance that is associated with the trigger. This can be either an event or an action. the event to enable. The sdfName must be a URL encoded string that is the absolute URI that is the global name of an `sdfEvent` or an `sdfAction`. 

Request Body:
  
 - The request body must be of type 'application/nipc+json', and contain an action object. The action object contains a NIPC URI to be executed, including the device or group id and actionname percent-encoded query parameter. 

~~~~ cddl
{::include cddl/api/action.cddl.folded}
~~~~
{:cddl sourcecode-markers="true" sourcecode-name="action.cddl"}

Example body for trigger creation:

~~~~~ json
=============== NOTE: '\' line wrapping per RFC 8792 ================

{
  "action": "/devices/3171ec43-42a5-4415-ab4b-afd0dfbe9615/actions?a\
ctionName=https%3A%2F%2Fexample.com%2FAlarmSystem%23%2FsdfObject%2Fb\
ell%2FsdfAction%2Fring"
}
~~~~~
{:json #excreatetrigger title="Example trigger creation" sourcecode-markers="true"}

Response:

 - Returns HTTP status code 201 Created with a Location header pointing to the created trigger instance.

Example of a successful response:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

HTTP/1.1 201 Created
Location: /devices/1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30/trigger?inst\
anceId=02ee282c-8915-4b2e-bbd2-88966773134a
~~~~~

The Location header must contain the URI for the created trigger instance, which may be used to check status or disable the event.

### Delete a trigger on a device

Method: `DELETE /devices/{id}/triggers{?instanceId}`

Description: Deletes an installed trigger

Parameters:

 - id: the ID of the device

Query Parameters:

 - instanceId: the instance ID of the trigger to disable (obtained from the Location header when the trigger was installed)

Response:

 - Returns HTTP status code 204 No Content on successful delete.

~~~~~
HTTP/1.1 204 No Content
~~~~~

### Get installed triggers for a device

Method: `GET /devices/{id}/triggers{?instanceId}`

Description: Get the installed triggers for a devices, or a specific trigger when specifying an instanceId.

Parameters:

 - id: the ID of the device

Query Parameters:

 - instanceId: an InstanceID, or comma separated list of event instance IDs to filter by (optional)
 - If no query parameter is supplied, then all triggers for the device must be retrieved

Response: 

The response must be an array of triggers, each containing an instanceId, the sdfName of an affordance and an action.

 - instanceId: must be the instance ID for each installed trigger, as returned by the NIPC GW when the trigger was created.
 - sdfName: must be the sdfName of the affordance (event or action) that is associated with the trigger.
 - action: must be the NIPC URI of the action to be executed when the trigger is activated.

~~~~ cddl
{::include cddl/api/trigger_status_array.cddl.folded}
~~~~
{:cddl sourcecode-markers="true" sourcecode-name="trigger_status_array.cddl"}

Example of a response:

~~~~~ json
=============== NOTE: '\' line wrapping per RFC 8792 ================

[
  {
    "instanceId": "02ee282c-8915-4b2e-bbd2-88966773134a",
    "sdfName": "https://example.com/heartrate#/sdfObject/healthsenso\
r",
    "action": "/devices/3171ec43-42a5-4415-ab4b-afd0dfbe9615/actions\
?actionName=https%3A%2F%2Fexample.com%2FAlarmSystem%23%2FsdfObject%2\
Fbell%2FsdfAction%2Fring"
  }
]
~~~~~
{:json #exgetmtriggers title="Example get multiple triggers response" sourcecode-markers="true"}

### Create a trigger on a group of devices

Method: `POST /groups/{id}/triggers{?sdfName}`

Description: Creates a trigger on an affordance of a group of devices. A trigger will trigger an action on another device or a group of devices.

Parameters:

 - id: the ID of the group of devices

Query Parameters:

 - sdfName: the sdfName of the affordance that is associated with the trigger. This can be either an event or an action. the event to enable. The sdfName must be a URL encoded string that is the absolute URI that is the global name of an `sdfEvent` or an `sdfAction`. 

Request Body:
  
 - The request body must be of type 'application/nipc+json', and contain an action object. The action object contains a NIPC URI to be executed, including the device or group id and actionname percent-encoded query parameter. 

~~~~ cddl
{::include cddl/api/action.cddl.folded}
~~~~
{:cddl sourcecode-markers="true" sourcecode-name="action.cddl"}

Example body for trigger creation:

~~~~~ json
=============== NOTE: '\' line wrapping per RFC 8792 ================

{
  "action": "/groups/3171ec43-42a5-4415-ab4b-afd0dfbe9615/actions?ac\
tionName=https%3A%2F%2Fexample.com%2FAlarmSystem%23%2FsdfObject%2Fbe\
ll%2FsdfAction%2Fring"
}
~~~~~
{:json #excreategrouptrigger title="Example trigger creation" sourcecode-markers="true"}

Response:

 - Returns HTTP status code 201 Created with a Location header pointing to the created trigger instance.

Example of a successful response:

~~~~~
=============== NOTE: '\' line wrapping per RFC 8792 ================

HTTP/1.1 201 Created
Location: /devices/1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30/trigger?inst\
anceId=02ee282c-8915-4b2e-bbd2-88966773134a
~~~~~

The Location header must contain the URI for the created trigger instance, which may be used to check status or disable the event.

### Delete a trigger on a group of devices

Method: `DELETE /groups/{id}/triggers{?instanceId}`

Description: Deletes an installed trigger

Parameters:

 - id: the ID of the group of devices

Query Parameters:

 - instanceId: the instance ID of the trigger to disable (obtained from the Location header when the trigger was installed)

Response:

 - Returns HTTP status code 204 No Content on successful delete.

~~~~~
HTTP/1.1 204 No Content
~~~~~

### Get installed triggers for a group of devices

Method: `GET /groups/{id}/triggers{?instanceId}`

Description: Get the installed triggers for a group of devices, or a specific trigger when specifying an instanceId.

Parameters:

 - id: the ID of the group of devices

Query Parameters:

 - instanceId: an InstanceID, or comma separated list of event instance IDs to filter by (optional)
 - If no query parameter is supplied, then all triggers for the group of devices must be retrieved

Response: 

The response must be an array of triggers, each containing an instanceId, the sdfName of an affordance and an action.
 - instanceId: must be the instance ID for each installed trigger, as returned by the NIPC GW when the trigger was created.
 - sdfName: must be the sdfName of the affordance (event or action) that is associated with the trigger.
 - action: must be the NIPC URI of the action to be executed when the trigger is activated.

~~~~ cddl
{::include cddl/api/trigger_status_array.cddl.folded}
~~~~
{:cddl sourcecode-markers="true" sourcecode-name="trigger_status_array.cddl"}

Example of a response:

~~~~~ json
=============== NOTE: '\' line wrapping per RFC 8792 ================

[
  {
    "instanceId": "02ee282c-8915-4b2e-bbd2-88966773134a",
    "sdfName": "https://example.com/heartrate#/sdfObject/healthsenso\
r",
    "action": "/devices/3171ec43-42a5-4415-ab4b-afd0dfbe9615/actions\
?actionName=https%3A%2F%2Fexample.com%2FAlarmSystem%23%2FsdfObject%2\
Fbell%2FsdfAction%2Fring"
  }
]
~~~~~
{:json #exgetmgrouptriggers title="Example get multiple group triggers response" sourcecode-markers="true"}

## NIPC explicit connection management APIs {#nipc-connection-management-apis}

Some protocols do not require explicit connection setup; for those protocols, the APIs in this section do not apply. For protocols that do require a connection (e.g., BLE), an NIPC gateway performs implicit connection management for individual operations (establish on demand; release on completion), so clients ordinarily need not manage connections. Clients MAY choose to explicitly establish and retain a connection to perform a sequence of operations that depends on intermediate results. This section specifies APIs for explicit connection lifecycle control. Examples use BLE.

### Protocol Information Object {#protocol-information-obj}
The protocol information object is used to define protocol specific parameters for connections. The protocol information object is protocol specific and defined in the protocol extensions. An example of where a protocol info object would be used is to return protocol specific connection parameters when making connections, for example a BLE service map. An example of a BLE protocol information object is shown below.

This specification defines both the BLE and the Zigbee protocol information objects for connections and broadcast messages.

~~~~ cddl
{::include cddl/api/protocolinfo.cddl.folded}
~~~~
{:cddl sourcecode-markers="true" sourcecode-name="protocolinfo.cddl"}   

### Connect to a device

Method: `POST /devices/{id}/connections`

Description: Connect to a device

Parameters:

  - id: the ID of the device

Request Body:

  - Connection retry parameters
  - A protocol info object representing the BLE service map to be discovered. In the case of BLE, if no protocol info object is included, service discovery is performed to discover all supported properties when connecting to a device. Optionally, service discovery may be limited to properties defined in the "ble" protocol extension. The services to be discovered can be added in an array. Property discovery can be buffered across connections, so the API also supports caching parameters. 

~~~~ cddl
{::include cddl/api/connection.cddl.folded}
~~~~
{:cddl sourcecode-markers="true" sourcecode-name="connection.cddl"}

Example body of a connection without specific discovery of properties:

~~~~~ json
{
  "retries": 3
}
~~~~~
{:json #exconn title="Example connection" sourcecode-markers="true"}

where-

 - "retries" defines the number of retries in case the operation does not 
   succeed

In case the application would like to discover specific properties of a device, an additional protocol information object can be provided that defines what properties should be discovered.

Example body of a BLE connection with specific discovery of properties:

~~~~~ json
{
  "retries": 3,
  "protocolInformation": {
    "ble": {
      "services": [
        {
          "serviceID": "00001809-0000-1000-8000-00805f9b34fb"
        }
      ],
      "cached": false,
      "cacheExpiryDuration": 3600,
      "autoUpdate": true,
      "bonding": "default"
    }
  }
}
~~~~~
{:json #exconnprp title="Example connection with explicit discovery of connections" sourcecode-markers="true"}

where in the BLE protocol object: 

 - "services" is an array of services defined by their serviceIDs.
 - "cached" refers to whether the services need to be discovered for this connection.
   If cached is true, the services will be discovered for this connection only if it is not present in the cache.
   If cached is false, the services will be discovered for this connection.
   The services will be cached once it is discovered.
 - "cacheExpiryDuration" defines how long (in seconds) the cache should be maintained 
   before purging.
 - some devices support notifications on changes in services, 
   "autoUpdate" allows the network to update services based on 
   notification (on by default)
 - "bonding" allows you to override the bonding method configured in the device object. Possible values are default, none, justworks, passkey, oob. Default behavior is to use the bonding method defined in the device object.
    
Response:

Success responses includes an optional protocol information object with an array of discovered properties, as defined in the BLE protocol info object in section {{protocol-information-obj}}.
This is an array of supported services, which in turn contains an array of characteristics, which in turn contains an array of descriptors, as shown in {{BLEservices}}.

~~~~~
    services
     - serviceID
        |
        |> characteristics
            - characteristicID
            - flags
               |
               |> Descriptors
                   - descriptorID
~~~~~
{: #BLEservices title="BLE Services"}

Example of a response:

~~~~~ json
{
  "id": "1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30",
  "protocolInformation": {
    "ble": {
      "services": [
        {
          "serviceID": "00001809-0000-1000-8000-00805f9b34fb",
          "characteristics": [
            {
              "characteristicID": 
                  "00002a1c-0000-1000-8000-00805f9b34fb",
              "flags": [
                "read",
                "write"
              ],
              "descriptors": [
                {
                  "descriptorID": 
                      "00002902-0000-1000-8000-00805f9b34fb"
                }
              ]
            }
          ]
        }
      ]
    }
  }
}
~~~~~
{:json #exconnresp title="Example connection response" sourcecode-markers="true"}

where-

  - "id" is the ID of the device
  - "protocolInformation" contains an Array of BLE services as shown in
   {{BLEservices}}

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Update a connection

Method: `PUT /devices/{id}/connections`

Description: Update a connection, for BLE this will update the cached ServiceMap for a device. Full service discovery will be performed, unless specific services are described in the API body.

Parameters:

  - id: the ID of the device

Request Body:

  - A protocol information object. In the case of BLE, if no protocol information is included, service discovery is performed to discover all supported properties when connecting to a device. Optionally, service discovery may be limited to properties defined in the "ble" protocol extension. The services to be discovered can be added in an array. Property discovery can be buffered across connections, so the API also supports caching parameters.

Example body of an update connection:

~~~~~ json
{
  "protocolInformation": {
    "ble": {
      "services": [
        {
          "serviceID": "00001809-0000-1000-8000-00805f9b34fb"
        }
      ],
      "cached": false,
      "cacheExpiryDuration": 3600,
      "autoUpdate": true
    }
  }
}
~~~~~
{:json #exupconn title="Example service discovery response" sourcecode-markers="true"}

where in the BLE protocol object: 

 - "services" is an array of services defined by their serviceIDs
 - "cached" refers to whether the services need to be cached for 
   subsequent connects, in order not to perform service discovery on
   each request
 - "cacheExpiryDuration" defines how long the cache should be maintained 
   before purging
 - some devices support notifications on changes in services, 
   "autoUpdate" allows the network to update services based on 
   notification (on by default)

Response:

Success responses include a protocol mapping with an array of 
discovered properties, as defined in the specific protocol.
For example, for BLE, this is an array of supported services, which in turn
contains an array of characteristics, which in turn contains an array of
descriptors, as shown in {{BLEservices}}.

Example of a response:

~~~~~ json
{
  "id": "1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30",
  "protocolInformation": {
    "ble": {
      "services": [
        {
          "serviceID": "00001809-0000-1000-8000-00805f9b34fb",
          "characteristics": [
            {
              "characteristicID": 
                "00002a1c-0000-1000-8000-00805f9b34fb",
              "flags": [
                "read",
                "write"
              ],
              "descriptors": [
                {
                  "descriptorID": 
                    "00002902-0000-1000-8000-00805f9b34fb"
                }
              ]
            }
          ]
        }
      ]
    }
  }
}
~~~~~
{:json #exupconnresp title="Example connection response" sourcecode-markers="true"}

where-

  - "id" is the ID of the device
  - "protocolInformation" contains an Array of BLE services as shown in
   {{BLEservices}} and described in {{protocol-information-obj}}.

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Disconnect from a device

Method: `DELETE /devices/{id}/connections`

Description: Disconnect from a device

Parameters:

  - id: the ID of the device

Response:

Returns HTTP status code 200 OK with device ID on successful disconnect.

Example of a response:

~~~~~ json
{
  "id": "1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30"
}
~~~~~
{:json #exdisconnresp title="Example disconnect response" sourcecode-markers="true"}

where "id" is the ID of the device.

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

### Get connection status

Method: `GET /devices/{id}/connections`

Description: Get connection status for a device. Success when device(s)
is/are connected, includes service map for the device if available.
Failure when a device is not connected.

Parameters:

  - id: the ID of the device

Response:

Example of a response:

~~~~~ json
{
  "id": "1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30",
  "protocolInformation": {
    "ble": {
      "services": [
        {
          "serviceID": "00001809-0000-1000-8000-00805f9b34fb",
          "characteristics": [
            {
              "characteristicID": 
                "00002a1c-0000-1000-8000-00805f9b34fb",
              "flags": [
                "read",
                "write"
              ],
              "descriptors": [
                {
                  "descriptorID": 
                    "00002902-0000-1000-8000-00805f9b34fb"
                }
              ]
            }
          ]
        }
      ]
    }
  }
}
~~~~~
{:json #exconnstatresp title="Example connection status response" sourcecode-markers="true"}

where-

  - "id" is the ID of the device
  - "protocolInformation" contains an Array of BLE services as shown in {{BLEservices}}

A failure will generate a standard failed response. Please refer to {{failure}}
definition of failed response.

# NIPC Extensibility

NIPC is designed to be extensible in two complementary ways:

 - Protocol mappings: NIPC relies on SDF protocol mappings to relate protocol‑neutral affordances to protocol‑specific operations. Adding a new mapping enables support for additional device protocols (or versions) without the need to change the NIPC API itself. This allows deployments to evolve as device ecosystems change, while preserving application portability and gateway interoperability. Protocol mapping is an extension to SDF and described in {{!I-D.ietf-asdf-sdf-protocol-mapping}}.

 - API extensions: Extensions compose multiple NIPC operations into a single request or introduce specialized flows optimized for common scenarios (e.g., bulk property updates, conditional reads, firmware operations). Extensions MUST use the “/extensions” path element and SHOULD focus on efficiency, latency reduction, and operational simplicity (fewer round trips, reduced state management). To ensure interoperability and consistent security review, extensions MUST be registered with IANA as defined in {{iana-api-ext}}.

## Protocol mappings

NIPC relies on SDF protocol mappings {{!I-D.ietf-asdf-sdf-protocol-mapping}} to relate protocol‑neutral affordances to protocol‑specific operations. In {{!I-D.ietf-asdf-sdf-protocol-mapping}} BLE and Zigbee are used as examples, however the mapping mechanism is extensible; so support for additional protocols (or versions) can be added without changing the NIPC schema or API.

## API extensions {#apiextensions}

The extension APIs allow for extensibility of the APIs.
Extension APIs may leverage the basic NIPC defined APIs and combine them in compound statements in order to streamline application operation against devices, make operations more expedient and convenient in one API call. An example of this is the bulk API extension.
They may also introduce new functionality that is specific to a use case or protocol, such as the BLE transmit API.

Extensions must be defined under the /extensions path element. The extension name is defined as a path parameter after the /extensions path element. Extensions may define their own request and response payloads, as well as their own query parameters. 
Extensions must be IANA registered as defined in {{iana-api-ext}}.

Extensions MAY implement long‑running operations (e.g., firmware updates, bulk actions). For such operations, the server SHOULD respond with 202 Accepted and a Location header referencing a status URI. Clients MAY poll the status URI (GET) to obtain progress. While the operation is in progress, the status endpoint SHOULD return 200 OK with status information; upon completion, the server MAY redirect with 303 See Other to the final result resource, or return 200 OK with the completed result from the status endpoint. This pattern minimizes client state, supports retry, and provides a uniform mechanism for tracking asynchronous execution.

In the appendix {{NIPCextensions}}, we have defined a few example extensions.

# NIPC Error Handling
{: #errorhandling}

Error types in NIPC APIs must use URI-based error type identifiers as defined in {{iana-problem-details}}. The error types 
can be generic or specific to the API category. The error types are organized into the following categories:

  - Generic: Broadly applicable errors, including authorization, invalid identifiers, and generic failures.
  - Property APIs: Errors related to property APIs (read/write).
  - Event APIs: Errors related to event APIs (enable/disable).
  - Protocol specific: Errors related to protocol-specific operations.
  - Extension APIs: Errors related to extension APIs.

NIPC error types are defined in the table below:

| Error Type                                 | Description                                  | Category         |
|--------------------------------------------|----------------------------------------------|------------------|
| invalid-id                                 | Invalid device ID or gateway doesn't recognize the ID | Generic          |
| invalid-sdf-url                            | Invalid SDF URL or SDF affordance not found   | Generic           |
| extension-operation-not-executed           | Operation was not executed since the previous operation failed | Generic |
| sdf-model-already-registered               | SDF model already registered                  | Generic           |
| sdf-model-in-use                           | SDF model in use                              | Generic           |
| unsupported-uri-scheme                     | Unsupported URI scheme                        | Generic           |
| property-not-readable                      | Property not readable                         | Property APIs     |
| property-not-writable                      | Property not writable                         | Property APIs     |
| event-already-enabled                      | Event already enabled                         | Event APIs        |
| event-not-enabled                          | Event not enabled                             | Event APIs        |
| event-not-registered                       | Event not registered for any data application | Event APIs        |
| protocolmap-ble-already-connected          | Device already connected                      | Protocol specific |
| protocolmap-ble-no-connection              | No connection found for device                | Protocol specific |
| protocolmap-ble-connection-timeout         | BLE connection timeout                        | Protocol specific |
| protocolmap-ble-bonding-failed             | BLE bonding failed                            | Protocol specific |
| protocolmap-ble-connection-failed          | BLE connection failed                         | Protocol specific |
| protocolmap-ble-service-discovery-failed   | BLE service discovery failed                  | Protocol specific |
| protocolmap-ble-invalid-service-or-characteristic | Invalid BLE service or characteristic ID | Protocol specific     |
| protocolmap-zigbee-connection-timeout      | Zigbee connection timeout                     | Protocol specific |
| protocolmap-zigbee-invalid-endpoint-or-cluster | Invalid Zigbee endpoint or cluster ID     | Protocol specific |
| extension-transmit-invalid-data            | Invalid transmit data                         | Transmit APIs     |
| extension-firmware-rollback                | Firmware rollback                             | Extension APIs    |
| extension-firmware-update-failed           | Firmware update failed                        | Extension APIs    |
{: #errorcodes title="Error Codes"}

The appropriate HTTP status code is returned in the response. 

# Publish/Subscribe Interface

Events are delivered via a publish/subscribe interface. Event types include: (1) streaming data (enabled/disabled via the NIPC Events API), (2) broadcasts (e.g., advertisements), and (3) connection status (device link up/down). Event payloads are encoded in CBOR {{!RFC8949}} and MAY be transported over MQTT, webhook, or websocket. CBOR is used because non‑IP device payloads are typically binary; it encodes such data efficiently and is more compact than JSON, reducing bandwidth. 

## CDDL Definition {#cddl-data-subscription}

The event streaming format is defined here in CDDL {{!RFC8610}}.
A DataSubscription is a CBOR map containing the raw payload (bytes) and a timestamp (epoch seconds). It MAY include deviceID (the SCIM device identifier) when the payload is associated with a known device. Optional members (e.g., apMacAddress, rssi) MAY be present but can reveal deployment topology and SHOULD be omitted unless required. A choice group within DataSubscription indicates the event type (e.g., advertisement, subscription notification, connection status). An event publication MAY carry one or more DataSubscription entries in an array. Such an array is represented as DataBatch.

The subscription type choice uses a CDDL socket ($$subscription-extension) to allow extensibility. New subscription types registered with IANA (see {{iana-data-subscription-types}}) can be added using the CDDL plug syntax (//=) without modifying the base schema.

~~~~ cddl
{::include cddl/data_subscription.cddl.folded}
~~~~
{:cddl sourcecode-markers="true" sourcecode-name="data_subscription.cddl"}

## CBOR Examples

This section contains a few examples of the DataSubscription struct in CBOR diagnostic notation.

~~~
[
  {
    "data": h'02011A020A0C16FF4C001007721F41B0392078',
    "deviceID": "1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30",
    "timestamp": 1727484393,
    "bleAdvertisement": {
        "macAddress": "C1:5C:00:00:00:01",
        "rssi": -25
    }
  }
]
~~~
{: title="Onboarded BLE Device Advertisement"}

~~~
[
  {
    "data": h'02011A020A0C16FF4C001007721F41B0392078',
    "timestamp": 1727484393,
    "bleAdvertisement": {
        "macAddress": "C1:5C:00:00:00:01",
        "rssi": -25
    }
  }
]
~~~
{: title="Non-Onboarded BLE Device Advertisement"}

~~~
[
  {
    "data": h'434630374346303739453036',
    "deviceID": "1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30",
    "timestamp": 1727484393,
    "bleSubscription": {
        "serviceID": "a4e649f4-4be5-11e5-885d-feff819cdc9f",
        "characteristicID": "c4c1f6e2-4be5-11e5-885d-feff819cdc9f"
    }
  }
]
~~~
{: title="BLE GATT Notification"}

~~~
[
  {
    "deviceID": "1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30",
    "timestamp": 1727484393,
    "bleConnectionStatus": {
        "macAddress": "C1:5C:00:00:00:01",
        "connected": true
    }
  }
]
~~~
{: title="BLE Connection status event"}

~~~
[
  {
    "data": h'434630374346303739453036',
    "deviceID": "1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30",
    "timestamp": 1727484393,
    "zigbeeSubscription": {
        "endpointID": 1,
        "clusterID": 6,
        "attributeID": 12,
        "attributeType": 1
    }
  }
]
~~~
{: title="Zigbee Attribute Notification"}

# Examples

This section contains a few examples on how applications can leverage NIPC operations to communicate with BLE and Zigbee devices.

## Property Read/Write

In this example, we will connect to a device and read and write from a property.

The sequence of operations for this are:  

  - Declare a device instance using the SCIM Interface (out of scope of this
    memo)
  - Register an SDF model for the device

    ~~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    POST /registrations/models
    Content-Type: application/sdf+json
    Accept: application/nipc+json
    Host: localhost

    { ... }

    HTTP/1.1 200 OK
    content-type: application/nipc+json

    [
      {
        "sdfName": "https://example.com/thermometer#/sdfThing/thermom\
    eter"
      }
    ]
    ~~~~~

    Request Body: JSON object with the SDF model, from {{thermometer-sdf}}

  - Read a property from the BLE device

    ~~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    GET /devices/1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30/properties?prop\
    ertyName=https%3A%2F%2Fexample.com%2Fthermometer%23%2FsdfThing%2F\
    thermometer%2FsdfProperty%2Fdevice_name
    Accept: application/nipc+json
    Host: localhost

    HTTP/1.1 200 OK
    content-type: application/nipc+json

    [
      {
        "property": "https://example.com/thermometer#/sdfThing/thermo\
    meter/sdfProperty/device_name",
        "value": "dGVzdA=="
      }
    ]
    ~~~~~
 
  - Write to a property on the BLE device

    ~~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    PUT /devices/1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30/properties
    Content-Type: application/nipc+json
    Host: localhost

    [
      {
        "property": "https://example.com/thermometer#/sdfThing/thermo\
    meter/sdfProperty/device_name",
        "value": "dGVzdA=="
      }
    ]

    HTTP/1.1 200 OK
    content-type: application/nipc+json

    [
      {
        "property": "https://example.com/thermometer#/sdfThing/thermo\
    meter/sdfProperty/device_name",
        "value": "dGVzdA=="
      }
    ]
    ~~~~~

## Enabling an Event on a Device

In this example, we will declare a device instance, and setup an advertisement
subscription event for that device.

The sequence of operations for this are:  

  - Declaring a device instance and endpoint app using the SCIM Interface (out of scope of this
   memo)
  - Register an SDF model for the device

    ~~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    POST /registrations/models
    Content-Type: application/sdf+json
    Accept: application/nipc+json
    Host: localhost

    { ... }

    HTTP/1.1 200 OK
    content-type: application/nipc+json

    [
      {
        "sdfName": "https://example.com/thermometer#/sdfThing/thermom\
    eter"
      }
    ]
    ~~~~~

    Request Body: JSON object with the SDF model, from {{thermometer-sdf}}
    
  - Register the data app with the event 

    ~~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    POST /registrations/data-apps?dataAppId=0927ce7c-b258-4bfa-a345-\
    bcc9f74385b4
    Content-Type: application/nipc+json
    Accept: application/nipc+json
    Host: localhost

    {
      "events": [
        "https://example.com/thermometer#/sdfThing/thermometer/sdfEve\
    nt/isPresent"
      ],
      "mqttClient": true
    }

    HTTP/1.1 200 OK
    content-type: application/nipc+json

    {
      "events": [
        "https://example.com/thermometer#/sdfThing/thermometer/sdfEve\
    nt/isPresent"
      ],
      "mqttClient": true
    }
    ~~~~~

  - Enable the advertisement event

    ~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    POST /devices/1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30/events?eventNa\
    me=https%23%2F%2Fexample.com%2Fthermometer%23%2FsdfThing%2Fthermo\
    meter%2FsdfEvent%2FisPresent
    Host: localhost
    Content-Length: 0

    HTTP/1.1 201 Created
    Location: /devices/1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30/events?in\
    stanceId=02ee282c-8915-4b2e-bbd2-88966773134a
    ~~~~

  - Check the status of the event

    ~~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    GET /devices/1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30/events?instance\
    Id=02ee282c-8915-4b2e-bbd2-88966773134a
    Host: localhost

    HTTP/1.1 200 OK
    content-type: application/nipc+json

    {
      "event": "https://example.com/thermometer#/sdfThing/thermometer\
    /sdfEvent/isPresent"
    }
    ~~~~~

## Enabling an Event on a Group of Devices

In this example, we will enable an advertisement subscription event
for a group of devices.

The sequence of operations for this are:  

  - Provision a device and endpoint app using the SCIM Interface (out of scope of this
   memo)
  - Register an SDF model for the devices

    ~~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    POST /registrations/models
    Content-Type: application/sdf+json
    Accept: application/nipc+json
    Host: localhost

    { ... }

    HTTP/1.1 200 OK
    content-type: application/nipc+json

    [
      {
        "sdfName": "https://example.com/thermometer#/sdfThing/thermom\
    eter"
      }
    ]
    ~~~~~

    Request Body: JSON object with the SDF model, from {{thermometer-sdf}}
    
  - Register the data app with the event 

    ~~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    POST /registrations/data-apps?dataAppId=0927ce7c-b258-4bfa-a345-\
    bcc9f74385b4
    Content-Type: application/nipc+json
    Accept: application/nipc+json
    Host: localhost

    {
      "events": [
        "https://example.com/thermometer#/sdfThing/thermometer/sdfEve\
    nt/isPresent"
      ],
      "mqttClient": true
    }

    HTTP/1.1 200 OK
    content-type: application/nipc+json

    {
      "events": [
        "https://example.com/thermometer#/sdfThing/thermometer/sdfEve\
    nt/isPresent"
      ],
      "mqttClient": true
    }
    ~~~~~

  - Enable the advertisement event on a group of devices

    ~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    POST /groups/0dc729d7-f6c3-491d-9b9d-e7176d2be243/events?eventNa\
    me=https%23%2F%2Fexample.com%2Fthermometer%23%2FsdfThing%2Fthermo\
    meter%2FsdfEvent%2FisPresent
    Host: localhost
    Content-Length: 0

    HTTP/1.1 201 Created
    Location: /groups/0dc729d7-f6c3-491d-9b9d-e7176d2be243/events?in\
    stanceId=f1b9f26b-21ce-4deb-9d57-289ba7e17cce
    ~~~~

  - Check the status of the event

    ~~~~~
    ============== NOTE: '\' line wrapping per RFC 8792 ==============

    GET /groups/0dc729d7-f6c3-491d-9b9d-e7176d2be243/events?instance\
    Id=f1b9f26b-21ce-4deb-9d57-289ba7e17cce
    Host: localhost

    HTTP/1.1 200 OK
    content-type: application/nipc+json

    [
      {
        "event": "https://example.com/heartrate#/sdfObject/healthsen\
    sor/sdfEvent/fallDetected",
        "deviceId": "1d3b2c36-8a65-45a6-87c1-bcdbe0a32e30"
      },
      {
        "event": "https://example.com/heartrate#/sdfObject/healthsen\
    sor/sdfEvent/fallDetected",
        "deviceId": "d62c7fb2-a216-4811-a388-053b17fdbedc"
      },
      {
        "event": "https://example.com/heartrate#/sdfObject/healthsen\
    sor/sdfEvent/fallDetected",
        "deviceId": "01b52a23-b98c-454c-ba9e-086a43bdfd79"
      },
      {
        "type": "https://www.iana.org/assignments/nipc-problem-types\
    #event-not-enabled",
        "status": 400,
        "title": "Event Not Enabled",
        "deviceId": "9171ec16-e3c1-4ccf-ad23-b92a1a3f069d",
        "detail": "Failed to disable the event for device 9171ec16-e\
3c1-4ccf-ad23-b92a1a3f069d"
      }
    ]
    ~~~~~

# Implementation Status
{:removeinrfc="true"}

This section records the status of known implementations of the
protocol defined by this specification at the time of posting of
this Internet-Draft, and is based on a proposal described in
{{?RFC7942}}.  The description of implementations in this section is
intended to assist the IETF in its decision processes in
progressing drafts to RFCs.  Please note that the listing of any
individual implementation here does not imply endorsement by the
IETF.  Furthermore, no effort has been spent to verify the
information presented here that was supplied by IETF contributors.
This is not intended as, and must not be construed to be, a
catalog of available implementations or their features.  Readers
are advised to note that other implementations may exist.

According to {{?RFC7942}}, "this will allow reviewers and working
groups to assign due consideration to documents that have the
benefit of running code, which may serve as evidence of valuable
experimentation and feedback that have made the implemented
protocols more mature.  It is up to the individual working groups
to use this information as they see fit".

## TieDie IoT

Organization: Cisco Systems, North Carolina State University

Description: Open-source implementation of the NIPC APIs and gateway functionality for BLE. Client libraries and sample application functions for Python and Java are also provided.

Level of maturity: Open-source prototype

Coverage: All NIPC APIs for BLE protocol mapping

Version compatibility: All versions up to draft-16

Licensing: Apache License, Version 2.0

URL: [](https://github.com/iot-onboarding/tiedie)

## Cisco Sensor Connect for IoT Services (Catalyst)

Organization: Cisco Systems

Description: Commercial solution that delivers advanced BLE capabilities over Cisco Wireless infrastructure.

Level of maturity: Production

Coverage: All NIPC APIs for BLE protocol mapping

Version compatibility: draft-00

Licensing: Proprietary

URL: [](https://developer.cisco.com/docs/spaces-connect-for-iot-services/)

## Cisco Sensor Connect for IoT Services (Meraki)

Organization: Cisco Systems

Description: Commercial solution that delivers advanced BLE capabilities over Cisco Wireless infrastructure.

Level of maturity: Beta

Coverage: All NIPC APIs for BLE protocol mapping

Version compatibility: draft-16

Licensing: Proprietary

## NIPC Prototype

Organization: Ericsson Research

Description: Prototype implementation in C of the NIPC API.

Level of maturity: Research prototype

Coverage: Registration and NIPC operations

Version compatibility: Draft-04

Licensing: Proprietary

Contact: Lorenzo Corneo <lorenzo.corneo@ericsson.com>

# Security Considerations {#security-considerations}

## Payload Encryption Considerations

Responses to NIPC operations requests may contain sensitive or confidential information.  Therefore, application and device implementations should consider payload encryption.
NIPC does not provide any payload encryption mechanism. If payload encryption is required, it MUST be provided by the underlying device protocol (e.g., BLE security modes) or by the transport-layer security mechanism (e.g., TLS).

## TLS Support Considerations

NIPC MUST run on top of a transport-layer security mechanism such as TLS. When leveraging TLS, the NIPC gateway MUST support TLS 1.2 {{!RFC5246}} and TLS 1.3 {{!RFC8446}} and MAY support additional transport-layer mechanisms.  When using TLS, the client MUST perform a TLS/SSL server identity check, per {{!RFC6125}}.  Implementation security considerations for TLS can be found in {{!RFC7525}}.

## HTTP Considerations

NIPC runs on top of HTTP and is thus subject to the security considerations of HTTP {{Section 9 of !RFC7230}}.

## Authorization Considerations

### API authorization Considerations

To enable NIPC gateway functions, the network administrator MUST authorize applications (e.g., via exchange of tokens or public keys). Authorization MAY be role‑based. The following baseline roles are RECOMMENDED:

 - Provisioning: permitted to create and manage device and endpoint‑app identities via SCIM (typically co‑located with the gateway).
 - Control: permitted to invoke NIPC property, action, and event APIs.
 - Data: permitted to receive streamed event data.
Deployments MAY further refine authorization at per‑API or per‑affordance granularity.

### Authorization Token/Bearer Token/Cookie Considerations

When using authorization tokens such as those issued by OAuth 2.0 {{!RFC6749}}, implementers MUST take into account threats and countermeasures as documented in {{Section 8 of !RFC7521}}.

Since the possession of a bearer token, Authorization token, or cookie MAY authorize the holder to perform NIPC Operations on devices, tokens and cookies MUST contain sufficient entropy to prevent random guessing attack; for example, see {{Section 5.2 of !RFC6750}} and {{Section 5.1.4.2.2 of !RFC6819}}.

As with all NIPC communications, bearer tokens and HTTP cookies MUST be exchanged using transport-layer security mechanism such as TLS.

Bearer tokens MUST have a limited lifetime that can be determined directly or indirectly (e.g., by checking with a validation service) by the application.  By expiring tokens, applications are forced to obtain a new token (which usually involves re-authentication) for continued authorized access.  For example, in OAuth 2.0, an application MAY use OAuth token refresh to obtain a new bearer token after authenticating to an authorization server.  See {{Section 6 of !RFC6749}}. As with bearer tokens, an HTTP cookie SHOULD last no longer than the lifetime of a browser session.  An expiry time should be set that limits session cookie lifetime as per {{Section 5.2.1 of !RFC6265}}.

Implementations supporting OAuth bearer tokens need to factor in security considerations of this authorization method {{!RFC7521}}.
Implementers also need to consider authentication choices coupled with OAuth bearer tokens.  For example, when using OAuth bearer tokens with client authentication via client credentials {{Section 4.4 of !RFC6749}}, implementers need to consider the security considerations of client authentication via client credentials as described in Section 3.2 of {{!RFC6819}}.

## Other Security Considerations

 - Preventing automated attacks: It is recommended to limit the number of requests that any particular application MAY make in a period of time.
 - Logging and monitoring: It is recommended to log and monitor API usage to detect potential abuse or attacks.
 - Input validation: It is recommended to validate all inputs to prevent injection attacks.
 - Error handling: It is recommended to handle errors gracefully without exposing sensitive information.
 - Least privilege: It is recommended to follow the principle of least privilege when granting access to resources.
 - Storage and handling of sensitive data: Credentials MUST NOT be stored in clear-text, but MUST be stored using an encrypted protection mechanism (e.g., hashing).

# IANA Considerations

This section provides guidance to the Internet Assigned Numbers Authority (IANA) regarding registration of values related to NIPC, in accordance with {{!RFC8126}}.

## Media Type Registration {#iana-media-types}

This document registers the "application/nipc+json" media type  for messages of the NIPC APIs defined in this document carrying parameters encoded in JSON. 

Type name: application

Subtype name: nipc+json

Required parameters: none

Optional parameters: none

Encoding considerations: Encoding considerations are identical to those specified for the "application/json" media type.

Security considerations: See the {{security-considerations}} section of this document.

Interoperability considerations: none

Published specification: This document, the NIPC API specification.

Applications that use this media type: Applications implementing NIPC APIs for IoT device management.

Fragment identifier considerations: none

Additional information:

- Deprecated alias names for this type: none
 
- Magic number(s): none

- File extension(s): none

- Macintosh file type code(s): none

Person & email address to contact for further information:

Intended usage: LIMITED USE

Restrictions on usage: To be used for NIPC APIs as defined in this document.

Author:

Change controller: IETF

## API extensions {#iana-api-ext}

IANA is requested to create a new registry called "NIPC API extensions". 

The registry must contain following attributes:

- Extension URI 
- Extension name
- Description
- Openapi model describing the extension. This model must be reviewed by an expert.  

Following API extensions are described in this document:

| Extension URI                                | Extension name       | Description                                    | Model reference    |
|----------------------------------------------|----------------------|------------------------------------------------|--------------------|
| /extensions/{id}/bulk                         | Bulk API             | Call multiple NIPC's in a single request       | {{NIPCextensions}} |
| /extensions/{id}/properties/file              | File write API       | Write a file with multiple property ops        | {{NIPCextensions}} |
| /extensions/{id}/properties/blob              | Binary write API     | Write a binary blob with multiple property ops | {{NIPCextensions}} |
| /extensions/{id}/properties/read/conditional | Read conditional API | Read a property until a condition is fulfilled | {{NIPCextensions}} |
| /extensions/{id}/events/conditional          | Event conditional API| Enable an event until a condition is fulfilled | {{NIPCextensions}} |
| /extensions/{id}/transmit                 | Transmit API         | Transmits a payload to a device                | {{NIPCextensions}} |

## Well-known URIs {#iana-well-known}

IANA is requested to register the following well-known URI in the "Well-Known URIs" registry as defined by {{!RFC8615}}:

| URI Suffix | Change Controller | Specification Document            |
|------------|-------------------|-----------------------------------|
| nipc       | IETF              | This document, [](#paths-general) |

The well-known URI for NIPC is:

    /.well-known/nipc

## Data Subscription Types {#iana-data-subscription-types}

IANA is requested to create a new registry called "NIPC Data Subscription Types".

This registry tracks the subscription types used in the NIPC publish/subscribe 
interface for streaming event data from devices. Each subscription type defines 
a specific data format for a particular protocol or use case.

The registry must contain the following attributes:

- Type Name: The CDDL key name used in the subscription choice
- Description: A brief description of the subscription type
- CDDL Definition: Reference to the CDDL structure defining the subscription data
- Reference: Document defining the subscription type

IANA is requested to register the following initial entries:

| Type Name            | Description                                      | CDDL Definition     | Reference     |
|----------------------|--------------------------------------------------|---------------------|---------------|
| bleSubscription      | BLE GATT notification/indication                 | BleSubscription     | This document |
| bleAdvertisement     | BLE advertisement data                           | BleAdvertisement    | This document |
| bleConnectionStatus  | BLE device connection status changes             | BleConnectionStatus | This document |
| zigbeeSubscription   | Zigbee attribute report subscription             | ZigbeeSubscription  | This document |

The CDDL definitions for these subscription types are provided in {{cddl-data-subscription}}.

## NIPC Protocols {#iana-protocol-info-types}

IANA is requested to create a new registry called "NIPC Protocols".

This registry tracks the protocols used in the `protocolInformation` object 
for NIPC connection management and service discovery operations. Each protocol 
type defines a specific schema for protocol-specific information, as defined 
in {{protocol-information-obj}}.

The registry must contain the following attributes:

- Protocol Name: The key name used in the `protocolInformation` object
- Description: A brief description of the protocol type
- Reference: Document defining the protocol type

IANA is requested to register the following initial entries:

| Protocol Name | Description                              | Reference     |
|---------------|------------------------------------------|---------------|
| ble           | Bluetooth Low Energy                     | This document |
| zigbee        | Zigbee                                   | This document |

## Problem Details for NIPC APIs {#iana-problem-details}

IANA is requested to create a new registry, the "NIPC Problem Type" registry, 
with following URL: [](https://www.iana.org/assignments/nipc-problem-types).

Registrations MUST use the prefix []("https://iana.org/assignments/nipc-problem-types#") for the type URI. 

The registration requests MUST use the template defined in {{Section 4.2 of RFC9457}}.

IANA is requested to register the following URIs in the "NIPC Problem Type" 
registry:

| Problem Type URI                                                                 | Description                                  | Reference         |
|----------------------------------------------------------------------------------|----------------------------------------------|-------------------|
| https://www.iana.org/assignments/nipc-problem-types#invalid-id              | Invalid device ID or gateway doesn't recognize the ID | This document   |
| https://www.iana.org/assignments/nipc-problem-types#invalid-sdf-url         | Invalid SDF URL or SDF affordance not found   | This document   |
| https://www.iana.org/assignments/nipc-problem-types#extension-operation-not-executed | Operation was not executed since the previous operation failed | This document   |
| https://www.iana.org/assignments/nipc-problem-types#sdf-model-already-registered | SDF model already registered                  | This document   |
| https://www.iana.org/assignments/nipc-problem-types#sdf-model-in-use        | SDF model in use                              | This document   |
| https://www.iana.org/assignments/nipc-problem-types#unsupported-uri-scheme  | Unsupported URI scheme                        | This document   |
| https://www.iana.org/assignments/nipc-problem-types#property-not-readable   | Property not readable                         | This document   |
| https://www.iana.org/assignments/nipc-problem-types#property-read-failed    | Property read failed                          | This document   |
| https://www.iana.org/assignments/nipc-problem-types#property-not-writable   | Property not writable                         | This document   |
| https://www.iana.org/assignments/nipc-problem-types#property-write-failed   | Property write failed                         | This document   |
| https://www.iana.org/assignments/nipc-problem-types#event-already-enabled   | Event already enabled                         | This document   |
| https://www.iana.org/assignments/nipc-problem-types#event-not-enabled       | Event not enabled                             | This document   |
| https://www.iana.org/assignments/nipc-problem-types#event-not-registered    | Event not registered for any data application | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-ble-already-connected | Device already connected                      | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-ble-no-connection | No connection found for device                | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-ble-connection-timeout | BLE connection timeout                        | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-ble-bonding-failed | BLE bonding failed                            | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-ble-connection-failed | BLE connection failed                         | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-ble-service-discovery-failed | BLE service discovery failed                  | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-ble-invalid-service-or-characteristic | Invalid BLE service or characteristic ID      | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-zigbee-connection-timeout | Zigbee connection timeout                     | This document   |
| https://www.iana.org/assignments/nipc-problem-types#protocolmap-zigbee-invalid-endpoint-or-cluster | Invalid Zigbee endpoint or cluster ID         | This document   |
| https://www.iana.org/assignments/nipc-problem-types#extension-broadcast-invalid-data | Invalid transmit data                         | This document   |
| https://www.iana.org/assignments/nipc-problem-types#extension-firmware-rollback | Firmware rollback                             | This document   |
| https://www.iana.org/assignments/nipc-problem-types#extension-firmware-update-failed | Firmware update failed                        | This document   |

Each Problem Type URI is intended for use as the "type" member in Problem Details responses as described.

--- back

# OpenAPI definition

The following non-normative model is provided for convenience of the implementor.

~~~~~~
<CODE BEGINS> file "openapi.yml"
{::include nipc-openapi/NIPC.yaml.folded}
<CODE ENDS>
~~~~~~
{: #openAPI sourcecode-markers="true" sourcecode-name="NIPC.yaml"}

# Protocol Mapping

The OpenAPI model for SDF protocol mapping is provided in {{Appendix B of I-D.ietf-asdf-sdf-protocol-mapping}}.

# Protocol Information

~~~ yaml
{::include nipc-openapi/protocolinfo/ProtocolInfo.yaml.folded}
~~~
{: sourcecode-markers="true" sourcecode-name="ProtocolInfo.yaml"}

## Protocol Information for BLE

~~~ yaml
{::include nipc-openapi/protocolinfo/ProtocolInfo-BLE.yaml.folded}
~~~
{: sourcecode-markers="true" sourcecode-name="ProtocolInfo-BLE.yaml"}

## Protocol Information for Zigbee

~~~ yaml
{::include nipc-openapi/protocolinfo/ProtocolInfo-Zigbee.yaml.folded}
~~~
{: sourcecode-markers="true" sourcecode-name="ProtocolInfo-Zigbee.yaml"}

# NIPC API extensions {#NIPCextensions}

The following OpenAPI models define a few example extensions to the NIPC API.

## NIPC API write binary blob extension

~~~ yaml
{::include nipc-openapi/extensions/Extension-Blob.yaml.folded}
~~~
{: sourcecode-markers="true" sourcecode-name="Extension-Blob.yaml"}

## NIPC API bulk operations extension

~~~ yaml
{::include nipc-openapi/extensions/Extension-Bulk.yaml.folded}
~~~
{: sourcecode-markers="true" sourcecode-name="Extension-Bulk.yaml"}

## NIPC API write file extension

~~~ yaml
{::include nipc-openapi/extensions/Extension-File.yaml.folded}
~~~
{: sourcecode-markers="true" sourcecode-name="Extension-File.yaml"}

## NIPC API conditional read extension

~~~ yaml
{::include nipc-openapi/extensions/Extension-ReadConditional.yaml.folded}
~~~
{: sourcecode-markers="true" sourcecode-name="Extension-ReadConditional.yaml"}

## NIPC API conditional event extension

~~~ yaml
{::include nipc-openapi/extensions/Extension-EventConditional.yaml.folded}
~~~
{: sourcecode-markers="true" sourcecode-name="Extension-EventConditional.yaml"}

## NIPC API property extensions

~~~ yaml
{::include nipc-openapi/extensions/Extension-Property.yaml.folded}
~~~
{: sourcecode-markers="true" sourcecode-name="Extension-Property.yaml"}

# NIPC API CDDL Definition

The following is a combined reference of all NIPC API CDDL definitions used in this document.

~~~ cddl
{::include cddl/api/combined.cddl.folded}
~~~
{: sourcecode-markers="true" sourcecode-name="combined.cddl"}

# Example SDF model with protocol mappings for BLE {#thermometer-sdf}

~~~ json
{::include nipc-sdf-example/thermometer.sdf.json}
~~~
{: title="Example SDF model with protocol mappings for BLE" sourcecode-markers="true" sourcecode-name="thermometer.sdf.json" }
